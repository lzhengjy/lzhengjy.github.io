<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>框架 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="该笔记基于b站黑马程序员Java面试题视频制作        1. 单例bean是线程安全的吗？12345@Service@Scope(&quot;singleton&quot;)public class UserServiceImpl implements UserService &amp;#123;    &amp;#125;     范围 范围    singleton （默认）将每个Spring IoC容">
<meta property="og:type" content="article">
<meta property="og:title" content="框架">
<meta property="og:url" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="该笔记基于b站黑马程序员Java面试题视频制作        1. 单例bean是线程安全的吗？12345@Service@Scope(&quot;singleton&quot;)public class UserServiceImpl implements UserService &amp;#123;    &amp;#125;     范围 范围    singleton （默认）将每个Spring IoC容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928092648.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093702.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093917.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142446.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142522.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143021.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143044.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143901.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144904.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144925.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145429.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145602.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145817.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930150448.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930151957.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152105.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152520.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152852.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155116.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155653.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161252.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161332.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161555.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161751.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161915.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162014.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162117.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162915.png">
<meta property="article:published_time" content="2023-09-28T01:23:21.000Z">
<meta property="article:modified_time" content="2024-06-06T08:38:18.641Z">
<meta property="article:author" content="Zheng">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Mybatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928092648.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lzhengjy.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-框架面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-09-28T01:23:21.000Z" itemprop="datePublished">2023-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      框架
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928092648.png" style="zoom:80%;">

<br>



<hr>
<h3 id="1-单例bean是线程安全的吗？"><a href="#1-单例bean是线程安全的吗？" class="headerlink" title="1. 单例bean是线程安全的吗？"></a>1. 单例bean是线程安全的吗？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>范围</strong></th>
<th align="left"><strong>范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">（默认）将每个Spring IoC容器的单个 bean 定义范围限定为单个对象实例。</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">将单个 bean 定义的作用域限定为任意数量的对象实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个自己的 bean 实例，它是在单个 bean 定义的后面创建的。仅在可感知网络的 Spring 上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">将单个 bean 定义的范围限定为 HTTP 的生命周期 <code>Session</code>。仅在可感知网络的 Spring 上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
<tr>
<td align="left">application</td>
<td align="left">将单个 bean 定义的作用域限定为的生命周期 <code>ServletContext</code>。仅在可感知网络的Spring上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
<tr>
<td align="left">websocket</td>
<td align="left">将单个 bean 定义的作用域限定为的生命周期 <code>WebSocket</code>。仅在可感知网络的Spring上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
</tbody></table>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093702.png" style="zoom: 80%;">

<br>

<p><strong>Spring框架中的单例bean是线程安全的吗？</strong></p>
<p>不是线程安全的</p>
<p>Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。</p>
<p>因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决</p>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093917.png" style="zoom:80%;">

<br>



<hr>
<h3 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h3><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>常见的AOP使用场景：</p>
<ul>
<li>记录操作日志</li>
<li>缓存处理</li>
<li>Spring中内置的事务处理</li>
</ul>
<br>

<p>Spring支持编程式事务管理和声明式事务管理两种方式。</p>
<ul>
<li>编程式事务控制：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li>
<li>声明式事务管理：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<br>



<p><strong>什么是AOP？</strong></p>
<p>面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</p>
<br>



<p><strong>项目中有没有使用到AOP？</strong></p>
<p>记录操作日志，缓存，spring实现的事务<br>核心是：使用AOP中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取到这些参数以后，保存到数据库</p>
<br>



<p><strong>Spring中的事务是如何实现的？</strong></p>
<p>其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142446.png" style="zoom:80%;">

<br>



<hr>
<h3 id="3-Spring中事务失效的场景有哪些？"><a href="#3-Spring中事务失效的场景有哪些？" class="headerlink" title="3. Spring中事务失效的场景有哪些？"></a>3. Spring中事务失效的场景有哪些？</h3><ul>
<li>异常捕获处理</li>
<li>抛出检查异常</li>
<li>非public方法</li>
</ul>
<br>



<p><strong>情况一：异常捕获处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//转账的用户不能为空</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">fromAccount</span> <span class="operator">=</span> accountDao.selectById(from);</span><br><span class="line">        <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">        <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">            accountDao.updateById(fromAccount);</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//被转账的用户</span></span><br><span class="line">            <span class="type">Account</span> <span class="variable">toAccount</span> <span class="operator">=</span> accountDao.selectById(to);</span><br><span class="line">            toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateById(toAccount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p>
<p>解决：在catch块添加throw new RuntimeException(e)抛出</p>
<br>



<p><strong>情况二：抛出检查异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">//转账的用户不能为空</span></span><br><span class="line">    <span class="type">Account</span> <span class="variable">fromAccount</span> <span class="operator">=</span> accountDao.selectById(from);</span><br><span class="line">    <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">    <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">        accountDao.updateById(fromAccount);</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        <span class="comment">//被转账的用户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">toAccount</span> <span class="operator">=</span> accountDao.selectById(to);</span><br><span class="line">        toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateById(toAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：Spring默认只会回滚会异常检查</p>
<p>解决：配置rollbackFor属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br></pre></td></tr></table></figure>

<br>



<p><strong>情况三：非public方法导致的事务失效</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">//转账的用户不能为空</span></span><br><span class="line">    <span class="type">Account</span> <span class="variable">fromAccount</span> <span class="operator">=</span> accountDao.selectById(from);</span><br><span class="line">    <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">    <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">        accountDao.updateById(fromAccount);</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        <span class="comment">//被转账的用户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">toAccount</span> <span class="operator">=</span> accountDao.selectById(to);</span><br><span class="line">        toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateById(toAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</p>
<p>解决：改为public方法</p>
<br>



<p><strong>Spring中事务失效的场景有哪些？</strong></p>
<ol>
<li>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出</li>
<li>抛出检查异常，配置rollbackFor属性为Exception</li>
<li>非public方法导致的事务失效，改为public</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142522.png" style="zoom:80%;">

<br>



<h3 id="4-bean的生命周期"><a href="#4-bean的生命周期" class="headerlink" title="4. bean的生命周期"></a>4. bean的生命周期</h3><p>Spring容器在进行实例化时，会将xml配置的bean的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> lazy-init=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.itheima.service.UserServiceImpl&quot;</span> scope=<span class="string">&quot;singleton&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>beanClassName：bean 的类名</li>
<li>initMethodName：初始化方法名称</li>
<li>properryValues：bean 的属性值</li>
<li>scope：作用域</li>
<li>lazyInit：延迟初始化</li>
</ul>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143021.png" style="zoom:67%;">

<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143044.png" style="zoom:67%;">

<br>

<ol>
<li>通过BeanDefinition获取bean的定义信息：Spring首先通过BeanDefinition获取Bean的定义信息，包括类名、作用域、构造函数参数、属性值等</li>
<li>调用构造函数实例化bean：Spring通过反射机制调用Bean的构造函数或工厂方法来创建Bean的实例</li>
<li>bean的依赖注入：Spring将Bean的依赖注入到Bean的实例中</li>
<li>处理Aware接口：如果Bean实现了Aware接口（如BeanNameAware、BeanFactoryAware、ApplicationContextAware），Spring会调用相应的方法，让Bean获取到相关的资源<ul>
<li>BeanNameAware：实现该接口的Bean可以获取到Bean的名称</li>
<li>BeanFactoryAware：实现该接口的Bean可以获取到BeanFactory组件对象</li>
<li>ApplicationContextAware：实现该接口的Bean可以获取到ApplicationContext组件对象</li>
</ul>
</li>
<li>Bean的后置处理器BeanPostProcessor-前置：在Bean初始化之前，Spring会调用BeanPostProcessor的postProcessBeforeInitialization方法</li>
<li>初始化方法(InitializingBean、init-method)：Spring会调用Bean的初始化方法，这可能是InitializingBean接口的afterPropertiesSet方法，或者是在XML中通过init-method属性指定的方法</li>
<li>Bean的后置处理器BeanPostProcessor-后置：在Bean初始化之后，Spring会调用BeanPostProcessor的postProcessAfterInitialization方法</li>
<li>销毁bean</li>
</ol>
<br>

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143901.png" style="zoom:80%;">

<br>



<hr>
<h3 id="5-Spring的循环依赖"><a href="#5-Spring的循环依赖" class="headerlink" title="5. Spring的循环依赖"></a>5. Spring的循环依赖</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144904.png" style="zoom:67%;">

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144925.png" style="zoom:67%;">

<br>



<p><strong>三级缓存解决循环依赖</strong></p>
<p>Spring解决循环依赖是通过三级缓存，对应的三级缓存如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单实例对象注册器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>缓存名称</strong></th>
<th><strong>源码名称</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObjects</td>
<td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象（生命周期还没走完）</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td>
</tr>
</tbody></table>
<br>



<p>一级缓存作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145429.png" style="zoom:67%;">

<br>



<p>如果要想打破循环依赖, 就需要一个中间人的参与, 这个中间人就是二级缓存</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145602.png" style="zoom:67%;">

<br>



<p>三级缓存：</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145817.png" style="zoom:67%;">

<br>



<p><strong>构造方法中出现了循环依赖怎么解决？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// B成员变量</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法执行了...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.b = b ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// A成员变量</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B的构造方法执行了...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IS there an unresolvable circular reference?</span><br></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A的构造方法执行了...&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.b = b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>



<p><strong>解释一下Spring中的循环引用？</strong></p>
<ul>
<li>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</li>
<li>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖<ol>
<li>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</li>
<li>二级缓存：缓存早期的bean对象（生命周期还没走完）</li>
<li>三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</li>
</ol>
</li>
</ul>
<p><strong>如果构造方法中出现了循环引用怎么解决？</strong></p>
<p>A依赖于B，B依赖于A，注入的方式是构造函数<br>原因：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br>解决方案：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p>
<br>

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930150448.png" style="zoom:80%;">

<br>



<hr>
<h3 id="6-SpringMVC的执行流程"><a href="#6-SpringMVC的执行流程" class="headerlink" title="6. SpringMVC的执行流程"></a>6. SpringMVC的执行流程</h3><ul>
<li>视图阶段（老旧JSP等）</li>
<li>前后端分离阶段（接口开发，异步）</li>
</ul>
<br>

<p><strong>视图阶段（JSP）</strong></p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930151957.png" style="zoom:80%;">

<ol>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>Controller执行完成返回ModelAndView对象</li>
<li>HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）</li>
<li>ViewReslover解析后返回具体View（视图）</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户</li>
</ol>
<br>



<p><strong>前后端分离阶段（接口开发，异步请求）</strong></p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152105.png" style="zoom:80%;">

<ol>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>方法上添加了@ResponseBody</li>
<li>通过HttpMessageConverter来返回结果转换为JSON并响应</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152520.png" style="zoom:67%;">

<br>



<hr>
<h3 id="7-SpringBoot自动装配原理"><a href="#7-SpringBoot自动装配原理" class="headerlink" title="7. SpringBoot自动装配原理"></a>7. SpringBoot自动装配原理</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152852.png" style="zoom:67%;">

<ul>
<li>@SpringBootConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。</li>
<li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包。</li>
<li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解。</li>
</ul>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155116.png" style="zoom: 67%;">



<p><strong>SpringBoot自动配置原理</strong></p>
<ol>
<li>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
</li>
<li>其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。<br>内部就是读取了该项目和该项目引用的Jar包的的classpath路径下META-INF&#x2F;spring.factories文件中的所配置的类的全类名。 在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。</li>
<li>条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155653.png" style="zoom:67%;">



<br>



<hr>
<h3 id="8-Spring框架常见注解"><a href="#8-Spring框架常见注解" class="headerlink" title="8. Spring框架常见注解"></a>8. Spring框架常见注解</h3><p><strong><font color="red">Spring 的常见注解</font></strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring  在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程（AOP）</td>
</tr>
</tbody></table>
<br>



<p><strong><font color="red">SpringMVC 的常见注解</font></strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将controller方法返回对象转化为json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<br>



<p><strong><font color="red">SpringBoot的常见注解</font></strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootConfiguration</td>
<td>组合了- @Configuration注解，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>打开自动配置的功能，也可以关闭某个自动配置的选</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring  在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程（AOP）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将controller方法返回对象转化为json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<br>



<hr>
<h3 id="9-MyBatis的执行流程"><a href="#9-MyBatis的执行流程" class="headerlink" title="9. MyBatis的执行流程"></a>9. MyBatis的执行流程</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161252.png" style="zoom:67%;">

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161332.png" style="zoom:67%;">



<p><strong>Mybatis执行流程：</strong></p>
<ol>
<li>读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161555.png" style="zoom:67%;">

<br>



<hr>
<h3 id="10-Mybatis是否支持延迟加载"><a href="#10-Mybatis是否支持延迟加载" class="headerlink" title="10. Mybatis是否支持延迟加载"></a>10. Mybatis是否支持延迟加载</h3><p>Mybatis支持延迟记载，但默认没有开启</p>
<p><strong>什么叫做延迟加载？</strong></p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161751.png" style="zoom:67%;">

<p>查询用户的时候，把用户所属的订单数据也查询出来，这个是立即加载<br>查询用户的时候，暂时不查询订单数据，当需要订单的时候，再查询订单，这个就是延迟加载</p>
<br>



<p><strong>延迟加载原理</strong></p>
<ol>
<li>使用CGLIB创建目标对象的代理对象</li>
<li>当调用目标方法user.getOrderList()时，进入拦截器invoke方法，发现user.getOrderList()是null值，执行sql查询order列表</li>
<li>把order查询上来，然后调用user.setOrderList(List<Order> orderList) ，接着完成user.getOrderList()方法的调用</Order></li>
</ol>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161915.png" style="zoom:67%;">

<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162014.png" style="zoom:67%;">

<br>



<hr>
<h3 id="11-Mybatis的一级、二级缓存"><a href="#11-Mybatis的一级、二级缓存" class="headerlink" title="11. Mybatis的一级、二级缓存"></a>11. Mybatis的一级、二级缓存</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162117.png" style="zoom:67%;">

<ul>
<li>本地缓存，基于PerpetualCache，本质是一个HashMap</li>
<li>一级缓存：作用域是session级别</li>
<li>二级缓存：作用域是namespace和mapper的作用域，不依赖于session</li>
</ul>
<br>



<p><font color="red"><strong>一级缓存</strong></font>: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//3. 执行sql</span></span><br><span class="line"><span class="comment">//3.1 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper1</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper2</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper1.selectById(<span class="number">6</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper2.selectById(<span class="number">6</span>);</span><br><span class="line">System.out.println(user1);</span><br></pre></td></tr></table></figure>

<br>



<p><font color="red"><strong>二级缓存</strong></font>:是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//3. 执行sql</span></span><br><span class="line"><span class="comment">//3.1 获取UserMapper接口的代理对象UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper1.selectById(<span class="number">6</span>);</span><br><span class="line">System.out.println(user1);</span><br><span class="line">sqlSession1.close();</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper2.selectById(<span class="number">6</span>);</span><br><span class="line">System.out.println(user2);</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">sqlSession2.close();</span><br></pre></td></tr></table></figure>

<p>二级缓存默认是关闭的<br>开启方式，两步：</p>
<ol>
<li>全局配置文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=<span class="string">&quot;cacheEnabled&quot;</span> value=<span class="string">&quot;true</span></span><br><span class="line"><span class="string">&lt;/settings&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>映射文件<br>使用<cache>标签让当前mapper生效二级缓存</cache></li>
</ol>
<p><font color="red">注意事项：</font></p>
<ol>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li>
<li>二级缓存需要缓存的数据实现Serializable接口</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162915.png" style="zoom:67%;">

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lzhengjy.github.io/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clywa1f51003xecvegqk38p96" data-title="框架" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          集合
        
      </div>
    </a>
  
  
    <a href="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">MySQL</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM%E7%AF%87/">JVM篇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/">技术经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/">框架和中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MybatisPlus/" rel="tag">MybatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot3/" rel="tag">SpringBoot3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel/" rel="tag">excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" rel="tag">权限管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/MybatisPlus/" style="font-size: 10px;">MybatisPlus</a> <a href="/tags/RabbitMQ/" style="font-size: 13.33px;">RabbitMQ</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/SpringBoot3/" style="font-size: 10px;">SpringBoot3</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/redis/" style="font-size: 16.67px;">redis</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 13.33px;">前端</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" style="font-size: 10px;">权限管理</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/19/xxl-job/">xxl-job</a>
          </li>
        
          <li>
            <a href="/2024/07/01/ElasticSearch/">ElasticSearch</a>
          </li>
        
          <li>
            <a href="/2024/06/20/%E9%80%9A%E8%BF%87JWT%E5%AE%9E%E7%94%9F%E6%88%90Token/">通过JWT实生成Token</a>
          </li>
        
          <li>
            <a href="/2024/06/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">分布式事务的解决方案</a>
          </li>
        
          <li>
            <a href="/2024/06/10/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/">延时队列</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Zheng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>