

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zheng">
  <meta name="keywords" content="">
  
    <meta name="description" content="消息中间件面试题该笔记基于b站黑马程序员Java面试题视频制作      一. RabbitMQ1. RabbitMQ如何保证消息不丢失 异步发送（验证码、短信、邮件…） MYSQL和Redis , ES之间的数据同步 分布式事务 削峰填谷 …        生产者确认机制 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件">
<meta property="og:url" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="消息中间件面试题该笔记基于b站黑马程序员Java面试题视频制作      一. RabbitMQ1. RabbitMQ如何保证消息不丢失 异步发送（验证码、短信、邮件…） MYSQL和Redis , ES之间的数据同步 分布式事务 削峰填谷 …        生产者确认机制 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png">
<meta property="article:published_time" content="2023-10-08T06:16:59.000Z">
<meta property="article:modified_time" content="2024-06-06T08:36:46.820Z">
<meta property="article:author" content="Zheng">
<meta property="article:tag" content="RabbitMQ">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png">
  
  
  
  <title>消息中间件 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lzhengjy.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zheng</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="消息中间件"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-08 14:16" pubdate>
          2023年10月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          71 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">消息中间件</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="消息中间件面试题"><a href="#消息中间件面试题" class="headerlink" title="消息中间件面试题"></a>消息中间件面试题</h2><p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">

<br>

<hr>
<h2 id="一-RabbitMQ"><a href="#一-RabbitMQ" class="headerlink" title="一. RabbitMQ"></a>一. RabbitMQ</h2><h3 id="1-RabbitMQ如何保证消息不丢失"><a href="#1-RabbitMQ如何保证消息不丢失" class="headerlink" title="1. RabbitMQ如何保证消息不丢失"></a>1. RabbitMQ如何保证消息不丢失</h3><ul>
<li>异步发送（验证码、短信、邮件…）</li>
<li>MYSQL和Redis , ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
<li>…</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">

<br>



<p><strong>生产者确认机制</strong></p>
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">

<p>消息失败之后的处理方法</p>
<ul>
<li>回调日志及时重新发送</li>
<li>记录日志</li>
<li>保存到数据库然后定时重新发送，成功发送后即刻删除表中的数据</li>
</ul>
<br>



<p><strong>消息持久化</strong></p>
<p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p>
<ol>
<li><p>交换机持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>队列持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 使用QueueBuilder构建队列，durable就是持久化的</span><br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>).build();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>消息持久化，SpringAMQP中的消息默认是成就的，可以通过MessageProperties中的DeliveryMode来指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化 </span><br>    .build();<br></code></pre></td></tr></table></figure></li>
</ol>
<br>



<p><strong>消费者确认</strong></p>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;">

<br>



<p><strong>RabbitMQ如何保证消息不丢失？</strong></p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png" srcset="/img/loading.gif" lazyload>

<br>



<hr>
<h3 id="2-RabbitMQ消息的重复消费问题"><a href="#2-RabbitMQ消息的重复消费问题" class="headerlink" title="2. RabbitMQ消息的重复消费问题"></a>2. RabbitMQ消息的重复消费问题</h3><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>都可能出现出现消费问题</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>解决方案：</p>
<ul>
<li>每条消息设置一个唯一的标识id</li>
<li>幂等方案：分布式锁、数据库锁（乐观锁、悲观锁）</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png" srcset="/img/loading.gif" lazyload>



<br>



<hr>
<h3 id="3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列"><a href="#3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列" class="headerlink" title="3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)"></a>3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)</h3><ul>
<li>延迟队列：进入队列的消息会被延迟消费的队列</li>
<li>场景：超时订单、限时优惠、定时发布</li>
</ul>
<p><font color="red">延迟队列 &#x3D; 死信交换机 + TTL</font></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">



<br>



<p><strong>死信交换机</strong></p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">ttlQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>) <span class="hljs-comment">// 指定队列名称，并持久化</span><br>        .ttl(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置队列的超时时间，10秒</span><br>        .deadLetterExchange(<span class="hljs-string">&quot;dl.direct&quot;</span>) <span class="hljs-comment">// 指定死信交换机</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">



<br>



<p><strong>TTL</strong></p>
<p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况:</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello, ttl message&quot;</span>).getBytes(StandardCharsets.UTF_8)<br>    .setExpiration(<span class="hljs-string">&quot;500&quot;</span>)<br>    .build();<br><span class="hljs-comment">// 消息Id，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">



<br>



<p><strong>延迟队列插件</strong></p>
<p>DelayExchange插件，需要安装在RabbitMQ中</p>
<p>RabbitMQ有一个官方的插件社区，地址为：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> </p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindinds = @QueueBinding(</span><br><span class="hljs-meta">	value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">    key = &quot;delay&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayedQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>	log.info(<span class="hljs-string">&quot;接收到 delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello,delayed message&quot;</span>.getBytes(StandardCharsets.UTF_8))<br>    .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">10000</span>)<br>    .build();<br><span class="hljs-comment">// 消息ID，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure>



<br>



<p><strong>RabbitMQ中死信交换机？（RabbitMQ延迟队列有了解过吗？）</strong></p>
<ul>
<li><p>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布…）</p>
</li>
<li><p>其中延迟队列就用到了死信交换机和TTL（消息存活时间）实现的</p>
</li>
<li><p>消息超时未消费就会变成死信（死信的其他情况：拒绝被消费，队列满了）</p>
<p> 延迟队列插件实现延迟队列DelayExchange</p>
</li>
<li><p>声明一个交换机，添加delayed属性为true</p>
</li>
<li><p>发送消息时，添加x-delay头，值为超时时间</p>
</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">



<br>



<hr>
<h3 id="4-消息堆积怎么解决"><a href="#4-消息堆积怎么解决" class="headerlink" title="4. 消息堆积怎么解决"></a>4. 消息堆积怎么解决</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png" srcset="/img/loading.gif" lazyload></p>
<p>解决消费堆积问题有三种思路：</p>
<ul>
<li>增加更多的消费者，提高消费速度</li>
<li>在消费者内开启线程，也加快消费者的处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<br>

<p><strong>惰性队列</strong></p>
<p>惰性队列的特征：</p>
<ul>
<li>接收到消息之后直接存入磁盘而非内存中</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">lazyQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(lazy.queue)<br>        .lazy()<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(</span><br><span class="hljs-meta">    name = &quot;lzay.queue&quot;,</span><br><span class="hljs-meta">    durable = &quot;true&quot;,</span><br><span class="hljs-meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenLazyQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>	log.info(<span class="hljs-string">&quot;接收到 lazy.queue的消息:&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决）</strong></p>
<p>解决消息堆积有三种种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限，采用惰性队列<ul>
<li>在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">



<br>



<hr>
<h3 id="5-RabbitMQ的高可用机制"><a href="#5-RabbitMQ的高可用机制" class="headerlink" title="5. RabbitMQ的高可用机制"></a>5. RabbitMQ的高可用机制</h3><ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、镜像集群、仲裁集群</li>
</ul>
<br>

<p><strong>普通集群</strong></p>
<p>普通集群，或者叫标准集群，具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;">



<br>



<p><strong>镜像集群</strong></p>
<p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png" srcset="/img/loading.gif" lazyload></p>
<br>



<p><strong>仲裁集群</strong></p>
<p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">quorumQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(<span class="hljs-string">&quot;quorumqueue&quot;</span>) <span class="hljs-comment">// 持久化</span><br>        .quorum() <span class="hljs-comment">// 仲裁队列</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<br>



<p><strong>RabbitMQ的高可用机制有了解过吗？</strong></p>
<ul>
<li>在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点</li>
<li>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li>
</ul>
<br>

<p><strong>那么出现丢数据怎么解决？</strong></p>
<p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。<br>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">



<br>



<hr>
<h2 id="二-Kafka"><a href="#二-Kafka" class="headerlink" title="二. Kafka"></a>二. Kafka</h2><h3 id="1-Kafka是如何保证消息不丢失"><a href="#1-Kafka是如何保证消息不丢失" class="headerlink" title="1. Kafka是如何保证消息不丢失"></a>1. Kafka是如何保证消息不丢失</h3><p>使用Kafka在消息的收发过程都会出现消息丢失 , Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步发送</span><br><span class="hljs-type">RecordMetadata</span> <span class="hljs-variable">recordMetadata</span> <span class="hljs-operator">=</span> kafkaProducer.send(record).get();<br><span class="hljs-comment">//异步发送</span><br>kafkaProducer.send(record, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息发送失败 | 记录日志&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> recordMetadata.offset();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> recordMetadata.partition();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> recordMetadata.topic();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置重试次数</span><br>prop.put(ProducerConfig.RETRIES_CONFIG,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;">

<br>

<table>
<thead>
<tr>
<th><strong>确认机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>acks&#x3D;0</td>
<td>生产者在成功写入消息之前不会等待任何来自服务器的响应,消息有丢失的风险，但是速度最快</td>
</tr>
<tr>
<td>acks&#x3D;1（默认值）</td>
<td>只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应</td>
</tr>
<tr>
<td>acks&#x3D;all</td>
<td>只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应</td>
</tr>
</tbody></table>
<br>

<p><strong>消费者从Brocker接受消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>禁用自动提交偏移量，改为手动</p>
<ul>
<li>同步提交</li>
<li>异步提交</li>
<li>同步+异步组合提交</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>        <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>            System.outprintln(record.value());<br>            System.outprintln(record.key());<br>        &#125;<br>        consumer.commitAsync();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;记录错误消息: &quot;</span> + e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        consumer.commitSync();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        consumer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>Kafka是如何保证消息不丢失?</strong></p>
<p>需要从三个层面去解决这个问题：</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数</li>
</ul>
</li>
<li><p>消息在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
</ul>
</li>
</ul>
<br>

<p><strong>Kafka中消息的重复消费问题如何解决的</strong></p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
<li>幂等方案</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">



<br>



<hr>
<h3 id="2-Kafka是如何保证消费的顺序性"><a href="#2-Kafka是如何保证消费的顺序性" class="headerlink" title="2. Kafka是如何保证消费的顺序性"></a>2. Kafka是如何保证消费的顺序性</h3><p>应用场景</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序</li>
</ul>
<br>

<p><strong>消费者从Brocker接收消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定分区</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br><span class="hljs-comment">// 相同的业务key</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<br>

<p><strong>Kafka是如何保证消费的顺序性？</strong></p>
<p>问题原因：<br>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>解决方案：</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
<br>



<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png" srcset="/img/loading.gif" lazyload></p>
<br>



<hr>
<h3 id="3-Kafka的高可用机制"><a href="#3-Kafka的高可用机制" class="headerlink" title="3. Kafka的高可用机制"></a>3. Kafka的高可用机制</h3><ul>
<li>集群模式</li>
<li>分区备份机制</li>
</ul>
<br>



<p><strong>集群模式</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<ul>
<li>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成</li>
<li>这样如果集群中某一台机器宕机，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一</li>
</ul>
<br>

<p><strong>分区备份机制</strong></p>
<p>某个topic中有三个分区P0、P1、P2</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<ul>
<li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>ISR（in-sync replica）需要同步复制保存的follower</p>
<p>如果leader失效后，需要选出新的leader，选举的原则如下：</p>
<ol>
<li>选举时优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</li>
<li>如果ISR列表中的follower都不行了，就只能从其他follower中选取</li>
</ol>
<br>

<p><strong>Kafka的高可用机制有了解过吗？</strong></p>
<p>可以从两个层面回答，第一个是集群，第二个是复制机制<br><strong>集群：</strong><br>一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务<br><strong>复制机制：</strong></p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
<br>

<p><strong>解释一下复制机制中的ISR</strong></p>
<p>ISR（in-sync replica）需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">



<br>



<hr>
<h3 id="4-Kafka数据清理机制"><a href="#4-Kafka数据清理机制" class="headerlink" title="4. Kafka数据清理机制"></a>4. Kafka数据清理机制</h3><ul>
<li>Kafka文件存储机制</li>
<li>数据清理机制</li>
</ul>
<br>

<p><strong>Kafka文件存储机制</strong></p>
<p>存储结构</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>为什么要分段？</p>
<ul>
<li>删除无用文件方便，提高磁盘利用率</li>
<li>查找数据便捷</li>
</ul>
<br>

<p><strong>数据清理机制</strong></p>
<p>日志的清理策略有两</p>
<ol>
<li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。需手动开启</li>
</ol>
<br>

<p><strong>Kafka存储结构</strong></p>
<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li>
</ul>
<p><strong>日志的清理策略有两个</strong>：</p>
<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;">

<br>



<hr>
<h3 id="5-Kafka中实现高性能的设计"><a href="#5-Kafka中实现高性能的设计" class="headerlink" title="5. Kafka中实现高性能的设计"></a>5. Kafka中实现高性能的设计</h3><ul>
<li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li>
<li>顺序读写：磁盘顺序读写，提升读写效率</li>
<li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访</li>
<li>l零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/" class="category-chain-item">面试篇</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/RabbitMQ/" class="print-no-link">#RabbitMQ</a>
      
        <a href="/tags/Kafka/" class="print-no-link">#Kafka</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>消息中间件</div>
      <div>https://lzhengjy.github.io/2023/10/08/消息中间件面试题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zheng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">多线程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" title="集合">
                        <span class="hidden-mobile">集合</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
