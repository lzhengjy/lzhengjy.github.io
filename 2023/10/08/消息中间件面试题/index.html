<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>消息中间件 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="消息中间件面试题该笔记基于b站黑马程序员Java面试题视频制作      一. RabbitMQ1. RabbitMQ如何保证消息不丢失 异步发送（验证码、短信、邮件…） MYSQL和Redis , ES之间的数据同步 分布式事务 削峰填谷 …        生产者确认机制 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件">
<meta property="og:url" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="消息中间件面试题该笔记基于b站黑马程序员Java面试题视频制作      一. RabbitMQ1. RabbitMQ如何保证消息不丢失 异步发送（验证码、短信、邮件…） MYSQL和Redis , ES之间的数据同步 分布式事务 削峰填谷 …        生产者确认机制 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png">
<meta property="article:published_time" content="2023-10-08T06:16:59.000Z">
<meta property="article:modified_time" content="2024-06-06T08:36:46.820Z">
<meta property="article:author" content="Zheng">
<meta property="article:tag" content="RabbitMQ">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lzhengjy.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-消息中间件面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-10-08T06:16:59.000Z" itemprop="datePublished">2023-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      消息中间件
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="消息中间件面试题"><a href="#消息中间件面试题" class="headerlink" title="消息中间件面试题"></a>消息中间件面试题</h2><p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png" style="zoom:80%;">

<br>

<hr>
<h2 id="一-RabbitMQ"><a href="#一-RabbitMQ" class="headerlink" title="一. RabbitMQ"></a>一. RabbitMQ</h2><h3 id="1-RabbitMQ如何保证消息不丢失"><a href="#1-RabbitMQ如何保证消息不丢失" class="headerlink" title="1. RabbitMQ如何保证消息不丢失"></a>1. RabbitMQ如何保证消息不丢失</h3><ul>
<li>异步发送（验证码、短信、邮件…）</li>
<li>MYSQL和Redis , ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
<li>…</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png" style="zoom:80%;">

<br>



<p><strong>生产者确认机制</strong></p>
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png" style="zoom:80%;">

<p>消息失败之后的处理方法</p>
<ul>
<li>回调日志及时重新发送</li>
<li>记录日志</li>
<li>保存到数据库然后定时重新发送，成功发送后即刻删除表中的数据</li>
</ul>
<br>



<p><strong>消息持久化</strong></p>
<p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p>
<ol>
<li><p>交换机持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息持久化，SpringAMQP中的消息默认是成就的，可以通过MessageProperties中的DeliveryMode来指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="comment">// 消息体</span></span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="comment">// 持久化 </span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ol>
<br>



<p><strong>消费者确认</strong></p>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png" style="zoom: 67%;">

<br>



<p><strong>RabbitMQ如何保证消息不丢失？</strong></p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png">

<br>



<hr>
<h3 id="2-RabbitMQ消息的重复消费问题"><a href="#2-RabbitMQ消息的重复消费问题" class="headerlink" title="2. RabbitMQ消息的重复消费问题"></a>2. RabbitMQ消息的重复消费问题</h3><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>都可能出现出现消费问题</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png" style="zoom:67%;">

<p>解决方案：</p>
<ul>
<li>每条消息设置一个唯一的标识id</li>
<li>幂等方案：分布式锁、数据库锁（乐观锁、悲观锁）</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png">



<br>



<hr>
<h3 id="3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列"><a href="#3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列" class="headerlink" title="3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)"></a>3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)</h3><ul>
<li>延迟队列：进入队列的消息会被延迟消费的队列</li>
<li>场景：超时订单、限时优惠、定时发布</li>
</ul>
<p><font color="red">延迟队列 &#x3D; 死信交换机 + TTL</font></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png" style="zoom:67%;">



<br>



<p><strong>死信交换机</strong></p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>) <span class="comment">// 设置队列的超时时间，10秒</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png" style="zoom:67%;">



<br>



<p><strong>TTL</strong></p>
<p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况:</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;hello, ttl message&quot;</span>).getBytes(StandardCharsets.UTF_8)</span><br><span class="line">    .setExpiration(<span class="string">&quot;500&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 消息Id，需要封装到CorrelationData中</span></span><br><span class="line"><span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png" style="zoom:67%;">



<br>



<p><strong>延迟队列插件</strong></p>
<p>DelayExchange插件，需要安装在RabbitMQ中</p>
<p>RabbitMQ有一个官方的插件社区，地址为：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> </p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png" style="zoom:50%;">

<p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindinds = @QueueBinding(</span></span><br><span class="line"><span class="meta">	value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayedQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">	log.info(<span class="string">&quot;接收到 delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;hello,delayed message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">    .setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line"><span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, correlationData);</span><br></pre></td></tr></table></figure>



<br>



<p><strong>RabbitMQ中死信交换机？（RabbitMQ延迟队列有了解过吗？）</strong></p>
<ul>
<li><p>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布…）</p>
</li>
<li><p>其中延迟队列就用到了死信交换机和TTL（消息存活时间）实现的</p>
</li>
<li><p>消息超时未消费就会变成死信（死信的其他情况：拒绝被消费，队列满了）</p>
<p> 延迟队列插件实现延迟队列DelayExchange</p>
</li>
<li><p>声明一个交换机，添加delayed属性为true</p>
</li>
<li><p>发送消息时，添加x-delay头，值为超时时间</p>
</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png" style="zoom:80%;">



<br>



<hr>
<h3 id="4-消息堆积怎么解决"><a href="#4-消息堆积怎么解决" class="headerlink" title="4. 消息堆积怎么解决"></a>4. 消息堆积怎么解决</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png"></p>
<p>解决消费堆积问题有三种思路：</p>
<ul>
<li>增加更多的消费者，提高消费速度</li>
<li>在消费者内开启线程，也加快消费者的处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<br>

<p><strong>惰性队列</strong></p>
<p>惰性队列的特征：</p>
<ul>
<li>接收到消息之后直接存入磁盘而非内存中</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(lazy.queue)</span><br><span class="line">        .lazy()</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">    name = &quot;lzay.queue&quot;,</span></span><br><span class="line"><span class="meta">    durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">	log.info(<span class="string">&quot;接收到 lazy.queue的消息:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决）</strong></p>
<p>解决消息堆积有三种种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限，采用惰性队列<ul>
<li>在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png" style="zoom:80%;">



<br>



<hr>
<h3 id="5-RabbitMQ的高可用机制"><a href="#5-RabbitMQ的高可用机制" class="headerlink" title="5. RabbitMQ的高可用机制"></a>5. RabbitMQ的高可用机制</h3><ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、镜像集群、仲裁集群</li>
</ul>
<br>

<p><strong>普通集群</strong></p>
<p>普通集群，或者叫标准集群，具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png" style="zoom: 67%;">



<br>



<p><strong>镜像集群</strong></p>
<p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png"></p>
<br>



<p><strong>仲裁集群</strong></p>
<p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;quorumqueue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">        .quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>



<p><strong>RabbitMQ的高可用机制有了解过吗？</strong></p>
<ul>
<li>在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点</li>
<li>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li>
</ul>
<br>

<p><strong>那么出现丢数据怎么解决？</strong></p>
<p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。<br>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png" style="zoom:80%;">



<br>



<hr>
<h2 id="二-Kafka"><a href="#二-Kafka" class="headerlink" title="二. Kafka"></a>二. Kafka</h2><h3 id="1-Kafka是如何保证消息不丢失"><a href="#1-Kafka是如何保证消息不丢失" class="headerlink" title="1. Kafka是如何保证消息不丢失"></a>1. Kafka是如何保证消息不丢失</h3><p>使用Kafka在消息的收发过程都会出现消息丢失 , Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png" style="zoom:67%;">



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步发送</span></span><br><span class="line"><span class="type">RecordMetadata</span> <span class="variable">recordMetadata</span> <span class="operator">=</span> kafkaProducer.send(record).get();</span><br><span class="line"><span class="comment">//异步发送</span></span><br><span class="line">kafkaProducer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败 | 记录日志&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> recordMetadata.offset();</span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> recordMetadata.partition();</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> recordMetadata.topic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置重试次数</span></span><br><span class="line">prop.put(ProducerConfig.RETRIES_CONFIG,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png" style="zoom: 80%;">

<br>

<table>
<thead>
<tr>
<th><strong>确认机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>acks&#x3D;0</td>
<td>生产者在成功写入消息之前不会等待任何来自服务器的响应,消息有丢失的风险，但是速度最快</td>
</tr>
<tr>
<td>acks&#x3D;1（默认值）</td>
<td>只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应</td>
</tr>
<tr>
<td>acks&#x3D;all</td>
<td>只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应</td>
</tr>
</tbody></table>
<br>

<p><strong>消费者从Brocker接受消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png" style="zoom:67%;">

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png" style="zoom:67%;">

<p>禁用自动提交偏移量，改为手动</p>
<ul>
<li>同步提交</li>
<li>异步提交</li>
<li>同步+异步组合提交</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.outprintln(record.value());</span><br><span class="line">            System.outprintln(record.key());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">&quot;记录错误消息: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>Kafka是如何保证消息不丢失?</strong></p>
<p>需要从三个层面去解决这个问题：</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数</li>
</ul>
</li>
<li><p>消息在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
</ul>
</li>
</ul>
<br>

<p><strong>Kafka中消息的重复消费问题如何解决的</strong></p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
<li>幂等方案</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png" style="zoom:80%;">



<br>



<hr>
<h3 id="2-Kafka是如何保证消费的顺序性"><a href="#2-Kafka是如何保证消费的顺序性" class="headerlink" title="2. Kafka是如何保证消费的顺序性"></a>2. Kafka是如何保证消费的顺序性</h3><p>应用场景</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序</li>
</ul>
<br>

<p><strong>消费者从Brocker接收消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png" style="zoom: 80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定分区</span></span><br><span class="line">kafkaTemplate.send(<span class="string">&quot;springboot-kafka-topic&quot;</span>, <span class="number">0</span>, <span class="string">&quot;key-001&quot;</span>, <span class="string">&quot;value-0001&quot;</span>);</span><br><span class="line"><span class="comment">// 相同的业务key</span></span><br><span class="line">kafkaTemplate.send(<span class="string">&quot;springboot-kafka-topic&quot;</span>, <span class="string">&quot;key-001&quot;</span>, <span class="string">&quot;value-0001&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<br>

<p><strong>Kafka是如何保证消费的顺序性？</strong></p>
<p>问题原因：<br>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>解决方案：</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
<br>



<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png"></p>
<br>



<hr>
<h3 id="3-Kafka的高可用机制"><a href="#3-Kafka的高可用机制" class="headerlink" title="3. Kafka的高可用机制"></a>3. Kafka的高可用机制</h3><ul>
<li>集群模式</li>
<li>分区备份机制</li>
</ul>
<br>



<p><strong>集群模式</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png" style="zoom:67%;">

<ul>
<li>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成</li>
<li>这样如果集群中某一台机器宕机，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一</li>
</ul>
<br>

<p><strong>分区备份机制</strong></p>
<p>某个topic中有三个分区P0、P1、P2</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png" style="zoom:67%;">

<ul>
<li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png" style="zoom:67%;">

<p>ISR（in-sync replica）需要同步复制保存的follower</p>
<p>如果leader失效后，需要选出新的leader，选举的原则如下：</p>
<ol>
<li>选举时优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</li>
<li>如果ISR列表中的follower都不行了，就只能从其他follower中选取</li>
</ol>
<br>

<p><strong>Kafka的高可用机制有了解过吗？</strong></p>
<p>可以从两个层面回答，第一个是集群，第二个是复制机制<br><strong>集群：</strong><br>一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务<br><strong>复制机制：</strong></p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
<br>

<p><strong>解释一下复制机制中的ISR</strong></p>
<p>ISR（in-sync replica）需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png" style="zoom:80%;">



<br>



<hr>
<h3 id="4-Kafka数据清理机制"><a href="#4-Kafka数据清理机制" class="headerlink" title="4. Kafka数据清理机制"></a>4. Kafka数据清理机制</h3><ul>
<li>Kafka文件存储机制</li>
<li>数据清理机制</li>
</ul>
<br>

<p><strong>Kafka文件存储机制</strong></p>
<p>存储结构</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png" style="zoom:67%;">

<p>为什么要分段？</p>
<ul>
<li>删除无用文件方便，提高磁盘利用率</li>
<li>查找数据便捷</li>
</ul>
<br>

<p><strong>数据清理机制</strong></p>
<p>日志的清理策略有两</p>
<ol>
<li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。需手动开启</li>
</ol>
<br>

<p><strong>Kafka存储结构</strong></p>
<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li>
</ul>
<p><strong>日志的清理策略有两个</strong>：</p>
<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png" style="zoom: 80%;">

<br>



<hr>
<h3 id="5-Kafka中实现高性能的设计"><a href="#5-Kafka中实现高性能的设计" class="headerlink" title="5. Kafka中实现高性能的设计"></a>5. Kafka中实现高性能的设计</h3><ul>
<li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li>
<li>顺序读写：磁盘顺序读写，提升读写效率</li>
<li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访</li>
<li>l零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png" style="zoom:80%;">

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clywa1f4u0031ecveglrth5lv" data-title="消息中间件" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          多线程
        
      </div>
    </a>
  
  
    <a href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">集合</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM%E7%AF%87/">JVM篇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/">技术经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/">框架和中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MybatisPlus/" rel="tag">MybatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot3/" rel="tag">SpringBoot3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel/" rel="tag">excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" rel="tag">权限管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/MybatisPlus/" style="font-size: 10px;">MybatisPlus</a> <a href="/tags/RabbitMQ/" style="font-size: 13.33px;">RabbitMQ</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/SpringBoot3/" style="font-size: 10px;">SpringBoot3</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/redis/" style="font-size: 16.67px;">redis</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 13.33px;">前端</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" style="font-size: 10px;">权限管理</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/19/xxl-job/">xxl-job</a>
          </li>
        
          <li>
            <a href="/2024/07/01/ElasticSearch/">ElasticSearch</a>
          </li>
        
          <li>
            <a href="/2024/06/20/%E9%80%9A%E8%BF%87JWT%E5%AE%9E%E7%94%9F%E6%88%90Token/">通过JWT实生成Token</a>
          </li>
        
          <li>
            <a href="/2024/06/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">分布式事务的解决方案</a>
          </li>
        
          <li>
            <a href="/2024/06/10/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/">延时队列</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Zheng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>