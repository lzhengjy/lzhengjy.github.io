<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lzhengjy.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="消息中间件面试题该笔记基于b站黑马程序员Java面试题视频制作      一. RabbitMQ1. RabbitMQ如何保证消息不丢失 异步发送（验证码、短信、邮件…） MYSQL和Redis , ES之间的数据同步 分布式事务 削峰填谷 …        生产者确认机制 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件">
<meta property="og:url" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="消息中间件面试题该笔记基于b站黑马程序员Java面试题视频制作      一. RabbitMQ1. RabbitMQ如何保证消息不丢失 异步发送（验证码、短信、邮件…） MYSQL和Redis , ES之间的数据同步 分布式事务 削峰填谷 …        生产者确认机制 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png">
<meta property="og:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png">
<meta property="article:published_time" content="2023-10-08T06:16:59.000Z">
<meta property="article:modified_time" content="2024-06-06T08:36:46.820Z">
<meta property="article:author" content="Zheng">
<meta property="article:tag" content="RabbitMQ">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png">


<link rel="canonical" href="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/","path":"2023/10/08/消息中间件面试题/","title":"消息中间件"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>消息中间件 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">消息中间件面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-RabbitMQ"><span class="nav-number">2.</span> <span class="nav-text">一. RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">2.1.</span> <span class="nav-text">1. RabbitMQ如何保证消息不丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">2. RabbitMQ消息的重复消费问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-RabbitMQ%E4%B8%AD%E7%9A%84%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA-RabbitMQ-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">2.4.</span> <span class="nav-text">4. 消息堆积怎么解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-RabbitMQ%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">2.5.</span> <span class="nav-text">5. RabbitMQ的高可用机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-Kafka"><span class="nav-number">3.</span> <span class="nav-text">二. Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">3.1.</span> <span class="nav-text">1. Kafka是如何保证消息不丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">2. Kafka是如何保证消费的顺序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Kafka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">3. Kafka的高可用机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">4. Kafka数据清理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Kafka%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.5.</span> <span class="nav-text">5. Kafka中实现高性能的设计</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lzhengjy.github.io/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="消息中间件 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          消息中间件
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-08 14:16:59" itemprop="dateCreated datePublished" datetime="2023-10-08T14:16:59+08:00">2023-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-06 16:36:46" itemprop="dateModified" datetime="2024-06-06T16:36:46+08:00">2024-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">面试篇</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="消息中间件面试题"><a href="#消息中间件面试题" class="headerlink" title="消息中间件面试题"></a>消息中间件面试题</h2><p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png" style="zoom:80%;">

<br>

<hr>
<h2 id="一-RabbitMQ"><a href="#一-RabbitMQ" class="headerlink" title="一. RabbitMQ"></a>一. RabbitMQ</h2><h3 id="1-RabbitMQ如何保证消息不丢失"><a href="#1-RabbitMQ如何保证消息不丢失" class="headerlink" title="1. RabbitMQ如何保证消息不丢失"></a>1. RabbitMQ如何保证消息不丢失</h3><ul>
<li>异步发送（验证码、短信、邮件…）</li>
<li>MYSQL和Redis , ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
<li>…</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png" style="zoom:80%;">

<br>



<p><strong>生产者确认机制</strong></p>
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png" style="zoom:80%;">

<p>消息失败之后的处理方法</p>
<ul>
<li>回调日志及时重新发送</li>
<li>记录日志</li>
<li>保存到数据库然后定时重新发送，成功发送后即刻删除表中的数据</li>
</ul>
<br>



<p><strong>消息持久化</strong></p>
<p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p>
<ol>
<li><p>交换机持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>队列持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 使用QueueBuilder构建队列，durable就是持久化的</span><br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>).build();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>消息持久化，SpringAMQP中的消息默认是成就的，可以通过MessageProperties中的DeliveryMode来指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化 </span><br>    .build();<br></code></pre></td></tr></table></figure></li>
</ol>
<br>



<p><strong>消费者确认</strong></p>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png" style="zoom: 67%;">

<br>



<p><strong>RabbitMQ如何保证消息不丢失？</strong></p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png">

<br>



<hr>
<h3 id="2-RabbitMQ消息的重复消费问题"><a href="#2-RabbitMQ消息的重复消费问题" class="headerlink" title="2. RabbitMQ消息的重复消费问题"></a>2. RabbitMQ消息的重复消费问题</h3><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>都可能出现出现消费问题</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png" style="zoom:67%;">

<p>解决方案：</p>
<ul>
<li>每条消息设置一个唯一的标识id</li>
<li>幂等方案：分布式锁、数据库锁（乐观锁、悲观锁）</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png">



<br>



<hr>
<h3 id="3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列"><a href="#3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列" class="headerlink" title="3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)"></a>3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)</h3><ul>
<li>延迟队列：进入队列的消息会被延迟消费的队列</li>
<li>场景：超时订单、限时优惠、定时发布</li>
</ul>
<p><font color="red">延迟队列 &#x3D; 死信交换机 + TTL</font></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png" style="zoom:67%;">



<br>



<p><strong>死信交换机</strong></p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">ttlQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>) <span class="hljs-comment">// 指定队列名称，并持久化</span><br>        .ttl(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置队列的超时时间，10秒</span><br>        .deadLetterExchange(<span class="hljs-string">&quot;dl.direct&quot;</span>) <span class="hljs-comment">// 指定死信交换机</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png" style="zoom:67%;">



<br>



<p><strong>TTL</strong></p>
<p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况:</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello, ttl message&quot;</span>).getBytes(StandardCharsets.UTF_8)<br>    .setExpiration(<span class="hljs-string">&quot;500&quot;</span>)<br>    .build();<br><span class="hljs-comment">// 消息Id，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png" style="zoom:67%;">



<br>



<p><strong>延迟队列插件</strong></p>
<p>DelayExchange插件，需要安装在RabbitMQ中</p>
<p>RabbitMQ有一个官方的插件社区，地址为：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> </p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png" style="zoom:50%;">

<p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindinds = @QueueBinding(</span><br><span class="hljs-meta">	value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">    key = &quot;delay&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayedQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>	log.info(<span class="hljs-string">&quot;接收到 delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello,delayed message&quot;</span>.getBytes(StandardCharsets.UTF_8))<br>    .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">10000</span>)<br>    .build();<br><span class="hljs-comment">// 消息ID，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure>



<br>



<p><strong>RabbitMQ中死信交换机？（RabbitMQ延迟队列有了解过吗？）</strong></p>
<ul>
<li><p>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布…）</p>
</li>
<li><p>其中延迟队列就用到了死信交换机和TTL（消息存活时间）实现的</p>
</li>
<li><p>消息超时未消费就会变成死信（死信的其他情况：拒绝被消费，队列满了）</p>
<p> 延迟队列插件实现延迟队列DelayExchange</p>
</li>
<li><p>声明一个交换机，添加delayed属性为true</p>
</li>
<li><p>发送消息时，添加x-delay头，值为超时时间</p>
</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png" style="zoom:80%;">



<br>



<hr>
<h3 id="4-消息堆积怎么解决"><a href="#4-消息堆积怎么解决" class="headerlink" title="4. 消息堆积怎么解决"></a>4. 消息堆积怎么解决</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png"></p>
<p>解决消费堆积问题有三种思路：</p>
<ul>
<li>增加更多的消费者，提高消费速度</li>
<li>在消费者内开启线程，也加快消费者的处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<br>

<p><strong>惰性队列</strong></p>
<p>惰性队列的特征：</p>
<ul>
<li>接收到消息之后直接存入磁盘而非内存中</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">lazyQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(lazy.queue)<br>        .lazy()<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(</span><br><span class="hljs-meta">    name = &quot;lzay.queue&quot;,</span><br><span class="hljs-meta">    durable = &quot;true&quot;,</span><br><span class="hljs-meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenLazyQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>	log.info(<span class="hljs-string">&quot;接收到 lazy.queue的消息:&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决）</strong></p>
<p>解决消息堆积有三种种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限，采用惰性队列<ul>
<li>在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png" style="zoom:80%;">



<br>



<hr>
<h3 id="5-RabbitMQ的高可用机制"><a href="#5-RabbitMQ的高可用机制" class="headerlink" title="5. RabbitMQ的高可用机制"></a>5. RabbitMQ的高可用机制</h3><ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、镜像集群、仲裁集群</li>
</ul>
<br>

<p><strong>普通集群</strong></p>
<p>普通集群，或者叫标准集群，具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png" style="zoom: 67%;">



<br>



<p><strong>镜像集群</strong></p>
<p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png"></p>
<br>



<p><strong>仲裁集群</strong></p>
<p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">quorumQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(<span class="hljs-string">&quot;quorumqueue&quot;</span>) <span class="hljs-comment">// 持久化</span><br>        .quorum() <span class="hljs-comment">// 仲裁队列</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<br>



<p><strong>RabbitMQ的高可用机制有了解过吗？</strong></p>
<ul>
<li>在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点</li>
<li>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li>
</ul>
<br>

<p><strong>那么出现丢数据怎么解决？</strong></p>
<p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。<br>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png" style="zoom:80%;">



<br>



<hr>
<h2 id="二-Kafka"><a href="#二-Kafka" class="headerlink" title="二. Kafka"></a>二. Kafka</h2><h3 id="1-Kafka是如何保证消息不丢失"><a href="#1-Kafka是如何保证消息不丢失" class="headerlink" title="1. Kafka是如何保证消息不丢失"></a>1. Kafka是如何保证消息不丢失</h3><p>使用Kafka在消息的收发过程都会出现消息丢失 , Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png" style="zoom:67%;">



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步发送</span><br><span class="hljs-type">RecordMetadata</span> <span class="hljs-variable">recordMetadata</span> <span class="hljs-operator">=</span> kafkaProducer.send(record).get();<br><span class="hljs-comment">//异步发送</span><br>kafkaProducer.send(record, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息发送失败 | 记录日志&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> recordMetadata.offset();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> recordMetadata.partition();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> recordMetadata.topic();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置重试次数</span><br>prop.put(ProducerConfig.RETRIES_CONFIG,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png" style="zoom: 80%;">

<br>

<table>
<thead>
<tr>
<th><strong>确认机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>acks&#x3D;0</td>
<td>生产者在成功写入消息之前不会等待任何来自服务器的响应,消息有丢失的风险，但是速度最快</td>
</tr>
<tr>
<td>acks&#x3D;1（默认值）</td>
<td>只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应</td>
</tr>
<tr>
<td>acks&#x3D;all</td>
<td>只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应</td>
</tr>
</tbody></table>
<br>

<p><strong>消费者从Brocker接受消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png" style="zoom:67%;">

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png" style="zoom:67%;">

<p>禁用自动提交偏移量，改为手动</p>
<ul>
<li>同步提交</li>
<li>异步提交</li>
<li>同步+异步组合提交</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>        <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>            System.outprintln(record.value());<br>            System.outprintln(record.key());<br>        &#125;<br>        consumer.commitAsync();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;记录错误消息: &quot;</span> + e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        consumer.commitSync();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        consumer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>Kafka是如何保证消息不丢失?</strong></p>
<p>需要从三个层面去解决这个问题：</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数</li>
</ul>
</li>
<li><p>消息在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
</ul>
</li>
</ul>
<br>

<p><strong>Kafka中消息的重复消费问题如何解决的</strong></p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
<li>幂等方案</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png" style="zoom:80%;">



<br>



<hr>
<h3 id="2-Kafka是如何保证消费的顺序性"><a href="#2-Kafka是如何保证消费的顺序性" class="headerlink" title="2. Kafka是如何保证消费的顺序性"></a>2. Kafka是如何保证消费的顺序性</h3><p>应用场景</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序</li>
</ul>
<br>

<p><strong>消费者从Brocker接收消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png" style="zoom: 80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定分区</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br><span class="hljs-comment">// 相同的业务key</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<br>

<p><strong>Kafka是如何保证消费的顺序性？</strong></p>
<p>问题原因：<br>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>解决方案：</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
<br>



<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png"></p>
<br>



<hr>
<h3 id="3-Kafka的高可用机制"><a href="#3-Kafka的高可用机制" class="headerlink" title="3. Kafka的高可用机制"></a>3. Kafka的高可用机制</h3><ul>
<li>集群模式</li>
<li>分区备份机制</li>
</ul>
<br>



<p><strong>集群模式</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png" style="zoom:67%;">

<ul>
<li>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成</li>
<li>这样如果集群中某一台机器宕机，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一</li>
</ul>
<br>

<p><strong>分区备份机制</strong></p>
<p>某个topic中有三个分区P0、P1、P2</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png" style="zoom:67%;">

<ul>
<li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png" style="zoom:67%;">

<p>ISR（in-sync replica）需要同步复制保存的follower</p>
<p>如果leader失效后，需要选出新的leader，选举的原则如下：</p>
<ol>
<li>选举时优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</li>
<li>如果ISR列表中的follower都不行了，就只能从其他follower中选取</li>
</ol>
<br>

<p><strong>Kafka的高可用机制有了解过吗？</strong></p>
<p>可以从两个层面回答，第一个是集群，第二个是复制机制<br><strong>集群：</strong><br>一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务<br><strong>复制机制：</strong></p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
<br>

<p><strong>解释一下复制机制中的ISR</strong></p>
<p>ISR（in-sync replica）需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png" style="zoom:80%;">



<br>



<hr>
<h3 id="4-Kafka数据清理机制"><a href="#4-Kafka数据清理机制" class="headerlink" title="4. Kafka数据清理机制"></a>4. Kafka数据清理机制</h3><ul>
<li>Kafka文件存储机制</li>
<li>数据清理机制</li>
</ul>
<br>

<p><strong>Kafka文件存储机制</strong></p>
<p>存储结构</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png" style="zoom:67%;">

<p>为什么要分段？</p>
<ul>
<li>删除无用文件方便，提高磁盘利用率</li>
<li>查找数据便捷</li>
</ul>
<br>

<p><strong>数据清理机制</strong></p>
<p>日志的清理策略有两</p>
<ol>
<li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。需手动开启</li>
</ol>
<br>

<p><strong>Kafka存储结构</strong></p>
<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li>
</ul>
<p><strong>日志的清理策略有两个</strong>：</p>
<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png" style="zoom: 80%;">

<br>



<hr>
<h3 id="5-Kafka中实现高性能的设计"><a href="#5-Kafka中实现高性能的设计" class="headerlink" title="5. Kafka中实现高性能的设计"></a>5. Kafka中实现高性能的设计</h3><ul>
<li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li>
<li>顺序读写：磁盘顺序读写，提升读写效率</li>
<li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访</li>
<li>l零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png" style="zoom:80%;">

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RabbitMQ/" rel="tag"># RabbitMQ</a>
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="集合">
                  <i class="fa fa-angle-left"></i> 集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="多线程">
                  多线程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zheng</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
