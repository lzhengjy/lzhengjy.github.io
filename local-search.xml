<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java反射</title>
    <link href="/2023/12/23/Java%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/12/23/Java%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/12/13/Docker/"/>
    <url>/2023/12/13/Docker/</url>
    
    <content type="html"><![CDATA[<p>该笔记是根据<a href="https://www.bilibili.com/video/BV1HP4118797/?share_source=copy_web&vd_source=db8e7458ec195ac74979ce5478cbc624">B站视频</a>学习编写</p><h3 id="1-什么是Docker"><a href="#1-什么是Docker" class="headerlink" title="1. 什么是Docker"></a>1. 什么是Docker</h3><p>Docker 是一个用于构建、部署和管理容器化应用的开源平台。这些容器是标准化的可执行组件，结合了应用源代码以及在任何环境中运行该代码所需的操作系统 (OS) 库和依赖项。</p><p><strong>Docker的作用：</strong></p><ul><li>轻量级的虚拟化：Docker 容器提供了一种轻量级的虚拟化方式，相较于传统的虚拟机，Docker 容器启动速度更快，占用资源更少</li><li><strong>环境一致性</strong>：Docker 可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，这样就可以确保应用在不同环境中的一致性</li><li><strong>提高资源利用率</strong>：开发人员使用容器在硬件上运行的应用副本数量是使用虚拟机的数倍。这可以减少云支出</li><li><strong>提高开发效率</strong>：Docker 容器化应用可以“一次编写，随处运行”。与虚拟机相比，容器的部署、配置和重启过程更迅速且更简单</li><li><strong>快速交付软件</strong>：Docker 可以让你将应用程序与基础架构分开，从而可以快速交付软件。你可以大大减少编写代码和在生产环境中运行代码之间的延迟</li></ul><br><hr><h3 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2. 安装Docker"></a>2. 安装Docker</h3><p><strong>卸载旧版</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs linxu">yum remove docker \<br>docker-client \<br>docker-ciient-latest \<br>docker-common \<br>docker-latest \<br>docker-latest-logrotate \<br>docker-logrotate \<br>docker-engine<br></code></pre></td></tr></table></figure><br><p><strong>配置Docker的yum库</strong></p><p>安装一个yun工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">yum install -y yum-utils<br></code></pre></td></tr></table></figure><p>安装完毕后，执行命令，配置Docker的yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>安装Docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><br><p><strong>启动和校验</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 启动docker<br>systemctl start docker<br><br># 停止docker<br>systemctl stop docker<br><br># 重启<br>systemctl restart docker<br><br># 开机自启<br>systemctl enable docker<br><br># 执行docker ps命令，如果不报错说明启动成功了<br></code></pre></td></tr></table></figure><br><hr><h3 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h3><p>使用Docker来安装MySQL，先停掉Linux中的MySQL</p><p>安装MySQL的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs linux">docker run -d \<br>--name mysql \<br>-p 3306:3306 \<br>-e TZ=Asia/Shanghai \<br>-e MYSQL_ROOT_PASSWORD=020427 \<br>mysql<br></code></pre></td></tr></table></figure><br><p>可以通过本机电脑连接到虚拟机的MySQL</p><img src="/2023/12/13/Docker/image-20231217205124016.png" alt="image-20231217205124016" style="zoom:67%;"><p><img src="/2023/12/13/Docker/image-20231217205218810.png" alt="image-20231217205218810"></p><p>当我们利用Docker安装应用时，Docker会自动搜索并下载应用镜像。镜像不仅包含应用本身，还包含应用运行所需要的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，称为容器</p><p>Docker官网维护的公共<strong>镜像仓库</strong>：<a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a></p><img src="/2023/12/13/Docker/image-20231217204228958.png" alt="image-20231217204228958" style="zoom: 50%;"><br><p><strong>命令解读</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs linux">docker run -d \<br>--name mysql \<br>-p 3306:3306 \<br>-e TZ=Asia/Shanghai \<br>-e MYSQL_ROOT_PASSWORD=123 \<br>mysql<br></code></pre></td></tr></table></figure><ul><li><strong>docker run</strong> ：创建并运行一个容器，**-d**是让容器在后台运行</li><li><strong>–name mysql</strong> ：给容器起一个名字，必须唯一</li><li><strong>-p 3306:3306</strong> ：设置端口映射，前面是主机端口，后面是容器端口</li><li><strong>-e KEY&#x3D;VALUE</strong> : 设置环境变量，不同的容器需要不同的环境变量，可以在Docker的镜像仓库查看有容器哪些环境变量</li><li><strong>mysql</strong> ：指定运行的镜像名字，镜像名称一般由两部分组成：[repository]:[tag]<ul><li>repository是镜像名</li><li>tag是版本号</li><li>如果没有版本号则默认是最新版本的镜像</li></ul></li></ul><br><hr><h3 id="4-常见命令"><a href="#4-常见命令" class="headerlink" title="4. 常见命令"></a>4. 常见命令</h3><p>Docker最常见的命令就是操作镜像和容器，详情见<a href="https://docs.docker.com/">官方文档</a></p><img src="/2023/12/13/Docker/image-20231218163616881.png" alt="image-20231218163616881" style="zoom:67%;"><ul><li>docker pull：从镜像仓库拉取或更新指定镜像</li><li>docker pull：把本地镜像推送到远程镜像仓库中去</li><li>docker images：列出本地存储的所有docker镜像</li><li>docker rmi：从主机节点中删除一个或多个镜像，-f是强制删除</li><li>docker build：根据DockerFile和context来自定义docker镜像</li><li>docker save：把打包好的镜像以压缩包的形式保存到本地</li><li>docker load：把压缩文件加载在本地镜像中</li><li>docker run：创建一个新的容器并运行</li><li>docker stop：停止容器</li><li>docker start：启动容器</li><li>docker logs：获取容器的日志</li><li>docker exec：通过这个命令可以在不需要进入容器的情况下直接与容器内的环境进行交互</li><li>docker ps：列出正在运行的docker容器,-a是显示所有容器包括未运行的</li><li>docker rm：删除一个或多个容器，添加-f可以强制删除正在运行的容器</li></ul><br><hr><h3 id="5-数据卷挂载"><a href="#5-数据卷挂载" class="headerlink" title="5. 数据卷挂载"></a>5. 数据卷挂载</h3><p><strong>数据卷</strong>是一种用于持久化存储容器数据的机制，它是一个可供一个或多个容器使用的特殊目录，绕过了联合文件系统，有很多特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除、</li></ul><br><p><strong>数据卷挂载</strong>是将宿主机的数据卷挂载到Docker容器中的目录中（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes），数据卷目录由Docker管理。这样做的好处是容器可以直接访问和使用这些数据，而且这些数据在容器之间是可以共享的</p><p>Docker提供了两种挂载方式，<code>-v</code>和<code>-mount</code></p><br><p>数据卷是容器内目录和宿主机目录之间映射的桥梁</p><img src="/2023/12/13/Docker/image-20231220161446653.png" alt="image-20231220161446653" style="zoom: 50%; "><br><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">docker volume create</td><td align="center">创建数据卷</td></tr><tr><td align="center">docker volume ls</td><td align="center">查看所有数据卷</td></tr><tr><td align="center">docker volume rm</td><td align="center">删除指定数据卷</td></tr><tr><td align="center">docker volume Inspect</td><td align="center">查看某个数据卷的详情</td></tr><tr><td align="center">docker volume prune</td><td align="center">清除数据卷</td></tr></tbody></table><br><p><strong>通过案例——利用Nginx容器部署静态资源来实现数据卷的挂载</strong></p><p>需求：</p><ul><li>创建Nginx容器，修改nginx容器内的html目录下的index.html文件内容</li><li>将静态资源部署到nginx的html目录</li></ul><br><p>当容器创建时，如果挂载了数据卷且数据卷不存在，会自动创建数据卷</p><p>在执行docker run命令时，使用**-v 数据卷:容器内目录**可以完成数据卷挂载</p><br><p><img src="/2023/12/13/Docker/image-20231220164110981.png" alt="image-20231220164110981"></p><ul><li>通过docker run -d –name nginx -p 180:180 -v html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx 创建并运行一个容器，并挂载数据卷</li><li>html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html   html容器名， &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html要挂载的容器中的目录</li><li>docker volume ls 查看所有数据卷</li><li>docker volume inspect html 查看html数据卷的详细信息</li><li>Mountpoint 挂载在宿主机中的位置</li></ul><p>这时候想修改nginx容器中的html目录下的文件只需要在宿主机中对应的文件中（MountPoint）修改就可以了</p><br><hr><h3 id="6-本地目录挂载"><a href="#6-本地目录挂载" class="headerlink" title="6. 本地目录挂载"></a>6. 本地目录挂载</h3><p>本地目录挂载是指将设备文件中的顶级目录连接到Linux跟目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。这个过程称为“挂载”</p><p>并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录</p><br><ul><li>在执行docker run 命令时，使用**-v 本地目录:容器内目录**可以完成本地目录挂载</li><li>本地目录必须以<code>/</code>或<code>./</code>开头，如果直接以名称开头会被识别为数据卷而非本地目录<ul><li>-v mysql:&#x2F;var&#x2F;lib&#x2F;mysql会被识别为一个名为mysql的数据卷</li><li>-v &#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql会被识别为当前目录下的mysql目录</li></ul></li></ul><br><hr><h3 id="7-自定义镜像"><a href="#7-自定义镜像" class="headerlink" title="7. 自定义镜像"></a>7. 自定义镜像</h3><p><strong>镜像结构</strong></p><p>镜像中包含了应用程序所需要的运行环境、函数库、配置、以及应用本身等各种文件，这些文件分层打包</p><img src="/2023/12/13/Docker/image-20231223170500748.png" alt="image-20231223170500748" style="zoom: 67%;"><br><p><strong>DockerFile</strong><br>DockerFile是一个文本文件，其中包含一个个的指令，用来说明要执行什么操作来构建镜像</p><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">指定基础镜像</td><td align="center">FROM centos:7</td></tr><tr><td align="center">ENV</td><td align="center">设置环境变量</td><td align="center">ENV key value</td></tr><tr><td align="center">COPY</td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center">COPY .&#x2F;jrell.tar.gz &#x2F;tmp</td></tr><tr><td align="center">RUN</td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center">RUN tar -zxvf &#x2F;tmp&#x2F;jrell.tar.gz &amp;&amp; EXPORTS path&#x3D;&#x2F;tmp&#x2F;jrell:$path</td></tr><tr><td align="center">EXPOSE</td><td align="center">指定容器运行时监听的端口</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p><a href="https://docs.docker.com/engine/reference/builder">官方文档</a></p><br><p><strong>案例</strong></p><p>基于JDK为基础镜像，省略前面步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 基础镜像<br>FROM openjdk:8.0-jre-buster<br># 拷贝jar包<br>COPY docker-demo.jar /app.jar<br># 入口<br>ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]<br></code></pre></td></tr></table></figure><br><p><strong>自定义镜像</strong></p><p>当编写好DockerFile，可以利用下面命令来构建镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">docker build -t myImage:1.0 .<br></code></pre></td></tr></table></figure><ul><li>-t ：是给镜像起名，格式是repository:tag的格式，不指定tag时，默认为latest</li><li>. ：是指定Docker所在目录，如果就在当前目录，则指定为”.”</li></ul><br><hr><h3 id="8-Docker网络"><a href="#8-Docker网络" class="headerlink" title="8. Docker网络"></a>8. Docker网络</h3><p>Docker网络是Docker容器之间以及容器和宿主机之间的网络连接的一种机制。在Docker中，每个容器都可以有自己的网络栈，包括网络接口、IP地址和网络配置。Docker网络提供了一种简单、可扩展的方式来组织和管理容器，使得它们可以在同一个网络中进行通信。Docker提供了几种网络模式，包括bridge、host、none和container。</p><ul><li><strong>Bridge模式</strong>：在该模式中，Docker守护进程创建了一个虚拟以太网桥docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。</li><li><strong>Host模式</strong>：采用host网络模式的Docker容器，可以直接使用宿主机的IP地址与外界进行通信。</li><li><strong>None模式</strong>：none网络模式即不为Docker容器创建任何的网络环境，容器内部就只能使用loopback网络设备。</li><li><strong>Container模式</strong>：处于这个模式下的Docker容器会共享一个网络栈，这样两个容器之间可以使用localhost高效快速通信</li></ul><p><strong>默认情况下、所有容器都是以bridge方式连接到Docker的一个虚拟网桥上</strong></p><img src="/2023/12/13/Docker/image-20231223202118445.png" alt="image-20231223202118445" style="zoom:67%;"><br><p>默认分配的容器ip地址是不固定的，服务器重启或者其它操作都有可以是容器的ip地址发生变化，所以需要加入自定义网络</p><p>加入自定义网络的容器才可以通过容器名互相访问，Docker的网络操作命令如下：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">docker network create</td><td align="center">创建一个网络</td></tr><tr><td align="center">docker network ls</td><td align="center">查看所有网络</td></tr><tr><td align="center">docker network rm</td><td align="center">删除指定网络</td></tr><tr><td align="center">docker network prune</td><td align="center">清除未使用的网络</td></tr><tr><td align="center">docker network connect</td><td align="center">使指定容器连接加入某网络</td></tr><tr><td align="center">docker network disconnect</td><td align="center">使指定容器连接离开某网络</td></tr><tr><td align="center">docker network inspect</td><td align="center">查看网络详细信息</td></tr></tbody></table><br><p>创建一个自定义网络</p><img src="/2023/12/13/Docker/image-20231223203413708.png" alt="image-20231223203413708" style="zoom:80%;"><br><p>把mysql容器加入自定义网络中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">docker network connect zheng mysql<br></code></pre></td></tr></table></figure><p>通过docker inspect mysql查看mysql容器的网络</p><img src="/2023/12/13/Docker/image-20231223204110631.png" alt="image-20231223204110631" style="zoom:80%;"><p>可以看见已经把容器添加到自定义网络中了</p><br><p>在创建容器时就加入自定义网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">docker run -d --name nginx -p 8081:8081 --network zheng nginx<br></code></pre></td></tr></table></figure><img src="/2023/12/13/Docker/image-20231223205249964.png" alt="image-20231223205249964" style="zoom: 80%;"><br><p>然后就这两个容器就可以通过名字互相ping了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB引擎</title>
    <link href="/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/"/>
    <url>/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<p>该笔记是基于b站视频学习制作:<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=133&vd_source=db8e7458ec195ac74979ce5478cbc624">MySQL数据库入门到精通</a></p><br><hr><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>意义：</strong></p><ul><li>InnoDB是MySQL的一种存储引擎，它是MySQL 8.0的默认存储引擎。InnoDB存储引擎的主要特点是支持事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。它也是MySQL上第一个提供外键约束的表引擎</li><li>InnoDB存储引擎的设计目标是在高可靠性和高性能之间取得平衡。它将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB。这样的设计可以减少内存与磁盘的交互次数，从而提升性能</li><li>此外，InnoDB还支持ACID事务，即原子性、一致性、隔离性、持久性。这些特性使得InnoDB在处理事务方面具有优势</li><li>总的来说，InnoDB存储引擎在MySQL中的应用非常广泛，它的存在使得MySQL能够更好地处理复杂的事务和保证数据的安全性。如果你想查看自己的数据库默认使用的存储引擎，可以通过使用命令<code>SHOW VARIABLES LIKE &#39;storage_engine&#39;;</code></li></ul><br><p><strong>作用：</strong></p><ul><li><strong>事务处理</strong>：InnoDB支持ACID事务，即原子性、一致性、隔离性、持久性。这些特性使得InnoDB在处理事务方面具有优势</li><li><strong>数据完整性</strong>：InnoDB是MySQL上第一个提供外键约束的表引擎，这有助于保证数据的完整性和一致性</li><li><strong>并发控制</strong>：InnoDB使用多版本并发控制(MVCC)来处理并发操作，这可以提高数据库的并发处理能力</li><li><strong>崩溃恢复</strong>：InnoDB具有崩溃恢复能力，可以在系统崩溃后恢复数据，保证数据的安全性</li><li><strong>性能优化</strong>：InnoDB将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB。这样的设计可以减少内存与磁盘的交互次数，从而提升性能</li></ul><br><hr><h4 id="2-逻辑存储结构"><a href="#2-逻辑存储结构" class="headerlink" title="2. 逻辑存储结构"></a>2. 逻辑存储结构</h4><img src="/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/image-20231202215131646.png" alt="image-20231202215131646" style="zoom:67%;"><ul><li>表空间（ibd文件）：一个MySQL实例可以对应多个表空间，用于存储记录、索引等数据</li><li>段：分为数据段（Leaf node segment）、段索引（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</li><li>区：表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页</li><li>页：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区</li><li>行：InnoDB存储引擎数据是按行进行存放的<ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值为trx_id隐藏列</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li></ul></li></ul><br><hr><h4 id="3-内存结构"><a href="#3-内存结构" class="headerlink" title="3. 内存结构"></a>3. 内存结构</h4><p>MySQL 5.5版本开始就默认使用InnoDB作为存储引擎，它擅长事务处理，具有崩溃恢复特性。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构</p><img src="/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/image-20231203140524143.png" alt="image-20231203140524143" style="zoom:67%;"><br><ul><li>Buffer Pool: 缓冲池是主内存中的一个区域，里面可以缓存磁盘上一些经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据，若缓冲池没有数据，则从磁盘中加载并缓存。如何再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li><li>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：<ul><li>free page：空闲page，未被使用</li><li>clean page：被使用page，数据没有被修改过</li><li>dirty page：脏页：没使用page，数据被修改过</li></ul></li><li>Change Buffer：更改缓冲区（针对于非唯一二级索引页），在执行DML语句（增删改）时，如果这些数据Page没有在Buffer Pool中，则不会直接操作数据库，而是将数据变更存在Change Buffer中，在未来数据被读取的时候，再将数据合并到Buffer Pool中，任何再将合并后的数据刷新到磁盘中去<ul><li>Change Buffer存在的意义：<ul><li>在InnoDB存储引擎中，change buffer的存在有着重要的意义。当索引字段内容发生更新时（例如update、insert、delete），如果对应的索引页在Buffer Pool中命中，就会直接更新缓存页。否则，InnoDB会将这些更新操作缓存在change buffer中，这样就无需从硬盘读入索引页。下次查询索引页时，会将索引页读入Buffer Pool，然后将change buffer中的操作应用到对应的缓存页，得到最新结果，这个过程称为merge。通过这种方式，可以保证数据逻辑的正确性。</li><li>此外，change buffer还有助于减少硬盘随机IO读取和提高内存利用率，从而提升数据库的并发能力。为了防止异常宕机丢失缓存，当事务提交时，InnoDB会将change buffer记录的内容持久化到磁盘（redo log），等待时机更新磁盘的数据文件（刷脏）。因此，change buffer在内存中，如果万一MySQL实例挂了或宕机了，这次的更新操作不会全部丢失。最后，MySQL可以通过ibdata1或redolog恢复change buffer。</li><li>总的来说，change buffer的存在可以提升索引性能，减少硬盘随机IO读取，提高内存利用率，以及保证数据逻辑</li></ul></li></ul></li><li>Adaptive Hash Index：自适应hash索引，用于优化Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引</li><li>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log、 undo log），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或者删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I&#x2F;O。有两个参数如下：<ul><li>innodb_log_buffer_size：缓冲区大小</li><li>innodb_flush_log_at_trx_commit：日志刷新磁盘时机。有0,1,2三个值<ul><li>1：日志在每次事务提交时写入并刷新到磁盘（默认值）</li><li>0：日志每次将日志写入并刷新到磁盘一次</li><li>2：日志在每次事务提交后写入、并每秒刷新到磁盘一次</li></ul></li></ul></li></ul><br><hr><h4 id="4-磁盘结构"><a href="#4-磁盘结构" class="headerlink" title="4. 磁盘结构"></a>4. 磁盘结构</h4><img src="/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/image-20231203140612885.png" alt="image-20231203140612885" style="zoom: 67%;"><ul><li><code>System Tablespace</code>：（系统表空间）是存储区域，用于存储<code>doublewriter buffer</code>（双写缓冲区）和<code>change buffer</code>（变更缓冲区）。如果用户创建的表在系统表空间中创建，而不是在文件每表或者通用表空间中创建，那么系统表空间也可能包含表和索引数据，在以前的MySQL版本中，系统表空间包含了InnoDB数据字典</li><li><code>File-Per-Table Tablespaces</code>：（每表一个文件的表空间）是一种数据存储方式。当启用了<code>innodb_file_per_table</code>配置选项时，每个InnoDB表和它的索引会被单独存储在<code>.ibd</code>数据文件中。这个<code>.ibd</code>数据文件代表一个单独的表空间</li><li><code>General Tablespaces</code>：（通用表空间）是一种可以存储多个表数据的共享表空间。它是使用CREATE TABLESPACE语法创建的</li><li><code>Undo Tablespaces</code>:（撤销表空间）包含撤销日志，这些日志是包含有关如何撤销事务对聚簇索引记录的最新更改的信息的记录集合。MySQL实例在初始化时会自动创建两个默认的表空间（初始大小16M），用于存储undo log日志</li><li><code>Temporary Tablespaces</code>：（临时表空间）是数据库中用于存储临时数据的空间</li><li><code>Doublewrite Buffer Files:</code>（双写缓冲区）InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区中，便于系统异常时恢复数据</li><li><code>Redo Log：</code>（重做日志），是用来实现事务的持久性。该日志由两部分组成：重做日志缓冲（redo log buffer）和重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有的修改信息存储在该日志中</li></ul><br><hr><h3 id="5-后台线程"><a href="#5-后台线程" class="headerlink" title="5. 后台线程"></a>5. 后台线程</h3><p>​                                                                                               </p><p><strong>Master Thread</strong></p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中去，保持数据的一致性，还包括赃页的刷新、合并插入缓存、undo页的回收</p><br><p><strong>IO Thread</strong></p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调</p><br><p><strong>Purge Thread</strong></p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收</p><br><p><strong>Page Cleaner Thread</strong></p><p>协助Master Thread刷新赃页到磁盘的线程，它可以减轻Master Thread的工资压力，减少阻塞</p><br><hr><h3 id="6-事务原理"><a href="#6-事务原理" class="headerlink" title="6. 事务原理"></a>6. 事务原理</h3><p><strong>事务：</strong>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败</p><br><p><strong>特性：</strong></p><ul><li><strong>原子性（Atomicity）：</strong>事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li><strong>一致性（Consistency）：</strong>事务完成时，必须使所有的数据都保持一致</li><li><strong>隔离性（Isolation）：</strong>数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li><strong>持久性（Durability）：</strong>事务一旦提交或者回滚，它对数据库中的数据的改变是永久的</li></ul><br><p>redo log 和 undo log 保证了事务的原子性、一致性和持久性<br>锁和MVCC保证了隔离性</p><br><p><strong>redo log</strong></p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性</p><p>该日志由两部分组成：重做日志缓冲（redo log buffer）和重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有的修改信息存储在该日志中，用于在刷新赃页到磁盘，发生错误时，进行数据恢复</p><img src="/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/image-20231213202354900.png" alt="image-20231213202354900" style="zoom: 80%;"><br><p><strong>undo log</strong></p><p>回滚日志，用于记录数据被修改前的信息，作用主要有两个：提供回滚和MVCC</p><p>undo log是逻辑日志，它记录的是对数据的操作。当delete一条记录时，undo log中就会记录一条对应的insert记录，当update一条记录时，就会记录一条相反的update日志</p><p>undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC</p><p>undo log存储：undo log采用段的方式进行管理和记录</p><br><hr><h3 id="7-MVCC"><a href="#7-MVCC" class="headerlink" title="7. MVCC"></a>7. MVCC</h3><p>MVCC，即多版本并发控制（Multi-Version Concurrency Control），是一种数据库管理系统中实现并发访问的方法。它允许在数据库中存在多个数据版本，从而使不同的事务能够同时访问同一数据的不同版本，提高了系统的并发性能。</p><br><p><strong>当前读</strong></p><p>当前读是指读取数据的最新版本，并且在读取的过程中对数据加锁，以防止其他事务同时修改相同的记录。这种读取方式常用于需要保证数据一致性的场景，如更新、删除、插入操作，以及使用select … for update（都是排他锁）或select … lock in share mode（共享锁）进行的查询</p><br><p><strong>快照读</strong></p><p>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p><ul><li>Read Committed：每次select，都生成一个快照读</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方</li><li>Serializable：快照读会退回为当前读</li></ul><br><p><strong>记录中的隐藏字段</strong></p><table><thead><tr><th align="center">隐藏字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">DB_TRX_ID</td><td align="center">最近修改事务ID，记录插入这条记录或者最后一次修改该记录的事务ID</td></tr><tr><td align="center">DB_ROLL_PTR</td><td align="center">回滚指针，指向这条记录的是一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td align="center">DB_ROW_ID</td><td align="center">隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段（如果有主键就不生成）</td></tr></tbody></table><br><p><strong>undo log</strong></p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照时也需要，不会立即被删除</p><br><p><strong>undo log版本链</strong></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p><p>当一个事务对数据进行修改时，它会在undo log中记录下修改前的数据版本，并更新数据记录的<code>DB_TRX_ID</code>和<code>DB_ROLL_PTR</code>。如果另一个事务再次修改这条数据，它也会在undo log中记录下当前的数据版本，并更新<code>DB_ROLL_PTR</code>指向新的undo log。这样通过<code>DB_ROLL_PTR</code>指针串联起来的undo log就形成了一个版本链</p><p>这个版本链允许数据库在执行回滚操作时，根据事务的需要找到正确的数据版本，同时它也支持MVCC机制，使得不同的事务可以看到数据的不同历史版本，从而实现非阻塞的读取操作</p><br><p><strong>ReadView</strong></p><p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（为提交的）id</p><p>在数据库系统中，特别是在使用MVCC（多版本并发控制）机制的系统中，ReadView是用来实现不同隔离级别下的一致性读取的关键数据结构。ReadView的生成过程通常与事务的开始和查询操作紧密相关。</p><br><p><strong>ReadView的生成过程</strong></p><ul><li><strong>事务开始</strong>：当一个事务开始时，数据库系统会为该事务分配一个唯一的事务ID（trx_id）</li><li><strong>活跃事务列表</strong>：系统会维护一个活跃事务列表，其中包含了所有尚未提交的事务的ID</li><li><strong>创建ReadView</strong>：在执行查询操作时，系统会创建一个ReadView</li><li><strong>确定数据版本可见性</strong>：ReadView会根据事务ID和数据版本的trx_id来确定哪些数据版本对当前事务是可见的</li></ul><br><p>ReadView中包含了四个核心字段</p><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">m_ids</td><td align="center">当前活跃的事务ID集合</td></tr><tr><td align="center">min_trx_id</td><td align="center">最小活跃事务ID</td></tr><tr><td align="center">max_trx_id</td><td align="center">预分配事务ID，最大活跃事务ID+1（事务ID是自增的）</td></tr><tr><td align="center">creator_trx_id</td><td align="center">ReadView创建者的事务ID</td></tr></tbody></table><br><p><strong>版本链访问规则</strong></p><p>trx_id表示的是当前<strong>被访问</strong>版本的ID</p><img src="/2023/12/02/InnoDB%E5%BC%95%E6%93%8E/image-20231213223050767.png" alt="image-20231213223050767" style="zoom:67%;"><ul><li>如果被访问版本的<code>trx_id</code>与<code>ReadView</code>中的<code>creator_trx_id</code>值相同，说明当前事务在访问自己修改过的记录，该版本可以被当前事务访问</li><li>如果被访问版本的<code>trx_id</code>小于<code>ReadView</code>中的<code>min_trx_id</code>值，说明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，该版本可以被当前事务访问</li><li>如果被访问版本的<code>trx_id</code>大于或等于<code>ReadView</code>中的<code>max_trx_id</code>值，说明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，该版本不可以被当前事务访问</li><li>如果被访问版本的<code>trx_id</code>值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，就需要判断<code>trx_id</code>属性值是否在<code>m_ids</code>列表中。如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问。如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问</li></ul><br><p>不同的隔离级别，生成的ReadView的时机不同：</p><ul><li>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</li></ul><br><p><strong>隔离级别为RC下，ReadView的工作原理</strong></p><p>RC（读已提交），它是指在这个隔离级别下，一个事务只能读取到其他事务已经提交的修改。这个级别的设计是为了防止脏读现象的发生</p><p>在RC隔离级别下，ReadView的工作原理是确保事务只能看到在该事务开始之前已经提交的更改。这是通过每次查询时都创建一个新的ReadView来实现的</p><br><p><strong>隔离级别为RR下，ReadView的工作原理</strong></p><p>RR（可重复读），它是指这个隔离级别下，一个事务在其执行期间可以多次读取同一数据集，并且每次读取的结果都是相同的，即使在这期间其他事务对这些数据进行了修改或更新。这种特性保证了数据的一致性，避免了在一个事务中出现不可重复读的问题</p><p>当一个事务在RR隔离级别下开始时，它会创建一个ReadView，这个ReadView相当于是一个数据快照。在整个事务执行期间，无论其他事务如何修改数据，当前事务都只能看到ReadView中的数据版本。这就意味着，即使其他事务提交了更新，当前事务仍然能够读取到它最初看到的数据版本，从而实现了可重复读的效果。</p><p>在RR隔离级别下，可以避免不可重复读和幻读，但可能会牺牲一些并发性能。这是因为为了维持数据的一致性，系统需要对数据加锁或使用其他机制来保证在事务执行期间数据不会被其他事务修改。这样的设计是为了在数据一致性和系统性能之间取得平衡。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot3学习笔记</title>
    <link href="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站视频<a href="https://www.bilibili.com/video/BV1Es4y1q7Bf/?share_source=copy_web">SpringBoot零基础教程</a>学习完成</p><h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p><strong>环境要求</strong></p><table><thead><tr><th>环境&amp;工具</th><th>版本（or later）</th></tr></thead><tbody><tr><td>SpringBoot</td><td>3.0.5+</td></tr><tr><td>IDEA</td><td>2021.2.1+</td></tr><tr><td>Java</td><td>17+</td></tr><tr><td>Maven</td><td>3.5+</td></tr><tr><td>Tomcat</td><td>10.0+</td></tr><tr><td>Servlet</td><td>5.0+</td></tr><tr><td>GraalVM Community</td><td>22.3+</td></tr><tr><td>Native Build Tools</td><td>0.9.19+</td></tr></tbody></table><br><p><strong>SpringBoot是什么</strong></p><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring 应用（说明：SpringBoot底层是Spring）</strong>大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><p><strong>特性：</strong>简化开发，简化配置，简化整合，简化部署，简化监控，简化运维</p><br><h4 id="1-2-开发流程"><a href="#1-2-开发流程" class="headerlink" title="1.2 开发流程"></a>1.2 开发流程</h4><p><strong>创建项目</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    所有springboot项目都要继承spring-boot-starter-parent--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p><strong>导入场景</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    web开发场景启动器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p><strong>主程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MainApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>业务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello springboot3&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>测试</strong></p><p>启动项目，默认端口号8080</p><p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116151721264.png"></p><br><p><strong>打包</strong></p><p>引入打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    springboot应用打包插件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>mvn-clean package</code> 把项目打成可自行的jar包，打包后可以在target中找到</p><p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116203134694.png"></p><br><p><code>java -jar demo.jar</code> 启动项目</p><br><h4 id="1-3-Spring-Initializr"><a href="#1-3-Spring-Initializr" class="headerlink" title="1.3 Spring Initializr"></a>1.3 Spring Initializr</h4><p>通过Spring Initializr 来创建springboot项目</p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116202359617.png" style="zoom: 67%;"><br><p>选择需要的依赖</p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116202838044.png" style="zoom:67%;"><p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116203920906.png" alt="image-20231116203920906"></p><br><hr><h3 id="2-应用分析"><a href="#2-应用分析" class="headerlink" title="2. 应用分析"></a>2. 应用分析</h3><h4 id="2-1-依赖管理机制"><a href="#2-1-依赖管理机制" class="headerlink" title="2.1 依赖管理机制"></a>2.1 依赖管理机制</h4><p>为什么导入<code>starter-web</code>所有相关的依赖都导入进来了？</p><ul><li>想要开发什么场景、就导入对应的场景启动器（依赖）</li><li>maven依赖传递原则，A依赖了B，B又依赖于C，所以A依赖于B和C。所以导入了场景启动器后，在场景启动器中会将所有需要的依赖都导入进来</li></ul><p>为什么版本号都不用写</p><ul><li>每个boot项目都会有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 版本仲裁中心，把常见的jar的依赖版本都声明号了</li></ul><p>自定义版本号</p><ul><li>利用maven的就近原则，在导入依赖时手动声明版本，则该依赖的版本会替换父项目默认的版本</li><li>在项目pom文件中的<code>properties</code>属性中加入版本管理</li></ul><p>第三方的jar包</p><ul><li>boot父项目没有进行版本管理的要自定义版本号</li></ul><br><h4 id="2-2-自动配置机制"><a href="#2-2-自动配置机制" class="headerlink" title="2.2 自动配置机制"></a>2.2 自动配置机制</h4><p><strong>初步理解</strong></p><ul><li>自动配置<code>Tomcat、SpringMVC</code>等<ul><li>导入什么场景，容器中就会自动配置好这个场景的核心组件</li><li>容器中有了什么组件就会有什么功能</li></ul></li><li>默认的包扫描规则<ul><li><code>@SprongBootApplication</code>标注的类就是主程序类</li><li><strong>SpringBoot只会扫描主程序所在的包及其下面的包</strong></li><li>自定义扫描路径<ul><li><code>@SpringBootApplication(scanBasePackages = &quot;com.zheng&quot;)</code>,在启动类的@SpringBootApplication注解上添加属性scanBasePackages,属性的值是需要扫描的包</li><li><code>@ComponentScan(&quot;com.zheng&quot;)</code>，在启动类中添加注解@ComponentScan，属性值是需要扫描的包</li></ul></li></ul></li><li>配置默认值<ul><li>配置文件的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的</li><li>绑定了配置文件中每一项值的类：<strong>属性类</strong></li><li>例如： <code>ServerProperties</code>绑定了所有Tomcat服务器有关的配置、<code>MultipartProperties</code>绑定了所有文件上传相关的配置</li></ul></li><li>按需加载自动配置<ul><li>导入场景<code>spring-boot-starter-web</code></li><li>场景启动器除了会导入相关的依赖，还会导入一个<code>spring-boot-starter</code>，它是所有<code>starter</code>的<code>starter</code>，是基础的<code>starter</code></li><li><code>spring-boot-starter</code>导入了一个包<code>spring-boot-autoconfigure</code>，这个包里面包含各种场景的<code>AutoConfiguration</code>自动配置类</li><li>虽然全场景的自动配置都在<code>spring-boot-autoconfigure</code>这个包，但是不是全部都开启的，只有需要的才会开启</li></ul></li></ul><p><strong>总结：</strong>导入场景启动器、触发<code>Spring-boot-autoconfigure</code>这个包的自动配置生效、容器中就会具有相关场景的功能</p><br><hr><h3 id="3-核心技能"><a href="#3-核心技能" class="headerlink" title="3. 核心技能"></a>3. 核心技能</h3><h4 id="3-1-常见注解"><a href="#3-1-常见注解" class="headerlink" title="3.1 常见注解"></a>3.1 常见注解</h4><p><strong>组件注解</strong></p><p>@Configuration、@SpringBootConfiguration</p><p>@Bean、@Scope</p><p>@Controller、@Service、@Repository、@Component</p><p>@Import</p><p>@ComponentScan</p><p>配置类：</p><ol><li>@Configuration编写一个配置类</li><li>在配置类中，自定义方法给容器中注册组件。配合@Bean</li><li>使用@Import导入第三方的组件</li></ol><br><p><strong>条件注解</strong></p><p>如果注解指定的条件成立，则触发指定行为</p><ul><li>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</li><li>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</li><li>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</li><li>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</li><li>@ConditionalOnBean(value&#x3D;组件类型，name&#x3D;组件名字)：判断容器中是否有这个类型的组件，并且名字是指定的值</li></ul><br><p><strong>属性绑定</strong></p><p><code>@ConfigurationProperties</code></p><p>将容器中任意组件（Bean）的属性值和配置文件的配置项的值进行绑定</p><ul><li>给容器中注册组件（@Component、@Bean）</li><li>使用@ConfigurationProperties声明组件和配置文件的哪些配置进行绑定</li></ul><p><code>@EnableConfigurationProperties</code></p><ul><li>Springboot默认是不会扫描第三方包，如果导入了第三方的包，即时组件上标注了@ConfigurationProperties注解也没用，因为组件扫描不进来，这时候就需要@EnableConfigurationProperties注解来进行属性的绑定并把组件注册进容器</li></ul><br><h4 id="3-2-YAML配置文件"><a href="#3-2-YAML配置文件" class="headerlink" title="3.2 YAML配置文件"></a>3.2 YAML配置文件</h4><p><strong>基本语法</strong></p><ul><li>大小写敏感</li><li>使用缩进表示层级关系，k: v，使用空格分割k，v</li><li>缩进的空格数随意，主要相同层级的元素左对齐即可</li><li><code>#</code>表示注解，从这个字符一直到行尾，都会被解析器忽略</li></ul><br><p><strong>示例</strong></p><p>第一4个类</p><p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117155159086.png"></p><p>只有Person类需要注入到组件中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span> <span class="hljs-comment">//和配置文件person前缀的所有配置进行绑定</span><br><span class="hljs-meta">@Data</span> <span class="hljs-comment">//自动生成JavaBean属性的getter/setter</span><br><span class="hljs-comment">//@NoArgsConstructor //自动生成无参构造器</span><br><span class="hljs-comment">//@AllArgsConstructor //自动生成全参构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthDay;<br>    <span class="hljs-keyword">private</span> Boolean like;<br>    <span class="hljs-keyword">private</span> Child child; <span class="hljs-comment">//嵌套对象</span><br>    <span class="hljs-keyword">private</span> List&lt;Dog&gt; dogs; <span class="hljs-comment">//数组（里面是对象）</span><br>    <span class="hljs-keyword">private</span> Map&lt;String,Cat&gt; cats; <span class="hljs-comment">//表示Map</span><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthDay;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; text; <span class="hljs-comment">//数组</span><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>获取person并输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> ioc.getBean(Person.class);<br>        System.out.println(<span class="hljs-string">&quot;person: &quot;</span> + person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>properties表示法</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">person.name</span>=<span class="hljs-string">张三</span><br><span class="hljs-attr">person.age</span>=<span class="hljs-string">18</span><br><span class="hljs-attr">person.birthDay</span>=<span class="hljs-string">2010/10/12 12:12:12</span><br><span class="hljs-attr">person.like</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">person.child.name</span>=<span class="hljs-string">李四</span><br><span class="hljs-attr">person.child.age</span>=<span class="hljs-string">12</span><br><span class="hljs-attr">person.child.birthDay</span>=<span class="hljs-string">2018/10/12</span><br><span class="hljs-attr">person.child.text[0]</span>=<span class="hljs-string">abc</span><br><span class="hljs-attr">person.child.text[1]</span>=<span class="hljs-string">def</span><br><span class="hljs-attr">person.dogs[0].name</span>=<span class="hljs-string">小黑</span><br><span class="hljs-attr">person.dogs[0].age</span>=<span class="hljs-string">3</span><br><span class="hljs-attr">person.dogs[1].name</span>=<span class="hljs-string">小白</span><br><span class="hljs-attr">person.dogs[1].age</span>=<span class="hljs-string">2</span><br><span class="hljs-attr">person.cats.c1.name</span>=<span class="hljs-string">小蓝</span><br><span class="hljs-attr">person.cats.c1.age</span>=<span class="hljs-string">3</span><br><span class="hljs-attr">person.cats.c2.name</span>=<span class="hljs-string">小灰</span><br><span class="hljs-attr">person.cats.c2.age</span>=<span class="hljs-string">2</span><br></code></pre></td></tr></table></figure><br><p>输出结果</p><p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117155514578.png" alt="image-20231117155514578"></p><br><p>yaml表示法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">张三</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">birthDay:</span> <span class="hljs-number">2010</span><span class="hljs-string">/10/10</span> <span class="hljs-number">12</span><span class="hljs-string">:12:12</span><br>  <span class="hljs-attr">like:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">child:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">李四</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">birthDay:</span> <span class="hljs-number">2018</span><span class="hljs-string">/10/10</span><br>    <span class="hljs-attr">text:</span> [<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>]<br>  <span class="hljs-attr">dogs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">小黑</span><br>      <span class="hljs-attr">age:</span> <span class="hljs-number">3</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">小白</span><br>      <span class="hljs-attr">age:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">cats:</span><br>    <span class="hljs-attr">c1:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">小蓝</span><br>      <span class="hljs-attr">age:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">c2:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">小绿</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">2</span>&#125; <span class="hljs-comment">#对象也可用&#123;&#125;表示</span><br></code></pre></td></tr></table></figure><br><p>输出结果，要把application.properties中的数据注释掉在运行，否则会输出application.properties中的数据，因为properties的优先级大于yaml</p><p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117155731222.png"></p><br><p><strong>细节</strong></p><ul><li>birthDay推荐写为brith-day</li><li>文本：<ul><li>单引号不会转义[会把\n作为普通字符输出]</li><li>双引号会转义[\n会显示为换行符]</li></ul></li><li>多文档合并<ul><li>使用<code>---</code>可以把多个yaml文档合并在一个文档中，每个文档区依然认为内容独立</li></ul></li></ul><br><p><strong>lombok</strong></p><p>使用lombok创建可以简化JavaBean的开发。能自动生成setter、getter、构造器、toString方法、自动生成Builder模式等</p><p><code>@Data</code>默认只会生成无参构造器，如果需要有参构造器需要用注解自己添加</p><p>&#96;&#96;@NoArgsConstructor&#96; 自动生成无参构造器</p><p><code>@AllArgsConstructor</code> 自动生成全参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>    &lt;scope&gt;compile&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117160611543.png" style="zoom:67%;"><br><h4 id="3-3-日志配置"><a href="#3-3-日志配置" class="headerlink" title="3.3 日志配置"></a>3.3 日志配置</h4><p>项目开发不要编写<code>System.out.println()</code>，应该使用<code>日志</code>记录信息</p><br><p><strong>简介</strong></p><ul><li>Spirng使用<code>commons-logging</code>作为内部日志，但底层日志实现是开放的，可以对接其它日志框架，从Spring5开始把<code>commons-logging</code>集成在spring中，不需要再引入</li><li>支持<code>jul</code>，<code>log4j2</code>，<code>logback</code>。SpringBoot提供了默认的控制台输出配置，也可以配置输出为文件</li><li><code>logback</code>是默认使用的</li></ul><br><p><strong>SpringBoot是如何把日志默认配置好的</strong></p><ol><li>每个<code>starter</code>场景都会导入一个核心场景<code>spring-boot-starter</code></li><li>核心场景引用了日志的所有功能<code>spring-boot-starter-logging</code></li><li>默认使用了<code>logback + slf4j</code>作为默认底层日志</li><li>日志是系统一启动就要用的</li><li>日志是利用监听器机制配置好的，<code>ApplicationListener</code></li><li>日志所有的配置都是可以通过修改配置文件实现的。以<code>logging</code>开始所有的配置</li></ol><br><p><strong>日志格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2023</span>-<span class="hljs-number">11</span>-17T15:<span class="hljs-number">57</span>:<span class="hljs-number">49.570</span>+08:<span class="hljs-number">00</span>  INFO <span class="hljs-number">17668</span> --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]<br><span class="hljs-number">2023</span>-<span class="hljs-number">11</span>-17T15:<span class="hljs-number">57</span>:<span class="hljs-number">49.570</span>+08:<span class="hljs-number">00</span>  INFO <span class="hljs-number">17668</span> --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/<span class="hljs-number">10.1</span><span class="hljs-number">.7</span>]<br></code></pre></td></tr></table></figure><p>默认输出格式：</p><ul><li>时间和容器：毫秒级精准2023-11-17T15:57:49.570+08:00</li><li>日志级别：<code>ERROR</code>,<code>WARN</code>,<code>INFO</code>,<code>DEBUG</code>,<code>TRACE</code>INFO</li><li>进程ID17668</li><li>消息分隔符—</li><li>线程名：使用[]包含[           main]</li><li>Logger名：通常是产生日志的类名o.apache.catalina.core.StandardService</li><li>消息：日志记录的内容Starting service [Tomcat]</li></ul><p>注意：logback没有FATAL级别，对应的是ERROR</p><br><p>日志的格式是可以修改的，通过在配置文件中自定义日志格式</p><p><code>logging.pattern.console </code> 修改控制台日志的格式</p><p><code>logging.pattern.file</code> 修改日志文件中日志的格式</p><p><code>logging.pattern.dateformat</code> 修改日期格式</p><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117205638097.png" alt="image-20231117205638097" style="zoom:80%;"><br><p><strong>记录日志</strong></p><p>在类上加入注解<code>@Slf4j</code>后，可以通过<code>log.info()</code>在控制台打印日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;hello,Java&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2023</span>-<span class="hljs-number">11</span>-17T21:09:<span class="hljs-number">05.983</span>+08:<span class="hljs-number">00</span>  INFO <span class="hljs-number">16376</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] c.z.logging.controller.HelloController   : hello,Java<br></code></pre></td></tr></table></figure><br><p><strong>日志级别</strong></p><ul><li><p>由低到高：<code>ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF</code></p><ul><li>只会打印指定级别及以上级别的日志</li><li>ALL：打印所有日志</li><li>TRACE：追踪框架详细流程日志，一般不使用</li><li>DEBUG：开发调试细节日志</li><li>INFO：关键、感兴趣的信息日志，一般通过手动INFO在控制台输出自己需要的提示信息</li><li>WARN：警告但不是错误的信息日志，比如版本过低警告</li><li>ERROR：业务错误日志，比如出现各种异常</li><li>FATAL：致命错误日志，比如JVM系统崩溃</li><li>OFF：关闭所有日志</li></ul></li><li><p>所有类的默认日志级别都使用root指定的级别作为默认级别</p></li><li><p>SpringBoot的日志默认级别是<code>INFO</code></p></li><li><p>可以修改所有类的日志级别和指定一个类的日志级别，通过配置<code>application.properties/yaml</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pro">logging.level.root=info<br>logging.level.com.zheng.logging.controller.HelloController=debug<br></code></pre></td></tr></table></figure><ul><li>logging.level.root&#x3D;info 设置所有类的日志级别为INFO</li><li>logging.level.com.zheng.logging.controller.HelloController&#x3D;debug 设置com.zheng.logging.controller.HelloController这个类的日志级别为DEBUG</li></ul></li></ul><br><p><strong>日志分组</strong></p><p>将相关的logger分组在一起，统一配置。SpringBoot也支持。比如把Tomcat相关的日志统一设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prop">logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat<br>logging.level.tomcat=trace<br></code></pre></td></tr></table></figure><br><p>SpringBoot预定义了两个分组<code>web</code>和<code>sql</code></p><table><thead><tr><th align="center">Name</th><th>Loggers</th></tr></thead><tbody><tr><td align="center">web</td><td>org.springframework.core.codec, org.springframework.http, org.springframework.web, org.springframework.boot.actuate.endpoint.web, org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td align="center">sql</td><td>org.springframework.jdbc.core, org.hibernate.SQL, org.jooq.tools.LoggerListener</td></tr></tbody></table><br><p><strong>文件输出</strong></p><p>SpringBoot默认只把日志写在控制台，如果想额外记录日志到文件，可以在<code>application,properties</code>中添加<code>logging.file.name</code>或者<code>logging.file.path</code>配置项</p><table><thead><tr><th>logging.file.name</th><th>logging.file.path</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>未指定</td><td>未指定</td><td></td><td>仅控制台输出</td></tr><tr><td><strong>指定</strong></td><td>未指定</td><td>my.log</td><td>写入指定文件。可以加路径</td></tr><tr><td>未指定</td><td><strong>指定</strong></td><td>&#x2F;var&#x2F;log</td><td>写入指定目录，文件名为spring.log</td></tr><tr><td><strong>指定</strong></td><td><strong>指定</strong></td><td></td><td>以logging.file.name为准</td></tr></tbody></table><p>当两个配置项都存在时以logging.file.name为准</p><br><p><strong>文件归档与滚动切割</strong></p><p><strong>归档：</strong>每天的日志单独存放在一个文件中</p><p><strong>切割：</strong>指定每个文件的存储上限，超过上限时切割成另一个文件</p><ul><li><p>每天的日志应该单独分割出来存储。如果使用<code>logback</code>（SpringBoot默认整合），可以通过<code>application.properties/yaml</code>文件指定日志滚动规则</p></li><li><p>如果是其他日志系统，需要自行配置,添加log4j2.xml或log4j2-spring.xml</p></li><li><p>支持的滚动规则如下</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>logging.logback.rollingpolicy.file-name-pattern</td><td>日志存档的文件名格式（默认值：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz）</td></tr><tr><td>logging.logback.rollingpolicy.clean-history-on-start</td><td>应用启动时是否清除以前存档（默认值：false）</td></tr><tr><td>logging.logback.rollingpolicy.max-file-size</td><td>存档前，每个日志文件的最大大小（默认值：10MB）</td></tr><tr><td>logging.logback.rollingpolicy.total-size-cap</td><td>日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置1GB则磁盘存储超过 1GB 日志后就会删除旧日志文件</td></tr><tr><td>logging.logback.rollingpolicy.max-history</td><td>日志文件保存的最大天数(默认值：7).</td></tr></tbody></table></li></ul><br><p><strong>自定义日志系统</strong></p><table><thead><tr><th>日志系统</th><th>自定义</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><p>建议在日志配置中使用<code>-spring</code>变量，例如配置文件名用<code>logback-spring.xml</code>而不是<code>logback.xml</code>。如果不添加<code>-spring</code>，spring无法完全控制日志初始化</p><br><hr><h3 id="4-Web开发"><a href="#4-Web开发" class="headerlink" title="4. Web开发"></a>4. Web开发</h3><h4 id="4-1-Web场景"><a href="#4-1-Web场景" class="headerlink" title="4.1 Web场景"></a>4.1 Web场景</h4><p>整合文web场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>引入了<code>autoconfigure</code>功能<br><code>@EnableAutoConfiguration</code>注解使用<code>@Import(AutoConfigurationImportSelector.calss)</code>批量导入组件</p><p>绑定了配置文件的一堆配置项</p><ul><li>SpringMVC的所有配置<code>spring.mvc</code></li><li>Web场景通用配置<code>spring.web</code></li><li>文件上传配置<code>spring.servlet.multipart</code></li><li>服务器的配置<code>server</code></li></ul><br><hr><h3 id="5-数据访问"><a href="#5-数据访问" class="headerlink" title="5. 数据访问"></a>5. 数据访问</h3><h4 id="5-1-SpringBoot整合Spring、MyBatis、SpringMVC"><a href="#5-1-SpringBoot整合Spring、MyBatis、SpringMVC" class="headerlink" title="5.1 SpringBoot整合Spring、MyBatis、SpringMVC"></a>5.1 SpringBoot整合Spring、MyBatis、SpringMVC</h4><p>详情见：<a href="lzhengjy.gitee.io/2023/11/09/SpringBoot%E6%95%B4%E5%90%88MyBatis%E5%92%8CSpringMVC/">SpringBoot整合SSM</a></p><p>所有的<code>Mybatis配置</code>写在<code>application.properties</code>中</p><p>所有的sql写在对应xml文件中或者通过注解写在对应的mapper接口上</p><br><h4 id="5-2-自动配置分析"><a href="#5-2-自动配置分析" class="headerlink" title="5.2 自动配置分析"></a>5.2 自动配置分析</h4><p><strong>jdbc场景的自动配置</strong></p><ul><li><code>mybatis-spring-boot-starter</code>导入 <code>spring-boot-starter-jdbc</code>，jdbc是操作数据库的场景</li><li>jdbc场景的几个自动装配<ul><li>org.springframework.boot.autoconfigure.jdbc.<strong>DataSourceAutoConfiguration</strong><ul><li>数据源的自动装配</li><li>所有和数据源有关的配置绑定在<code>DataSourceProperties</code>中</li><li>默认使用<code>HikariDataSource</code></li></ul></li><li>org.springframework.boot.autoconfigure.jdbc.<strong>JdbcTemplateAutoConfiguration</strong><ul><li>给容器中放了<code>JdbcTemplate</code>操作数据库</li></ul></li><li>org.springframework.boot.autoconfigure.jdbc.<strong>DataSourceTransactionManagerAutoConfiguration</strong><ul><li>支持事务管理</li></ul></li></ul></li></ul><br><p><strong><code>MyBatisAutoConfiguration</code>配置了MyBatis的整合流程</strong></p><ul><li><code>mybatis-spring-boot-starter</code>导入了<code>mybatis-spring-boot-autoconfigure</code></li><li>默认加载两个自动配置类<ul><li>org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration</li><li>org.mybatis.spring.boot.autoconfigure.<strong>MybatisAutoConfiguration</strong><ul><li>必须在数据源配置好后才会配置</li><li>给容器中<code>SqlSessionFactory</code>组件创建和数据库的一次会话</li><li>给容器中<code>SqlSessionTemplate</code>操作数据库</li></ul></li><li>MyBatis的所有配置都绑定在<code>MybatisProperties</code>中</li></ul></li></ul><br><hr><h3 id="6-基础特性"><a href="#6-基础特性" class="headerlink" title="6. 基础特性"></a>6. 基础特性</h3><h4 id="6-1-SpringApplication"><a href="#6-1-SpringApplication" class="headerlink" title="6.1. SpringApplication"></a>6.1. SpringApplication</h4><p><strong>自定义banner</strong></p><ul><li>类路径添加banner.txt或者设置spring.banner.location就可以定制banner了</li><li>spring.banner.location的默认值是classpath:banner.txt(类路径添加banner.txt)</li><li>自定义banner推荐网站：<a href="https://www.bootschool.net/ascii">Spring Boot自定义启动Banner在线生成工具</a></li><li>关闭banner,在application.properties中添加配置<code>spring.main.banner-mode=off</code></li></ul><br><p><strong>测试</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt"> ________  ___  ___  _______   ________   ________<br>|\_____  \|\  \|\  \|\  ___ \ |\   ___  \|\   ____\<br> \|___/  /\ \  \\\  \ \   __/|\ \  \\ \  \ \  \___|<br>     /  / /\ \   __  \ \  \_|/_\ \  \\ \  \ \  \  ___<br>    /  /_/__\ \  \ \  \ \  \_|\ \ \  \\ \  \ \  \|\  \<br>   |\________\ \__\ \__\ \_______\ \__\\ \__\ \_______\<br>    \|_______|\|__|\|__|\|_______|\|__| \|__|\|_______|<br><br></code></pre></td></tr></table></figure><img src="/2023/11/16/SpringBoot3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121145636418.png" style="zoom:67%;"><br><p><strong>自定义 SpringApplication</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Boot306FeaturesApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        SpringApplication.run(Boot306FeaturesApplication.class, args);</span><br><br>        <span class="hljs-comment">// 自定义SpringApplication的底层设置</span><br>        <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(Boot306FeaturesApplication.class);<br>        <span class="hljs-comment">// 调整SpringApplication的参数</span><br><span class="hljs-comment">//        application.setDefaultProperties();</span><br><br>        <span class="hljs-comment">// 把banner关闭,优先级比配置文件低</span><br>        application.setBannerMode(Banner.Mode.OFF);<br>        <span class="hljs-comment">// 运行SpringApplication</span><br>        application.run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>通过FluentBuilderAPI来自定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的environment和listeners的值不能为空</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationBuilder</span>()<br>        .main(Boot306FeaturesApplication.class)<br>        .sources(Boot306FeaturesApplication.class)<br>        .bannerMode(Banner.Mode.OFF)<br><span class="hljs-comment">//        .environment(null)</span><br><span class="hljs-comment">//        .listeners(null)</span><br>        .run(args);<br></code></pre></td></tr></table></figure><br><h4 id="6-2-Profiles"><a href="#6-2-Profiles" class="headerlink" title="6.2 Profiles"></a>6.2 Profiles</h4><p>Profiles是一种配置集合，开发人员可以根据不同的开发环境、需求或者配置条件来定制构建过程</p><br><p><strong>标识环境</strong></p><p>任何<code>@Componet</code>,<code>@Configuration</code>或<code>@ConfigurationProperties</code>可以使用<code>@Profile</code>标记，来指定何时被加载。容器中的组件都可以被@Profiles标记</p><br><p><strong>激活环境</strong></p><p>通过配置文件来配置激活指定环境</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">production</span><br></code></pre></td></tr></table></figure><p>也可用在启动项目时使用命令行激活:<code>--spirng.profiles.active=dev</code></p><br><p><strong>环境包含</strong></p><ul><li><p>激活指定的一个或多个环境：<code>spring.profiles.active=production</code></p></li><li><p>指定默认环境：<code>spring.profiles.default=default</code></p></li><li><p>包含指定环境，无论激活的是哪个环境，指定环境都会被激活生效：<code>spring.profiles.include=dev</code></p><ul><li><p>例如</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.include[0]</span>=<span class="hljs-string">common</span><br><span class="hljs-attr">spring.profiles.include[1]</span>=<span class="hljs-string">local</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>=</code>后面的都是自定义的环境名</p></li></ul><br><p><strong>Profile分组</strong></p><p>创建prod组，指定包含db和mq配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.group.prod[0]</span>=<span class="hljs-string">db</span><br><span class="hljs-attr">spring.profiles.group.prod[1]</span>=<span class="hljs-string">mq</span><br></code></pre></td></tr></table></figure><p>使用<code>--spring.profiles.active=prod</code>，就会激活<code>prod,db,mp</code>配置文件</p><br><p><strong>Profile配置文件</strong></p><ul><li><code>application.properties</code>：主配置文件，在任何环境下都会生效</li><li><code>application-&#123;profile&#125;.properties/yaml</code>：可以作为指定环境的配置文件，例如<ul><li><code>application-dev.properties</code></li><li><code>application-test.yaml</code></li></ul></li><li>激活这个环境，配置就会生效</li><li>配置的优先级：自定义环境的配置文件优先级大于主配置文件优先级，<code>profile优先级</code>&gt;<code>application</code></li></ul><br><h4 id="6-3-外部化配置"><a href="#6-3-外部化配置" class="headerlink" title="6.3 外部化配置"></a>6.3 外部化配置</h4><p>线上应用如何快速修改配置，并应用最新配置？</p><ul><li>SpringBoot使用<strong>配置优先级 + 外部配置</strong>简化配置更新、简化运维</li><li>只需要在项目的jar包所在的文件夹下面在放一个<code>application.properties</code>最新配置文件，重启项目就能更新最新配置</li></ul><br><p><strong>配置优先级</strong></p><ol><li><strong>默认属性</strong>（通过<code>SpringApplication.setDefaultProperties</code>指定的）</li><li>@PropertySource指定加载的配置（需要写在@Configuration类上才可生效）</li><li><strong>配置文件（pplication.properties&#x2F;yml等）</strong></li><li>RandomValuePropertySource支持的random.*配置（如：@Value(“${random.int}”)）</li><li>OS 环境变量</li><li>Java 系统属性（System.getProperties()）</li><li>JNDI 属性（来自java:comp&#x2F;env）</li><li>ServletContext 初始化参数</li><li>ServletConfig 初始化参数</li><li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li><li><strong>命令行参数</strong></li><li>测试属性。(@SpringBootTest进行测试时指定的属性)</li><li>测试类@TestPropertySource注解</li><li>Devtools 设置的全局属性。($HOME&#x2F;.config&#x2F;spring-boot)</li></ol><br><p><strong>配置文件的优先级如下（后面的覆盖前面的）</strong></p><ol><li>jar包内的<code>application.properties.yml</code></li><li>jar包内的<code>application-&#123;profile&#125;.properties/yml</code></li><li>jar包外的<code>application.properties/yml</code></li><li>jar包外的<code>application-&#123;profile&#125;.properties/yml</code></li><li>如果<code>properties</code>和<code>yml</code>同时存在，<code>properties</code>优先</li></ol><br><h4 id="6-4-单元测试"><a href="#6-4-单元测试" class="headerlink" title="6.4 单元测试"></a>6.4 单元测试</h4><p>SpringBoot提供一系列测试工具及注解方便我们进行测试</p><p>我们只需要导入<code>spring-boot-starter-test</code>即可整合测试</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>spring-boot-starter-test默认提供了下面的库供我们测试使用</p><ul><li>JUnit 5</li><li>Spring Test</li><li>AssertJ</li><li>Hamcrest</li><li>Mockito</li><li>JSONassert</li><li>JsonPath</li></ul><br><p>如果要测试组件，在测试类中通过<code>@Autowired</code>导入需要测试的组件即可</p><br><p><strong>注解</strong></p><p>JUnit 5 的注解相对于 JUnit 4 有所变化</p><p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">JUnit官网</a></p><ul><li>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</li><li>**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍</li><li>**@DisplayName :**为测试类或者测试方法设置展示名称</li><li>**@BeforeEach :**表示在每个单元测试之前执行</li><li>**@AfterEach :**表示在每个单元测试之后执行</li><li>**@BeforeAll :**表示在所有单元测试之前执行</li><li>**@AfterAll :**表示在所有单元测试之后执行</li><li>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</li><li>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li><li>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</li><li>**@ExtendWith :**为测试类或测试方法提供扩展类引用</li></ul><br><p><strong>断言</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr><tr><td>assertArrayEquals</td><td>数组断言</td></tr><tr><td>assertAll</td><td>组合断言</td></tr><tr><td>assertThrows</td><td>异常断言</td></tr><tr><td>assertTimeout</td><td>超时断言</td></tr><tr><td>fail</td><td>快速失败</td></tr></tbody></table><br><p><strong>参数化测试</strong></p><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p><p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><ul><li>@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</li><li>@NullSource: 表示为参数化测试提供一个null的入参</li><li>@EnumSource: 表示为参数化测试提供一个枚举入参</li><li>@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参</li><li>@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流）</li></ul><br> ]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合MyBatis和SpringMVC</title>
    <link href="/2023/11/09/SpringBoot%E6%95%B4%E5%90%88MyBatis%E5%92%8CSpringMVC/"/>
    <url>/2023/11/09/SpringBoot%E6%95%B4%E5%90%88MyBatis%E5%92%8CSpringMVC/</url>
    
    <content type="html"><![CDATA[<p>我们通过一个案例来演示SpringBoot整合MyBatis和SpringMVC<br>该案例通过前后端分离来完成，前端使用vue2加JavaScript实现</p><h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;!-- &lt;input type=&quot;button&quot; value=&quot;获取远程数据&quot; @click=&quot;sendReq()&quot;&gt; --&gt;<br>        &lt;div class=&quot;title&quot;&gt;学生列表&lt;/div&gt;<br>        &lt;div class=&quot;thead&quot;&gt;<br>            &lt;div class=&quot;row bold&quot;&gt;<br>                &lt;div class=&quot;col&quot;&gt;编号&lt;/div&gt;<br>                &lt;div class=&quot;col&quot;&gt;姓名&lt;/div&gt;<br>                &lt;div class=&quot;col&quot;&gt;性别&lt;/div&gt;<br>                &lt;div class=&quot;col&quot;&gt;年龄&lt;/div&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div class=&quot;tbody&quot;&gt;<br>            &lt;div v-if=&quot;students.length &gt; 0&quot;&gt;<br>                &lt;div class=&quot;row&quot; v-for=&quot;stu in students&quot; :key=&quot;stu.id&quot;&gt;<br>                    &lt;div class=&quot;col&quot;&gt;&#123;&#123;stu.id &#125;&#125;&lt;/div&gt;<br>                    &lt;div class=&quot;col&quot;&gt;&#123;&#123;stu.name &#125;&#125;&lt;/div&gt;<br>                    &lt;div class=&quot;col&quot;&gt;&#123;&#123;stu.sex &#125;&#125;&lt;/div&gt;<br>                    &lt;div class=&quot;col&quot;&gt;&#123;&#123;stu.age&#125;&#125;&lt;/div&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import axios from &#x27;../utils/myaxios&#x27;<br>const options = &#123;<br>    mounted: function()&#123;<br>        this.sendReq()<br>    &#125;,<br>    data: function() &#123;<br>        return &#123;<br>            students: []<br>        &#125;;<br>    &#125;,<br>    methods: &#123;<br>        async sendReq() &#123;<br>            const resp = await axios.get(&quot;/api/students&quot;);<br>            console.log(resp.data);<br>            this.students = resp.data.data;<br>        &#125;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br>&lt;style scoped&gt;<br>    div &#123;<br>        font-family: 华文行楷;<br>        font-size: 20px;<br>    &#125;<br><br>    .title &#123;<br>        margin-bottom: 10px;<br>        font-size: 30px;<br>        color: #333;<br>        text-align: center;<br>    &#125;<br><br>    .row &#123;<br>        background-color: #fff;<br>        display: flex;<br>        justify-content: center;<br>    &#125;<br><br>    .col &#123;<br>        border: 1px solid #f0f0f0;<br>        width: 15%;<br>        height: 35px;<br>        text-align: center;<br>        line-height: 35px;<br>    &#125;<br><br>    .bold .col &#123;<br>        background-color: #f1f1f1;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li><p>v-if：条件渲染指令，根据表达式的值来动态控制元素的显示或隐藏， 当表达式中的值为true时，其里面的内容才会展现出来</p></li><li><p>v-else：条件渲染指令，当v-if中表达式的值为false时，其里面的内容才会展现出来，v-else需要和v-if搭配使用，不能单独存在</p></li><li><p>v-for：列表渲染指令，类似于Java中的foreach</p><ul><li>key：key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法；而使用key时，它会基于key的变化重新排列元素顺序，并且会移除&#x2F;销毁key不存在的元素</li></ul></li><li><p>import axios from ‘..&#x2F;utils&#x2F;myaxios’ ：这里的myaxios是自定义的axios</p></li><li><p>mounted：生命周期钩子函数，或自动执行其中的内容</p><ul><li>在Vue实例被挂载到真实的DOM元素后被调用</li><li>仅触发一次</li><li>应用场景：执行异步操作、注册事件监听器、调用第三方库或插件、执行其它初始化操作</li></ul></li><li><p>const resp &#x3D; await axios.get(“&#x2F;api&#x2F;students”)：像后端发送get请求并获取数据</p></li><li><p>this.students &#x3D; resp.data.data：把后端返回的对象中的数据获取到</p><ul><li><p>resp.data.data：由于后端统一了返回格式，resp.data只能获取到Result对象，resp.data.data才能获取到Result中的data数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">//编码：1成功，0和其它数字为失败</span><br>    <span class="hljs-keyword">private</span> String msg; <span class="hljs-comment">//错误信息</span><br>    <span class="hljs-keyword">private</span> T data; <span class="hljs-comment">//数据</span><br>    ......<br></code></pre></td></tr></table></figure></li></ul><br></li></ul><h4 id="自定义axios-js"><a href="#自定义axios-js" class="headerlink" title="自定义axios.js"></a>自定义axios.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">const</span> _axios = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-comment">// baseURL: &#x27;http://localhost:8080&#x27;,</span><br>    <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>&#125;);<br>_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 比如在这里添加统一的 headers</span><br>      config.<span class="hljs-property">headers</span> = &#123;<br>          <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;aaa.bbb.ccc&#x27;</span><br>      &#125;<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br>_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">400</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求参数不正确&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跳转至登录页面&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">401</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;资源未找到&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">404</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> _axios;<br></code></pre></td></tr></table></figure><br><h4 id="自定义axios-js-1"><a href="#自定义axios-js-1" class="headerlink" title="自定义axios.js"></a>自定义axios.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">const</span> _axios = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-comment">// baseURL: &#x27;http://localhost:8080&#x27;,</span><br>    <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>&#125;);<br>_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 比如在这里添加统一的 headers</span><br>      config.<span class="hljs-property">headers</span> = &#123;<br>          <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;aaa.bbb.ccc&#x27;</span><br>      &#125;<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br>_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">400</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求参数不正确&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跳转至登录页面&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">401</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;资源未找到&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">404</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> _axios;<br></code></pre></td></tr></table></figure><br><h4 id="配置文件vue-config-js"><a href="#配置文件vue-config-js" class="headerlink" title="配置文件vue.config.js"></a>配置文件vue.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; defineConfig &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@vue/cli-service&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">7070</span>,<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在这里配置的端口号和统一的URL前缀映射</p><br><hr><h3 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h3><h4 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><p>创建一个简单的表即可，输入一些内容</p><p><img src="/2023/11/09/SpringBoot%E6%95%B4%E5%90%88MyBatis%E5%92%8CSpringMVC/20231109142648.png"></p><br><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>lombok插件中的@Data注解可以帮我们生成set、get、构造方法、toString等方法</p></li><li><p>Java中的类的属性名要和数据库表中的对应，数据库表可以用下划线，Java在编译时会把它用驼峰命名法转换，例如Java中的teacherName对应数据库中的teacher_name</p></li><li><p>Java中的类属性要和数据库表中的字段对应，数据类型也要对应</p><table><thead><tr><th align="center">MySQL字段类型</th><th align="center">Java实体类属性</th></tr></thead><tbody><tr><td align="center">int、tinyint、smallint、mediumint</td><td align="center">int</td></tr><tr><td align="center">bigint</td><td align="center">long</td></tr><tr><td align="center">float</td><td align="center">float</td></tr><tr><td align="center">double</td><td align="center">double</td></tr><tr><td align="center">varchar、char、text</td><td align="center">String</td></tr><tr><td align="center">date</td><td align="center">java.sql.Date</td></tr><tr><td align="center">time、datetime</td><td align="center">java.sqlTimestamp</td></tr><tr><td align="center">bit</td><td align="center">boolean</td></tr></tbody></table></li></ul><br><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StudentService studentService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/api/students&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;Student&gt;&gt; <span class="hljs-title function_">getAllStudent</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Student&gt; students = studentService.getAll();<br>        <span class="hljs-keyword">return</span> Result.success(students);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h4><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    List&lt;Student&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Override</span><br><br>    <span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Student&gt; students = studentMapper.getAll();<br>        <span class="hljs-keyword">return</span> students;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里的接口不是必须的，但是使用接口能够带来挺多方便<ul><li>在尚未实现具体Service逻辑的情况下编写上层代码，如Controller对Service的调用</li><li>Spring默认是基于动态代理实现AOP的，动态代理需要接口</li><li>可以对Service进行多实现</li></ul></li><li>由于该案例只是简单的实现一下SpringBoot整合MyBatis和SpringMVC，并未在业务层做一些逻辑处理，只是简单获取数据并返回</li></ul><br><h4 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br>    List&lt;Student&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Mapper和@Repository都是在持久层的接口上添加注解。</li><li>@Mapper是属于mybatis的注解。在程序中，mybatis需要找到对应的mapper，在编译时候动态生成代理类，实现数据库查询功能</li><li>但是如果只是单独的使用@Mapper注解的话，在idea中进行自动装配的时候，会出现警告，提示找不到这个bean。但是这个不影响程序运行，可以直接忽略也可以添加@Repository注解。这样spring会扫描@Repository并识别这个bean，就不会出现这个警告。</li></ul><br><h4 id="统一返回结果类"><a href="#统一返回结果类" class="headerlink" title="统一返回结果类"></a>统一返回结果类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">//编码：1成功，0和其它数字为失败</span><br>    <span class="hljs-keyword">private</span> String msg; <span class="hljs-comment">//错误信息</span><br>    <span class="hljs-keyword">private</span> T data; <span class="hljs-comment">//数据</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;<br>        Result&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;T&gt;();<br>        result.code = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">(T object)</span> &#123;<br>        Result&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;T&gt;();<br>        result.data = object;<br>        result.code = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.msg = msg;<br>        result.code = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Serializable接口：一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化<ul><li>序列化：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据</li><li>把对象转换为字节序列的过程称为对象的序列化、把字节序列恢复为对象的过程称为对象的反序列化</li></ul></li><li>这里用的是泛型类，即在声明类时使用泛型</li></ul><br><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/vue?serverTimezone=GMT%2B8&amp;useSSL=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;020427&quot;</span><br></code></pre></td></tr></table></figure><ul><li>这里配置了数据源</li></ul><br><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-comment">#druid数据库连接池</span><br><span class="hljs-comment">#type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-comment">#清除缓存</span><br><span class="hljs-attr">spring.thymeleaf.cache</span>=<span class="hljs-string">false</span><br><span class="hljs-comment">#配置mapper</span><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br></code></pre></td></tr></table></figure><ul><li>这里配置了端口号</li><li>mybatis.mapper-locations：用于将配置路径下的*.xml文件加载到mybatis中，这个案例中mapper文件下没有写xml文件，采用的是注解的方法，所以这里可以不用配置</li><li>spring.thymeleaf.cache：Spring Thymeleaf模板引擎的配置属性，用于指定是否启用模板缓存<ul><li>true：Thymeleaf会将解析过的模板缓存起来，以提高性能</li><li>false：每次请求都会重新解析模板</li></ul></li></ul><br><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>启动前端项目<br>在vue项目下用命令行运行启动指令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> serve<br></code></pre></td></tr></table></figure><img src="/2023/11/09/SpringBoot%E6%95%B4%E5%90%88MyBatis%E5%92%8CSpringMVC/20231109154830.png" style="zoom: 67%;"><br><p>后端正常在启动类启动就行了</p><p>最终正常前端从后端获取到了数据并展示在页面中</p><p><img src="/2023/11/09/SpringBoot%E6%95%B4%E5%90%88MyBatis%E5%92%8CSpringMVC/20231109155246.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2基础知识</title>
    <link href="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Vue2基础"><a href="#一-Vue2基础" class="headerlink" title="一. Vue2基础"></a>一. Vue2基础</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p><strong>安装脚手架</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli<br></code></pre></td></tr></table></figure><ul><li>g 参数表示全局安装，这样在任意目录都可以使用 vue 脚本创建项目</li></ul><br><p><strong>创建项目</strong></p><p>使用在需要创建项目的文件夹下打开命令行操作，输入指令回车后会跳转到vue创建项目的网站中去</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vue ui</span><br></code></pre></td></tr></table></figure><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231104152637.png" style="zoom: 50%;"><p>在这里可以进行vue项目的创建</p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231104153005.png" style="zoom:50%;"><br><p><strong>安装 devtools</strong></p><ul><li>devtools 插件网址：<a href="https://devtools.vuejs.org/guide/installation.html">https://devtools.vuejs.org/guide/installation.html</a></li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105145007.png" style="zoom: 50%;"><br><p><strong>运行vue</strong></p><p>在项目文件夹里打开终端输入指令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> serve<br></code></pre></td></tr></table></figure><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105145350.png" style="zoom: 67%;"><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105145500.png" style="zoom:67%;"><br><p><strong>修改端口号</strong></p><ul><li>文档地址：<a href="https://webpack.js.org/configuration/dev-server/#devserverport">DevServer | webpack</a></li><li>在vue.config.js中添加一下代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">7070</span><br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>添加代理</strong></p><p>为了避免前后端服务器联调时， fetch、xhr 请求产生跨域问题，需要配置代理</p><ul><li><p>文档地址：<a href="https://webpack.js.org/configuration/dev-server/#devserverport">DevServer | webpack</a></p></li><li><p>打开 vue.config.js 添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">  <br><span class="hljs-attr">devServer</span>: &#123;<br>   <span class="hljs-attr">port</span>: <span class="hljs-number">7070</span>,<br>   <span class="hljs-attr">proxy</span>: &#123;<br>     <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>       <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>,<br>       <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span><br>     &#125;<br>   &#125;<br> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><br><p><strong>Vue项目结构</strong></p><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105150531.png"></p><ul><li>assets - 静态资源</li><li>components - 可重用组件</li><li>router - 路由</li><li>store - 数据共享</li><li>views - 视图组件</li></ul><p>以后还会添加</p><ul><li>api - 跟后台交互，发送 fetch、xhr 请求，接收响应</li><li>plugins - 插件</li></ul><br><hr><h3 id="2-Vue组件"><a href="#2-Vue组件" class="headerlink" title="2. Vue组件"></a>2. Vue组件</h3><p>Vue 的组件文件以 .vue 结尾，每个组件由三部分组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;&lt;/template&gt;<br><br>&lt;script&gt;&lt;/script&gt;<br><br>&lt;style&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li>template 模板部分，由它生成 html 代码</li><li>script 代码部分，控制模板的数据来源和行为</li><li>style 样式部分，一般不咋关心</li></ul><br><p>先删除App.vue原有代码，来个 Hello, World 例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      msg: &quot;Hello, Vue!&quot;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>解释</p><ul><li>export default 导出组件对象，供 main.js 导入使用</li><li>这个对象有一个 data 方法，返回一个<strong>对象</strong>，给 template 提供数据</li><li><code>&#123;&#123;&#125;&#125;</code> 在 Vue 里称之为插值表达式，用来<strong>绑定</strong> data 方法返回的<strong>对象</strong>属性，<strong>绑定</strong>的含义是数据发生变化时，页面显示会同步变化</li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105152017.png" style="zoom:80%;"><br><h4 id="2-1-文本插值"><a href="#2-1-文本插值" class="headerlink" title="2.1 文本插值"></a>2.1 文本插值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt;<br>        &lt;h1&gt;&#123;&#123; age &gt; 60 ? &#x27;老年&#x27; : &#x27;青年&#x27; &#125;&#125;&lt;/h1&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const options = &#123;<br>    data: function () &#123;<br>        return &#123; name: &#x27;张三&#x27;, age: 70 &#125;;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&#123;&#123;&#125;&#125;</code> 里只能绑定一个属性，绑定多个属性需要用多个 <code>&#123;&#123;&#125;&#125;</code> 分别绑定</li><li>template 内只能有一个根元素</li><li>插值内可以进行简单的表达式计算</li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105154158.png" style="zoom:80%;"><br><h4 id="2-2-属性绑定"><a href="#2-2-属性绑定" class="headerlink" title="2.2 属性绑定"></a>2.2 属性绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;div&gt;&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;/div&gt;<br>        &lt;div&gt;&lt;input type=&quot;date&quot; v-bind:value=&quot;birthday&quot;&gt;&lt;/div&gt;<br>        &lt;div&gt;&lt;input type=&quot;text&quot; :value=&quot;age&quot;&gt;&lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const options = &#123;<br>    data: function () &#123;<br>        return &#123; name: &#x27;王五&#x27;, birthday: &#x27;1995-05-01&#x27;, age: 20 &#125;;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>简写方式：可以省略 v-bind 只保留冒号</li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105154654.png" style="zoom:80%;"><br><h4 id="2-3-事件绑定"><a href="#2-3-事件绑定" class="headerlink" title="2.3 事件绑定"></a>2.3 事件绑定</h4><h4 id><a href="#" class="headerlink" title></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 事件绑定 --&gt;<br>&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;点我执行m1&quot; v-on:click=&quot;m1&quot;&gt;&lt;/div&gt;<br>        &lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;点我执行m2&quot; @click=&quot;m2&quot;&gt;&lt;/div&gt;<br>        &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const options = &#123;<br>    data: function () &#123;<br>        return &#123; count: 0 &#125;;<br>    &#125;,<br>    methods: &#123;<br>        m1() &#123;<br>            this.count ++;<br>            console.log(&quot;m1&quot;)<br>        &#125;,<br>        m2() &#123;<br>            this.count --;<br>            console.log(&quot;m2&quot;)<br>        &#125;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>简写方式：可以把 v-on: 替换为 @</li><li>在 methods 方法中的 this 代表的是 data 函数返回的数据对象</li></ul><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231105213826.png"></p><br><h4 id="2-4-双向绑定"><a href="#2-4-双向绑定" class="headerlink" title="2.4 双向绑定"></a>2.4 双向绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;div&gt;<br>            &lt;label for=&quot;&quot;&gt;请输入姓名&lt;/label&gt;<br>            &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;<br>        &lt;/div&gt;<br>        &lt;div&gt;<br>            &lt;label for=&quot;&quot;&gt;请输入年龄&lt;/label&gt;<br>            &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;<br>        &lt;/div&gt;<br>        &lt;div&gt;<br>            &lt;label for=&quot;&quot;&gt;请选择性别&lt;/label&gt;<br>            男 &lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;<br>            女 &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;<br>        &lt;/div&gt;<br>        &lt;div&gt;<br>            &lt;label for=&quot;&quot;&gt;请选择爱好&lt;/label&gt;<br>            游泳 &lt;input type=&quot;checkbox&quot; value=&quot;游泳&quot; v-model=&quot;fav&quot;&gt;<br>            打球 &lt;input type=&quot;checkbox&quot; value=&quot;打球&quot; v-model=&quot;fav&quot;&gt;<br>            健身 &lt;input type=&quot;checkbox&quot; value=&quot;健身&quot; v-model=&quot;fav&quot;&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const options = &#123;<br>    data: function () &#123;<br>        return &#123; name: &#x27;&#x27;, age: null, sex:&#x27;男&#x27; , fav:[&#x27;打球&#x27;]&#125;;<br>    &#125;,<br>    methods: &#123;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>用 v-model 实现双向绑定，即 <ul><li>JavaScript 数据可以同步到表单标签</li><li>反过来用户在表单标签输入的新值也会同步到 JavaScript 这边</li></ul></li><li>双向绑定只适用于表单这种带【输入】功能的标签，其它标签的数据绑定，单向就足够了</li><li>复选框这种标签，双向绑定的 JavaScript 数据类型一般用数组</li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231106132653.png" style="zoom:67%;"><br><h4 id="2-5-计算属性"><a href="#2-5-计算属性" class="headerlink" title="2.5 计算属性"></a>2.5 计算属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 计算属性 --&gt;<br>&lt;template&gt;<br>    &lt;div&gt;<br>//        &lt;h2&gt;&#123;&#123;fullName()&#125;&#125;&lt;/h2&gt;<br>        &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;<br>        &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;<br>        &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const options = &#123;<br>    data: function () &#123;<br>        return &#123; firstName: &#x27;哥&#x27;, lastName: &#x27;正&#x27; &#125;;<br>    &#125;,<br>    /* methods: &#123;<br>        fullName() &#123;<br>            console.log(&#x27;进入了 fullName&#x27;)<br>            return this.lastName + this.firstName;<br>        &#125;<br>    &#125;,*/<br>    computed: &#123;<br>        fullName() &#123;<br>            console.log(&#x27;进入了 fullName&#x27;)<br>            return this.lastName + this.firstName;<br>        &#125;<br>    &#125;<br>&#125;;<br>export default options;<br></code></pre></td></tr></table></figure><ul><li>普通方法调用必须加 ()，没有缓存功能</li><li>计算属性使用时就把它当属性来用，不加 ()，有缓存功能：<ul><li>一次计算后，会将结果缓存，下次再计算时，只要数据没有变化，不会重新计算，直接返回缓存结果</li></ul></li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20231106134344.png" style="zoom:67%;"><br><hr><h3 id="3-axios"><a href="#3-axios" class="headerlink" title="3. axios"></a>3. axios</h3><p>axios 它的底层是用了 XMLHttpRequest（xhr）方式发送请求和接收响应，xhr 相对于之前讲过的 fetch api 来说，功能更强大，但由于是比较老的 api，不支持 Promise，axios 对 xhr 进行了封装，使之支持 Promise，并提供了对请求、响应的统一拦截功能</p><p>安装</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install axios -S<br></code></pre></td></tr></table></figure><p>导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>axios 默认导出一个对象，这里的 import 导入的就是它默认导出的对象</li></ul><p>方法</p><table><thead><tr><th>请求</th><th>备注</th></tr></thead><tbody><tr><td>axios.get(url[, config])</td><td></td></tr><tr><td>axios.delete(url[, config])</td><td></td></tr><tr><td>axios.head(url[, config])</td><td></td></tr><tr><td>axios.options(url[, config])</td><td></td></tr><tr><td>axios.post(url[, data[, config]])</td><td></td></tr><tr><td>axios.put(url[, data[, config]])</td><td></td></tr><tr><td>axios.patch(url[, data[, config]])</td><td></td></tr></tbody></table><ul><li>config - 选项对象、例如查询参数、请求头…</li><li>data - 请求体数据、最常见的是 json 格式数据</li><li>get、head 请求无法携带请求体，这应当是浏览器的限制所致（xhr、fetch api 均有限制）</li><li>options、delete 请求可以通过 config 中的 data 携带请求体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;input type=&quot;button&quot; value=&quot;获取远程数据&quot; @click=&quot;sendReq()&quot;&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import axios from &#x27;axios&#x27;<br>const options = &#123;<br>    methods: &#123;<br>        async sendReq() &#123;<br>            // 1. 演示 get, post<br>            const resp1 = await axios.get(&#x27;/api/a2&#x27;);<br>            const resp2 = await axios.post(&#x27;/api/a2&#x27;);<br><br>            // 2. 发送请求头<br>            const resp3 = await axios.post(&#x27;/api/a3&#x27;,&#123;&#125;,&#123;<br>                 headers:&#123;<br>                     Authorization:&#x27;abc&#x27;<br>                 &#125;<br>            &#125;);<br><br>            // 3. 发送请求时携带查询参数 ?name=xxx&amp;age=xxx<br>            const name = encodeURIComponent(&#x27;&amp;&amp;&amp;&#x27;);<br>            const age = 18;<br>            const resp4 = await axios.post(`/api/a4?name=$&#123;name&#125;&amp;age=$&#123;age&#125;`);<br><br>            // 不想自己拼串、处理特殊字符、就用下面的办法<br>            const resp5 = await axios.post(&#x27;/api/a4&#x27;, &#123;&#125;, &#123;<br>               params: &#123;<br>                    name:&#x27;&amp;&amp;&amp;&amp;&#x27;,<br>                    age: 20<br>               &#125;<br>            &#125;);<br><br>            // 4. 用请求体发数据，格式为 urlencoded<br>            const params1 = new URLSearchParams();<br>            params1.append(&quot;name&quot;, &quot;张三&quot;);<br>            params1.append(&quot;age&quot;, 24)<br><br>            const resp6 = await axios.post(&#x27;/api/a4&#x27;, params);<br><br>            // 5. 用请求体发数据，格式为 multipart<br>            const params2 = new FormData();<br>            params2.append(&quot;name&quot;, &quot;李四&quot;);<br>            params2.append(&quot;age&quot;, 30);<br>            const resp7 = await axios.post(&#x27;/api/a5&#x27;, params);<br><br>            // 6. 用请求体发数据，格式为 json<br>            const resp8 = await axios.post(&#x27;/api/a5json&#x27;, &#123;<br>                name: &#x27;王五&#x27;,<br>                age: 50<br>            &#125;);<br><br>            console.log(resp);<br>        &#125;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>创建实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _axios = axios.<span class="hljs-title function_">create</span>(config);<br></code></pre></td></tr></table></figure><ul><li>axios 对象可以直接使用，但使用的是默认的设置</li><li>用 axios.create 创建的对象，可以覆盖默认设置，config 见下面说明</li></ul><p><strong>常见的 config 项有</strong></p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>baseURL</td><td>将自动加在 url 前面</td></tr><tr><td>headers</td><td>请求头，类型为简单对象</td></tr><tr><td>params</td><td>跟在 URL 后的请求参数，类型为简单对象或 URLSearchParams</td></tr><tr><td>data</td><td>请求体，类型有简单对象、FormData、URLSearchParams、File 等</td></tr><tr><td>withCredentials</td><td>跨域时是否携带 Cookie 等凭证，默认为 false</td></tr><tr><td>responseType</td><td>响应类型，默认为 json</td></tr></tbody></table><p>例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _axios = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>,<br>    <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-keyword">await</span> _axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/a6set&#x27;</span>)<br><span class="hljs-keyword">await</span> _axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/a6get&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>生产环境希望 xhr 请求不走代理，可以用 baseURL 统一修改</li><li>希望跨域请求携带 cookie，需要配置 withCredentials: true，服务器也要配置 allowCredentials &#x3D; true，否则浏览器获取跨域返回的 cookie 时会报错</li></ul><br><p><strong>响应格式</strong></p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>data</td><td>响应体数据</td></tr><tr><td>status</td><td>状态码</td></tr><tr><td>headers</td><td>响应头</td></tr></tbody></table><ul><li>200 表示响应成功</li><li>400 请求数据不正确 age&#x3D;abc</li><li>401 身份验证没通过</li><li>403 没有权限</li><li>404 资源不存在</li><li>405 不支持请求方式 post</li><li>500 服务器内部错误</li></ul><br><p>请求拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 比如在这里添加统一的 headers</span><br>      config.<span class="hljs-property">headers</span> = &#123;<br>          <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;aaa.bbb.ccc&#x27;</span><br>      &#125;<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>响应拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 2xx 范围内走这里</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 超出 2xx, 比如 4xx, 5xx 走这里</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><ul><li><p>这里的 _axios 是自己创建的axios对象</p></li><li><p>请求拦截器中第一个方法是请求正常的情况下要执行的拦截动作，第二个方法是请求拦截异常的情况下要执行的拦截动作</p></li><li><p>响应拦截器中第一个方法是响应正常的情况下要执行的拦截动作，第二个方法是响应拦截异常的情况下要执行的拦截动作</p></li><li><p>响应时出现的异常可以放在响应拦截器中的第二个方法中去，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">400</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求参数不正确&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跳转至登录页面&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">401</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;资源未找到&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">404</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure></li></ul><br><p>把上面的代码抽取到一个js文件中去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">const</span> _axios = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-comment">// baseURL: &#x27;http://localhost:8080&#x27;,</span><br>    <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>&#125;);<br>_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 比如在这里添加统一的 headers</span><br>      config.<span class="hljs-property">headers</span> = &#123;<br>          <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;aaa.bbb.ccc&#x27;</span><br>      &#125;<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br>_axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">400</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求参数不正确&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跳转至登录页面&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">401</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;资源未找到&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">404</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> _axios;<br></code></pre></td></tr></table></figure><hr><h2 id="二-Vue2进阶"><a href="#二-Vue2进阶" class="headerlink" title="二. Vue2进阶"></a>二. Vue2进阶</h2><h3 id="1-ElementUI"><a href="#1-ElementUI" class="headerlink" title="1. ElementUI"></a>1. ElementUI</h3><p>安装：在vue项目文件下打开命令行输入以下安装代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install element-ui -S<br></code></pre></td></tr></table></figure><p>安装完后在package.json文件中会引入element-ui的依赖<br><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231110144914074.png" style="zoom:67%;"></p><br><p>引入组件</p><p>把下面的代码放入main.js中，Vue.use(Element)要放在new Vue前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Element</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Element</span>)<br></code></pre></td></tr></table></figure><br><h4 id="1-1-表格组件"><a href="#1-1-表格组件" class="headerlink" title="1.1 表格组件"></a>1.1 表格组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;el-table :data=&quot;students&quot;&gt;<br>            &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt;<br>        &lt;/el-table&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import axios from &#x27;../utils/myaxios&#x27;<br>const options = &#123;<br>    async mounted() &#123;<br>        const resp = await axios.get(&#x27;/api/students&#x27;);<br>        this.students = resp.data.data<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            students: []<br>        &#125;<br>    &#125;<br>&#125;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>el-table：表格<ul><li>data：要展示的数据对象</li></ul></li><li>el-table-column：表格中的列<ul><li>label：命名</li><li>prop：数据对象对应的属性</li></ul></li></ul><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231110152129499.png" style="zoom: 50%;"><br><h4 id="1-2-分页组件"><a href="#1-2-分页组件" class="headerlink" title="1.2 分页组件"></a>1.2 分页组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;el-table :data=&quot;students&quot;&gt;<br>            &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt;<br>        &lt;/el-table&gt;<br>        &lt;el-pagination <br>            :total=&quot;total&quot;<br>            :page-size=&quot;queryDto.size&quot;<br>            :current-page=&quot;queryDto.page&quot;<br>            layout=&quot;prev,pager,next,sizes,-&gt;,total&quot;<br>            :page-sizes=&quot;[5,10,15,20]&quot;<br>            @current-change=&quot;currentChange&quot;<br>            @size-change=&quot;sizeChange&quot;<br>        &gt;&lt;/el-pagination&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import axios from &#x27;../utils/myaxios&#x27;<br>const options = &#123;<br>    mounted() &#123;<br>        this.query();<br>    &#125;,<br>    methods: &#123;<br>        currentChange(page) &#123;<br>            this.queryDto.page = page;<br>            this.query();<br>        &#125;,<br>        sizeChange(size) &#123;<br>            this.queryDto.size = size;<br>            this.query();<br>        &#125;,<br>        async query() &#123;<br>            const resp = await axios.get(&#x27;/api/students/q&#x27;, &#123;<br>                params: this.queryDto<br>            &#125;);<br>            this.students = resp.data.data.list;<br>            this.total = resp.data.data.total;<br>        &#125;<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            students: [],<br>            queryDto: &#123;<br>                page: 1,<br>                size: 5<br>            &#125;,<br>            total: 0<br>        &#125;<br>    &#125;<br>&#125;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><p>el-pagination：element-ui分页组件</p><ul><li>有 : 和 没有 : 的区别，有:表示该属性的值会去data中去查找，没有则是给定固定值</li><li>total： 总数量</li><li>page-size：每页条目个数，可以自定义<ul><li>:page-sizes&#x3D;”[5,10,15,20]” ：自定义每页条目数</li></ul></li><li>layout：组件布局，子组件名用逗号分隔（决定页面显示哪些组件）sizes<code>, </code>prev<code>, </code>pager<code>, </code>next<code>, </code>jumper<code>, </code>-&gt;<code>, </code>total<code>, </code>slot</li><li>@current-change：current- page改变时会触发，这里通过调用自定义函数currentChange来改变data中的page，来实现数据的双向绑定</li><li>@size-change：page-size改变时会触发，这里通过调用自定义函数sizeChange来改变data中的size，来实现数据的双向绑定</li></ul></li><li><p>query()函数：把向前端的请求封装成方法，方便调用。刚开始加载页面时会调用（钩子函数中），页数改变时会调用（currentChange函数中），每页条目个数改变时会调用（sizeChange函数中）</p></li><li><p>this.students &#x3D; resp.data.data.list和this.total &#x3D; resp.data.data.total     因为后端返回的数据中的data是一个map集合</p></li></ul><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231110223807689.png"></p><br><h4 id="1-3-分页搜索"><a href="#1-3-分页搜索" class="headerlink" title="1.3 分页搜索"></a>1.3 分页搜索</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;!-- 输入框，用于输入姓名 --&gt;<br>        &lt;el-input placeholder=&quot;请输入姓名&quot; size=&quot;mini&quot; v-model=&quot;queryDto.name&quot;&gt;&lt;/el-input&gt;<br>        <br>        &lt;!-- 下拉选择框，用于选择性别 --&gt;<br>        &lt;el-select placeholder=&quot;请选择性别&quot; size=&quot;mini&quot; v-model=&quot;queryDto.sex&quot;&gt;<br>            &lt;el-option value=&quot;&quot; label=&quot;无限制&quot;&gt;&lt;/el-option&gt;<br>            &lt;el-option value=&quot;男&quot;&gt;&lt;/el-option&gt;<br>            &lt;el-option value=&quot;女&quot;&gt;&lt;/el-option&gt;<br>        &lt;/el-select&gt;<br>        <br>        &lt;!-- 下拉选择框，用于选择年龄范围 --&gt;<br>        &lt;el-select placeholder=&quot;请选择年龄&quot; size=&quot;mini&quot; v-model=&quot;queryDto.age&quot;&gt;<br>            &lt;el-option value=&quot;&quot; label=&quot;无限制&quot;&gt;&lt;/el-option&gt;<br>            &lt;el-option value=&quot;0,20&quot; label=&quot;0到20&quot;&gt;&lt;/el-option&gt;<br>            &lt;el-option value=&quot;21,40&quot; label=&quot;21到40&quot;&gt;&lt;/el-option&gt;<br>            &lt;el-option value=&quot;41,60&quot; label=&quot;41到60&quot;&gt;&lt;/el-option&gt;<br>            &lt;el-option value=&quot;61,200&quot; label=&quot;61岁以上&quot;&gt;&lt;/el-option&gt;<br>        &lt;/el-select&gt;<br>        <br>        &lt;!-- 按钮，点击后进行搜索 --&gt;<br>        &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;search()&quot;&gt;搜索&lt;/el-button&gt;<br>        <br>        &lt;!-- 表格，用于显示学生数据 --&gt;<br>        &lt;el-table :data=&quot;students&quot;&gt;<br>            &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt;<br>        &lt;/el-table&gt;<br>        <br>        &lt;!-- 分页器，用于切换页面和调整每页显示的数量 --&gt;<br>        &lt;el-pagination <br>            :total=&quot;total&quot;<br>            :page-size=&quot;queryDto.size&quot;<br>            :current-page=&quot;queryDto.page&quot;<br>            layout=&quot;prev,pager,next,sizes,-&gt;,total&quot;<br>            :page-sizes=&quot;[5,10,15,20]&quot;<br>            @current-change=&quot;currentChange&quot;<br>            @size-change=&quot;sizeChange&quot;<br>        &gt;&lt;/el-pagination&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import axios from &#x27;../utils/myaxios&#x27;<br>const options = &#123;<br>    // 组件挂载后立即执行查询<br>    mounted() &#123;<br>        this.query();<br>    &#125;,<br>    methods: &#123;<br>        // 搜索方法，执行查询<br>        search() &#123;<br>            this.query();<br>        &#125;,<br>        // 当前页改变时的处理方法<br>        currentChange(page) &#123;<br>            this.queryDto.page = page;<br>            this.query();<br>        &#125;,<br>        // 每页显示数量改变时的处理方法<br>        sizeChange(size) &#123;<br>            this.queryDto.size = size;<br>            this.query();<br>        &#125;,<br>        // 查询方法，从后端获取数据<br>        async query() &#123;<br>            const resp = await axios.get(&#x27;/api/students/q&#x27;, &#123;<br>                params: this.queryDto<br>            &#125;);<br>            this.students = resp.data.data.list;<br>            this.total = resp.data.data.total;<br>        &#125;<br>    &#125;,<br>    // 组件的初始数据<br>    data() &#123;<br>        return &#123;<br>            students: [], // 学生数据<br>            queryDto: &#123; // 查询参数<br>                name: &#x27;&#x27;,<br>                sex: &#x27;&#x27;,<br>                age: &#x27;&#x27;,<br>                page: 1,<br>                size: 5<br>            &#125;,<br>            total: 0 // 总数<br>        &#125;<br>    &#125;<br>&#125;<br>export default options;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>/* 设置输入框和选择框的宽度和边距 */<br>.el-input--mini,<br>.el-select--mini &#123;<br>    width: 193px;<br>    margin: 10px 10px 0 0;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li>el-option中的value是传给后端的值，label是显示在前端页面的值，如果没有添加label属性则把value显示在前端页面</li><li>输入框和选择框都可以通过v-model实现数据的双向绑定</li></ul><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231112203941703.png"></p><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231112204017960.png"></p><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231112204043990.png"></p><br><h4 id="1-4-级联选择器"><a href="#1-4-级联选择器" class="headerlink" title="1.4 级联选择器"></a>1.4 级联选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;!-- el-cascader 组件用于显示级联选择器 --&gt;<br>    &lt;el-cascader :options=&quot;ops&quot; clearable&gt;&lt;/el-cascader&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const options = &#123;<br>    data() &#123;<br>        return &#123;<br>            // ops 是级联选择器的选项数据<br>            ops:[<br>                // 第一级选项：菜品<br>                &#123;value:100 ,label:&#x27;菜品&#x27; ,children:[<br>                    // 第二级选项：湘菜<br>                    &#123;value:110, label:&#x27;湘菜&#x27;, children:[<br>                        // 第三级选项：剁椒鱼头<br>                        &#123;value:111, label:&#x27;剁椒鱼头&#x27;&#125;,<br>                        // 第三级选项：辣椒炒肉<br>                        &#123;value:112, label:&#x27;辣椒炒肉&#x27;&#125;<br>                    ]&#125;,<br>                    // 第二级选项：川菜<br>                    &#123;value:120, label:&#x27;川菜&#x27;, children:[<br>                        // 第三级选项：红烧兔头<br>                        &#123;value:121, label:&#x27;红烧兔头&#x27;&#125;,<br>                        // 第三级选项：宫保鸡丁<br>                        &#123;value:122, label:&#x27;宫保鸡丁&#x27;&#125;<br>                    ]&#125;,<br>                    // 第二级选项：粤菜<br>                    &#123;value:130, label:&#x27;粤菜&#x27;, children:[<br>                        // 第三级选项：白切鸡<br>                        &#123;value:131, label:&#x27;白切鸡&#x27;&#125;,<br>                        // 第三级选项：蜜汁叉烧<br>                        &#123;value:132, label:&#x27;蜜汁叉烧&#x27;&#125;<br>                    ]&#125;<br>                ]&#125;,<br>                // 第一级选项：饮品<br>                &#123;value:200 ,label:&#x27;饮品&#x27; ,children:[<br>                    // 第二级选项：饮料<br>                    &#123;value:210, label:&#x27;饮料&#x27;, children:[<br>                        // 第三级选项：王老吉<br>                        &#123;value:211, label:&#x27;王老吉&#x27;&#125;,<br>                        // 第三级选项：可乐<br>                        &#123;value:212, label:&#x27;可乐&#x27;&#125;,<br>                        // 第三级选项：雪碧<br>                        &#123;value:213, label:&#x27;雪碧&#x27;&#125;<br>                    ]&#125;,<br>                    // 第二级选项：啤酒<br>                    &#123;value:220, label:&#x27;啤酒&#x27;, children:[<br>                        // 第三级选项：雪花<br>                        &#123;value:221, label:&#x27;雪花&#x27;&#125;,<br>                        // 第三级选项：百威<br>                        &#123;value:222, label:&#x27;百威&#x27;&#125;<br>                    ]&#125;,<br>                    // 第二级选项：白酒<br>                    &#123;value:230, label:&#x27;白酒&#x27;, children:[<br>                        // 第三级选项：茅台<br>                        &#123;value:231, label:&#x27;茅台&#x27;&#125;,<br>                        // 第三级选项：江小白<br>                        &#123;value:232, label:&#x27;江小白&#x27;&#125;<br>                    ]&#125;<br>                ]&#125;,<br>            ]<br>        &#125;<br>    &#125;<br>&#125;;<br>export default options;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="/2023/11/04/Vue2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231112212003863.png"></p><br>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2023/11/01/JS/"/>
    <url>/2023/11/01/JS/</url>
    
    <content type="html"><![CDATA[<p>Javascript是一种脚本语言，可以用来更改页面内容，控制多媒体，制作图像、动画等等</p><p>该笔记基于b站视频完成<a href="https://www.bilibili.com/video/BV1Tt4y1772f/?share_source=copy_web&vd_source=db8e7458ec195ac74979ce5478cbc624">Java开发所需的前端技术教学</a></p><h3 id="1-js入门案例"><a href="#1-js入门案例" class="headerlink" title="1. js入门案例"></a>1. js入门案例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>js入门<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>);</span><br><span class="language-javascript">        a.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;3333333&quot;</span>;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231101150137.png" style="zoom: 50%;"><p>document.getElementById()根据元素id获取元素对象</p><br><p><strong>js文件的引用</strong></p><img src="/2023/11/01/JS/20231101150530.png" style="zoom: 67%;"><p>1.js文件的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>);<br>a.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;44444&quot;</span>;<br></code></pre></td></tr></table></figure><br><hr><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p><strong>let</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> 变量名 = 值;<br></code></pre></td></tr></table></figure><ul><li>let声明的变量可以多次赋值</li></ul><br><p><strong>const</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> 变量名 = 值;<br></code></pre></td></tr></table></figure><ul><li>const修饰的为常量，只能赋值一次，不能再次赋值，但是值的内容可以改</li></ul><p><img src="/2023/11/01/JS/20231101153056.png"></p><br><p><strong>var</strong></p><p>var声明的变量是可以多次赋值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;<br>a = <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure><br><hr><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><h4 id="3-1-undefined和null"><a href="#3-1-undefined和null" class="headerlink" title="3.1 undefined和null"></a>3.1 undefined和null</h4><ul><li>执行表达式或函数，没有返回结果，出现undefined</li><li>访问数字不存在的元素，访问对象不存在的属性，出现undefined</li><li>定义变量没有初始化，出现undefined</li></ul><p>二者共同点</p><ul><li>都没有属性、方法</li><li>Nullish</li></ul><p>二者区别</p><ul><li>undefined由js产生</li><li>null由程序员提供</li></ul><img src="/2023/11/01/JS/20231101154218.png" style="zoom:67%;"><br><h4 id="3-2-string"><a href="#3-2-string" class="headerlink" title="3.2 string"></a>3.2 string</h4><p>在JavaScript中可以用单引号、双引号、反引号定义字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;spring&#x27;</span>;<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;spring&quot;</span>;<br><span class="hljs-keyword">let</span> s3 = <span class="hljs-string">`spring`</span>;<br></code></pre></td></tr></table></figure><br>模板字符串（Template strings）<p>需求：拼接url的请求参数，如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">/test?<span class="hljs-attribute">name</span>=zheng&amp;age=18<br>/test?<span class="hljs-attribute">name</span>=li&amp;age=20<br></code></pre></td></tr></table></figure><p>传统方法拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = ; <span class="hljs-comment">// zheng li ...</span><br><span class="hljs-keyword">let</span> age = ; <span class="hljs-comment">// 18 20 ...</span><br><span class="hljs-keyword">let</span> uri = <span class="hljs-string">&quot;/test?name=&quot;</span> + name + <span class="hljs-string">&quot;&amp;age=&quot;</span> + age;<br></code></pre></td></tr></table></figure><p>模板字符串方式，要用反引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = ; <span class="hljs-comment">// zheng li ...</span><br><span class="hljs-keyword">let</span> age = ; <span class="hljs-comment">// 18 20 ...</span><br><span class="hljs-keyword">let</span> uri = <span class="hljs-string">`/test?name=<span class="hljs-subst">$&#123;name&#125;</span>&amp;age=<span class="hljs-subst">$&#123;age&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231101160325.png" style="zoom:80%;"><br><h4 id="3-3-number和bigint"><a href="#3-3-number和bigint" class="headerlink" title="3.3 number和bigint"></a>3.3 number和bigint</h4><p>number 类型标识的是双精度浮动小数，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10</span> / <span class="hljs-number">3</span>;   <span class="hljs-comment">// 结果 3.3333333333333335</span><br></code></pre></td></tr></table></figure><p>既然是浮点小数，那么可以除零</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10</span> / <span class="hljs-number">0</span>;  <span class="hljs-comment">// 结果 Infinity 正无穷大</span><br>-<span class="hljs-number">10</span> / <span class="hljs-number">0</span>;  <span class="hljs-comment">// 结果 -Infinity 负无穷大</span><br></code></pre></td></tr></table></figure><p>浮点小数都有运算精度问题，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2.0</span> - <span class="hljs-number">1.1</span>; <span class="hljs-comment">// 结果 0.8999999999999999</span><br></code></pre></td></tr></table></figure><p>字符串转数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">// 结果是数字 10 </span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10.5&quot;</span>);<span class="hljs-comment">// 结果是数字 10, 去除了小数部分</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>) / <span class="hljs-number">3</span>; <span class="hljs-comment">// 结果仍视为 number 浮点数, 因此结果为 3.3333333333333335</span><br><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">// 转换失败，结果是特殊值 NaN (Not a Number)</span><br></code></pre></td></tr></table></figure><p>要表示真正的整数，需要用 bigint，数字的结尾用 n 表示它是一个 bigint 类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10n</span> / <span class="hljs-number">3n</span>;<span class="hljs-comment">// 结果 3n, 按整数除法处理</span><br></code></pre></td></tr></table></figure><br><h4 id="3-4-boolean"><a href="#3-4-boolean" class="headerlink" title="3.4 boolean"></a>3.4 boolean</h4><ul><li>Truthy</li><li>Falsy</li></ul><p>在 js 中，并不是 boolean 才能用于条件判断，你可以在 if 语句中使用【数字】、【字符串】… 作为判断条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b) &#123; <span class="hljs-comment">// true</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102124803.png" style="zoom:67%;"><p>这时就有一个规则，当需要条件判断时，这个值被当作 true 还是 false，当作 true 的值归类为 truthy，当作 false 的值归类为 falsy</p><p>下面值都是 falsy</p><ul><li><code>false</code></li><li><code>Nullish (null, undefined)</code></li><li><code>0, 0n, NaN</code></li><li><code>&quot;&quot; &#39;&#39; ``</code>  即长度为零的字符串</li></ul><p>剩余的值绝大部分都是 truthy</p><p>有几个容易被当作 falsy 实际是 truthy 的</p><ul><li><code>&quot;false&quot;, &quot;0&quot;</code> 即字符串的 false 和 字符串的零</li><li><code>[]</code> 空数组</li><li><code>&#123;&#125;</code> 空对象</li></ul><br><hr><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><h4 id="4-1-定义函数"><a href="#4-1-定义函数" class="headerlink" title="4.1 定义函数"></a>4.1 定义函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> 函数名(参数) &#123;<br>    <span class="hljs-comment">// 函数体</span><br>    <span class="hljs-keyword">return</span> 结果;<br>&#125;<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">函数名(实参);<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// 返回 3</span><br></code></pre></td></tr></table></figure><p>js 中的函数调用特点：对参数的<strong>类型</strong>和<strong>个数</strong>都没有限制，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// 返回 ab</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);   <span class="hljs-comment">// 返回 9, 第三个参数没有被用到, 不会报错</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 返回 NaN, 这时 b 没有定义是 undefined, undefined 做数学运算结果就是 NaN</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/01/JS/20231102125835.png"></p><br><h4 id="4-2-默认参数"><a href="#4-2-默认参数" class="headerlink" title="4.2 默认参数"></a>4.2 默认参数</h4><p>java 中（spring）要实现默认参数的效果得这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/page&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">page</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(defaultValue=&quot;1&quot;)</span> <span class="hljs-type">int</span> page, </span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(defaultValue=&quot;10&quot;)</span> <span class="hljs-type">int</span> size</span><br><span class="hljs-params">    )</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pagination</span>(<span class="hljs-params">page = <span class="hljs-number">1</span>, size = <span class="hljs-number">10</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(page, size);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 两个参数都默认</span><br><span class="hljs-title function_">pagination</span>();<br><span class="hljs-comment">// 第一个参数默认，第二个参数自己设置</span><br><span class="hljs-title function_">pagination</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">100</span>);<br><span class="hljs-comment">// 第一个参数自己设置，第二个参数默认</span><br><span class="hljs-title function_">pagination</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// 两个参数的自己设置</span><br><span class="hljs-title function_">pagination</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102130659.png" style="zoom:80%;"><br><h4 id="4-3-匿名函数"><a href="#4-3-匿名函数" class="headerlink" title="4.3 匿名函数"></a>4.3 匿名函数</h4><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">参数</span>) &#123;<br>    <span class="hljs-comment">// 函数体</span><br>    <span class="hljs-keyword">return</span> 结果;<br>&#125;)<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用场景——定义完毕立即调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102152417.png" style="zoom:67%;"><p>使用场景——作为其它对象的方法</p><p>页面元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p id = <span class="hljs-string">&quot;p1&quot;</span>&gt;点我啊&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>该元素有一个onclick方法，鼠标点击后会调用该方法，onclick方法初始化为null，需要赋值后才能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>).<span class="hljs-property">onclick</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;鼠标被单击了----&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102153423.png" style="zoom:67%;"><br><h4 id="4-4-箭头函数"><a href="#4-4-箭头函数" class="headerlink" title="4.4 箭头函数"></a>4.4 箭头函数</h4><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(参数) =&gt; &#123;<br>    <span class="hljs-comment">// 函数体</span><br>    <span class="hljs-keyword">return</span> 结果;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果没有参数，()要保留&#96;&#96;</li><li>如果只有一个参数，()可以省略</li><li>如果函数体内只有一个一行代码，{}可以省略</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;单击&quot;</span>);<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102154038.png" style="zoom:67%;"><br><h4 id="4-5-函数是对象"><a href="#4-5-函数是对象" class="headerlink" title="4.5 函数是对象"></a>4.5 函数是对象</h4><p>以下形式在 js 中非常常见！</p><ol><li>可以参与赋值，例，具名函数也能参与赋值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;函数是对象&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>).<span class="hljs-property">onclick</span> = abc;<br></code></pre></td></tr></table></figure><ol start="2"><li>有属性、有方法，执行 <code>console.dir(abc)</code>，输出结果如下</li></ol><img src="/2023/11/01/JS/20231102154731.png" style="zoom:67%;"><ul><li><p>其中带有 f 标记的是方法，不带的是属性</p></li><li><p>带有 ➡ 符号的可以继续展开，限于篇幅省略了</p></li><li><p>带有 <code>[[ ]]</code> 的是内置属性，不能访问，只能查看</p></li><li><p>相对重要的是 <code>[[Prototype]]</code> 和 <code>[[Scopes]]</code></p></li></ul><ol start="3"><li>可以作为方法参数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">fn</span>) &#123;          <span class="hljs-comment">// fn 将来可以是一个函数对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<br>    <span class="hljs-title function_">fn</span>();                 <span class="hljs-comment">// 调用函数对象</span><br>&#125;<br><br><span class="hljs-title function_">b</span>(a)<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102205224.png" style="zoom:67%;"><ol start="4"><li>可以作为方法返回值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">d</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;d&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-title function_">c</span>()()<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102205343.png" style="zoom:67%;"><br><h4 id="4-6-函数的作用域"><a href="#4-6-函数的作用域" class="headerlink" title="4.6 函数的作用域"></a>4.6 函数的作用域</h4><p>看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> z = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 看这里</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);<br>    &#125;<br>    <span class="hljs-title function_">b</span>();<br>&#125;<br><span class="hljs-title function_">a</span>();<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231102205917.png" style="zoom:67%;"><img src="/2023/11/01/JS/20231102205955.png" style="zoom:67%;"><ul><li>以函数为分界线划定作用域，所有函数之外是全局作用域</li><li>查找变量时，由内向外查找<ul><li>在内层作用域找到变量，就会停止查找，不会再找外层</li><li>所有作用域都找不到变量，报错</li></ul></li><li>作用域本质上是函数对象的属性，可以通过 console.dir 来查看调试</li></ul><br><h4 id="4-7-闭包"><a href="#4-7-闭包" class="headerlink" title="4.7 闭包"></a>4.7 闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x,y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-title function_">a</span>()();  <span class="hljs-comment">// 在外面执行了 b</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103144345.png" style="zoom:67%;"><ul><li>函数定义时，它的作用域就已经确定好了，因此无论函数将来去哪里了，它都能从自己的作用域中找到当时的变量</li><li>闭包就是指<font color="red">函数能够访问自己作用域中的变量</font></li></ul><br><h4 id="4-8-var与let的区别"><a href="#4-8-var与let的区别" class="headerlink" title="4.8 var与let的区别"></a>4.8 var与let的区别</h4><p>如果函数外层引用的是let变量，那么外层普通的{}也会作为域边界，最外层的let也占一个script作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x,y);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103150435.png" style="zoom: 67%;"><br><p>如果函数外层引用的是 var 变量，外层普通的 {} 不会视为边界</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x,y);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103150522.png" style="zoom:67%;"><br><p>如果 var 变量出现了重名，则他俩会被视为同一作用域中的同一个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> e = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> e = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<span class="hljs-comment">// 打印 20</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<span class="hljs-comment">// 因为是同一个变量，还是打印 20</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103150703.png" style="zoom:67%;"><p>&lt;&gt;br&#x2F;&gt;</p><p>如果是 let，则视为两个作用域中的两个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> e = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> e = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<span class="hljs-comment">// 打印 20</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<span class="hljs-comment">// 打印 10</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103150729.png" style="zoom:67%;"><br><p>要想里面的 e 和外面的 e 能区分开来，最简单的办法是改成 let，或者用函数来界定作用域范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> e = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> e = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;<br>    <span class="hljs-title function_">b</span>();<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br></code></pre></td></tr></table></figure><br><hr><h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><h4 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建数组</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 获取数组元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-comment">// 修改数组元素</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 获取数组长度</span><br>arr.<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// 变量数据元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103151922.png" style="zoom:67%;"><br><h4 id="5-2-API"><a href="#5-2-API" class="headerlink" title="5.2 API"></a>5.2 API</h4><ul><li>push、shift、splice</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; <br><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 向数组尾部(右侧)添加元素, 结果 [1,2,3,4]</span><br>arr.<span class="hljs-title function_">shift</span>();<span class="hljs-comment">// 从数组头部(左侧)移除元素, 结果 [2,3,4]</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">// 删除【参数1】索引位置的【参数2】个元素，结果 [2,4]</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103152343.png" style="zoom:80%;"><br><ul><li>join</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>];<br><br>arr.<span class="hljs-title function_">join</span>(); <span class="hljs-comment">// 默认使用【,】作为连接符，结果 &#x27;a,b,c,d&#x27;</span><br>arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// 结果 &#x27;abcd&#x27;</span><br>arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-comment">// 结果 &#x27;a-b-c-d&#x27;</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103152546.png" style="zoom: 80%;"><br><ul><li>map、filter、forEach</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">i</span>) &#123;   <span class="hljs-comment">// 代表的新旧元素之间的变换规则</span><br>    <span class="hljs-keyword">return</span> i * <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-comment">// arr.map(a) // 具名函数，结果 [10,20,30,60]</span><br><br><span class="hljs-comment">// arr.map( (i) =&gt; &#123;return i * 10&#125; ); // 箭头函数</span><br>arr.<span class="hljs-title function_">map</span>( <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i * <span class="hljs-number">10</span> ); <span class="hljs-comment">// 箭头函数</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/01/JS/20231103152952.png"></p><br><ul><li>传给 map 的函数，参数代表旧元素，返回值代表新元素</li></ul><p>map 的内部实现（伪代码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-comment">// 参数是一个函数</span><br>    <span class="hljs-keyword">let</span> narr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> o = arr[i]; <span class="hljs-comment">// 旧元素</span><br>        <span class="hljs-keyword">let</span> n = <span class="hljs-title function_">a</span>(o);   <span class="hljs-comment">// 新元素</span><br>        narr.<span class="hljs-title function_">push</span>(n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> narr;<br>&#125; <br></code></pre></td></tr></table></figure><p>filter 例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br>arr.<span class="hljs-title function_">filter</span>( <span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// 结果 [1,3]</span><br></code></pre></td></tr></table></figure><ul><li>传给 filter 的函数，参数代表旧元素，返回 true 表示要留下的元素</li></ul><p>forEach 例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br><br><span class="hljs-comment">/*for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="hljs-comment">    console.log(arr[i]);</span><br><span class="hljs-comment">&#125;*/</span><br><br>arr.<span class="hljs-title function_">forEach</span>( <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i) );<br></code></pre></td></tr></table></figure><p>两个称呼</p><ul><li>高阶函数，map，filter，forEach</li><li>回调函数，例如作为参数传入的函数</li></ul><br><hr><h3 id="6-Object"><a href="#6-Object" class="headerlink" title="6. Object"></a>6. Object</h3><h4 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    属性名: 值,<br>    方法名: 函数,<br>    get 属性名() &#123;&#125;,<br>    set 属性名(新值) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>例1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小明&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>,<br>    <span class="hljs-attr">study</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;爱学习&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103153543.png" style="zoom: 80%;"><br><p>例2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;小红&quot;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> study = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;小红爱学习&quot;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> stu = &#123;name, age, study&#125;;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103153759.png" style="zoom:80%;"><br><p>例3：<font color="red">(重点)</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小刚&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;爱学习&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种定义对象方法的方式只限于对象内部</li></ul><img src="/2023/11/01/JS/20231103154051.png" style="zoom:80%;"><br><h4 id="6-2-get-和set-方法"><a href="#6-2-get-和set-方法" class="headerlink" title="6.2 get()和set()方法"></a>6.2 get()和set()方法</h4><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    _name : <span class="hljs-literal">null</span>, <span class="hljs-comment">// 类似于java中的私有属性</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123; <span class="hljs-comment">// 定义get方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入了get&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;<br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">name</span>) &#123; <span class="hljs-comment">// 定义set方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入了set&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 赋值操作会调用set方法</span><br>stu.<span class="hljs-property">name</span>=<span class="hljs-string">&quot;小白&quot;</span>;<br><br><span class="hljs-comment">// 调用操作会调用get方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103155028.png" style="zoom: 80%;"><ul><li>JavaScript中是没有私有属性这种概念的，在属性前加 ‘_’ 是一种习惯上的约定</li></ul><br><h4 id="6-3-属性增删"><a href="#6-3-属性增删" class="headerlink" title="6.3 属性增删"></a>6.3 属性增删</h4><p>对比一下 Java 中的 Object</p><ul><li>Java 的 Object 是以类作为模板来创建，对象不能脱离类模板的范围，一个对象的属性、能用的方法都是确定好的</li><li>JS 的对象，不需要什么模板，它的属性和方法可以随时加减</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>&#125;;<br>stu.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-comment">// 添加属性</span><br><span class="hljs-keyword">delete</span> stu.<span class="hljs-property">age</span>;<span class="hljs-comment">// 删除属性</span><br><br>stu.<span class="hljs-property">study</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 添加方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;在学习&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103155830.png" style="zoom: 80%;"><br><p>添加 get，set，需要借助 Object.definePropery</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<span class="hljs-attr">_name</span>:<span class="hljs-literal">null</span>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(stu, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>参数1：目标对象</li><li>参数2：属性名</li><li>参数3：get，set 的定义</li></ul><img src="/2023/11/01/JS/20231103160031.png" style="zoom:80%;"><br><h4 id="6-4-this"><a href="#6-4-this" class="headerlink" title="6.4 this"></a>6.4 this</h4><p>先来对 Java 中的 this 有个理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMethod</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(Student <span class="hljs-built_in">this</span>, String subject)</span> &#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;在学习 &quot;</span> + subject);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>        <br>        <span class="hljs-comment">// 下面的代码，本质上是执行 study(stu, &quot;java&quot;)，因此 this 就是 stu</span><br>        stu.study(<span class="hljs-string">&quot;java&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Java 中的 this 是个隐式参数</li><li>Java 中，我们说 this 代表的就是调用方法的那个对象</li></ul><br><p>js 中的 this 也是隐式参数，但它与函数运行时上下文相关</p><p>例如，一个“落单”的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">study</span>(<span class="hljs-params">subject</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;在学习 &quot;</span> + subject)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">study</span>(<span class="hljs-string">&quot;js&quot;</span>);  <span class="hljs-comment">// 输出 在学习 js</span><br></code></pre></td></tr></table></figure><p>这是因为此时函数执行，全局对象 window 被当作了 this，window 对象的 name 属性是空串</p><img src="/2023/11/01/JS/20231103164554.png" style="zoom:80%;"><br><p>同样的函数，如果作为对象的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小白&quot;</span>,<br>    study<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，会将当前对象作为 this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">stu.<span class="hljs-title function_">study</span>(<span class="hljs-string">&#x27;js&#x27;</span>); <span class="hljs-comment">// 输出 小白在学习 js</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103164840.png" style="zoom: 80%;"><br><p>还可以动态改变 this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小黑&quot;</span>&#125;;<br>study.<span class="hljs-title function_">call</span>(stu, <span class="hljs-string">&quot;js&quot;</span>);<span class="hljs-comment">// 输出 小黑在学习 js</span><br></code></pre></td></tr></table></figure><p>这回 study 执行时，就把 call 的第一个参数 stu 作为 this</p><img src="/2023/11/01/JS/20231103165105.png" style="zoom:80%;"><br><p>一个例外是，在<strong>箭头函数</strong>内出现的 this，以外层 this 理解 </p><p>用匿名函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小花&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>],<br>    <span class="hljs-title function_">play</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;与&quot;</span> + e + <span class="hljs-string">&quot;在玩耍&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br>stu.<span class="hljs-title function_">play</span>()<br></code></pre></td></tr></table></figure><ul><li>this.name 所在的函数是【落单】的函数，因此 this 代表 window</li></ul><p>输出结果为<br><img src="/2023/11/01/JS/20231103172439.png" style="zoom:67%;"></p><br><p>用箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小花&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>],<br>    <span class="hljs-title function_">play</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;与&quot;</span> + e + <span class="hljs-string">&quot;在玩耍&quot;</span>);<br>        &#125;)<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>this.name 所在的函数是箭头函数，因此 this 要看它外层的 play 函数，play 又是属于 stu 的方法，因此 this 代表 stu 对象</li></ul><p>输出结果为<br><img src="/2023/11/01/JS/20231103172557.png" style="zoom: 67%;"></p><br><p>不用箭头函数的做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小花&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>],<br>    <span class="hljs-title function_">play</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> me = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(me.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;与&quot;</span> + e + <span class="hljs-string">&quot;在玩耍&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103172659.png" style="zoom:67%;"><br><h4 id="6-5-原型进程"><a href="#6-5-原型进程" class="headerlink" title="6.5 原型进程"></a>6.5 原型进程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> father = &#123;<br>    <span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;父属性&#x27;</span>,<br>    <span class="hljs-attr">m1</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> son = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(father);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son.<span class="hljs-property">f1</span>);  <span class="hljs-comment">// 打印 父属性</span><br>son.<span class="hljs-title function_">m1</span>();  <span class="hljs-comment">// 打印 父方法</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103200011.png" style="zoom:80%;"><ul><li>father 是父对象，son 去调用 .m1 或 .f1 时，自身对象没有，就到父对象找</li><li>son 自己可以添加自己的属性和方法</li><li>son 里有特殊属性 <code>__proto__</code> 代表它的父对象，js 术语： son 的原型对象</li><li>不同浏览器对打印 son 的 <code>__proto__</code> 属性时显示不同<ul><li>Edge 打印 console.dir(son) 显示 <code>[[Prototype]]</code></li><li>Firefox 打印 console.dir(son) 显示 <code>&lt;prototype&gt;</code></li></ul></li></ul><br><p><strong>基于函数的原型继承</strong></p><p>出于方便的原因，js 又提供了一种基于函数的原型继承</p><blockquote><p><strong>函数职责</strong></p><ol><li><p>负责创建子对象，给子对象提供属性、方法，功能上相当于构造方法</p></li><li><p>函数有个特殊的属性 prototype，它就是函数创建的子对象的父对象</p><p><strong>注意！</strong>名字有差异，这个属性的作用就是为新对象提供原型</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cons</span>(<span class="hljs-params">f2</span>) &#123;<br>    <span class="hljs-comment">// 创建子对象(this), 给子对象提供属性和方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">f2</span> = f2;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">m2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// cons.prototype 就是父对象</span><br>cons.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">f1</span> = <span class="hljs-string">&quot;父属性&quot;</span>;<br>cons.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">m1</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>配合 new 关键字，创建子对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title function_">cons</span>(<span class="hljs-string">&quot;子属性&quot;</span>)<br></code></pre></td></tr></table></figure><p>子对象的 <code>__proto__</code> 就是函数的 <code>prototype</code> 属性</p><img src="/2023/11/01/JS/20231103200447.png" style="zoom:80%;"><br><hr><h3 id="7-JSON"><a href="#7-JSON" class="headerlink" title="7. JSON"></a>7. JSON</h3><p>一个 json 对象可以长这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>一个 js 对象长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JSON和JS的区别</p><ol><li>本质不同<ul><li>json 对象本质上是个字符串，它的职责是作为客户端和服务器之间传递数据的一种格式，它的属性只是样子货</li><li>js 对象是切切实实的对象，可以有属性方法</li></ul></li><li>语法细节不同<ul><li>json 中只能有 null、true|false、数字、字符串（只有双引号）、对象、数组</li><li>json 中不能有除以上的其它 js 对象的特性，如方法等</li><li>json 中的属性必须用双引号引起来</li></ul></li></ol><p>json 字符串与 js 对象的转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json字符串);  <span class="hljs-comment">// 返回js对象</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(js对象);  <span class="hljs-comment">// 返回json字符串</span><br></code></pre></td></tr></table></figure><br><hr><h3 id="8-运算符与表达式"><a href="#8-运算符与表达式" class="headerlink" title="8. 运算符与表达式"></a>8. 运算符与表达式</h3><ul><li><code>+ - * / % ** </code></li><li><code>+= -= *= /= %= **=</code></li><li><code>++ --</code></li><li>位运算、移位运算</li><li><code>== != &gt; &gt;= &lt; &lt;=</code></li><li><code>=== !==</code> </li><li><code>&amp;&amp; || !</code> </li><li><code>?? ?.</code> </li><li><code>...</code> </li><li>解构赋值</li></ul><br><h4 id="8-1"><a href="#8-1" class="headerlink" title="8.1  &#x3D;&#x3D;&#x3D;"></a>8.1  &#x3D;&#x3D;&#x3D;</h4><p>严格相等运算符，用作逻辑判等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span> == <span class="hljs-number">1</span>    <span class="hljs-comment">// 返回 true </span><br><span class="hljs-number">1</span> == <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-comment">// 返回 true，会先将右侧的字符串转为数字，再做比较</span><br><span class="hljs-number">1</span> === <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-comment">// 返回 false，类型不等，直接返回 false</span><br></code></pre></td></tr></table></figure><p>typeof 查看某个值的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span><span class="hljs-comment">// 返回 &#x27;number&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-comment">// 返回 &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103204917.png" style="zoom:80%;"><br><h4 id="8-2"><a href="#8-2" class="headerlink" title="8.2 ||"></a>8.2 ||</h4><p>需求：如果参数 n 没有传递，给它一个【男】</p><p><strong>推荐</strong>做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">n = <span class="hljs-string">&#x27;男&#x27;</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>一些老旧代码中可能的做法（不推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">n</span>) &#123;<br>    n = n || <span class="hljs-string">&#x27;男&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>它的语法是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">值<span class="hljs-number">1</span> || 值<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果值1 是 Truthy，返回值1，如果值1 是 Falsy 返回值 2</p><img src="/2023/11/01/JS/20231103205241.png" style="zoom:80%;"><br><h4 id="8-3-与"><a href="#8-3-与" class="headerlink" title="8.3 ??与?."></a>8.3 ??与?.</h4><p><strong>??</strong> </p><p>需求：如果参数n没有传递<font color="red">或者是nul</font>l，给他一个[男]</p><p>传统办法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span>(n === <span class="hljs-literal">undefined</span> || n === <span class="hljs-literal">null</span>) &#123;<br>        n = <span class="hljs-string">&#x27;男&#x27;</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用??</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">n</span>) &#123;<br>n = n ?? <span class="hljs-string">&#x27;男&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103205850.png" style="zoom:80%;"><br><p><strong>?.</strong></p><p>需求：函数参数是一个对象，可能包含子属性</p><p>例如，参数可能是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu1 = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;北京&#x27;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> stu2 = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;李四&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> stu3 = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;李四&quot;</span>,<br>    <span class="hljs-attr">address</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在要访问子属性（有问题）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">stu</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-property">address</span>.<span class="hljs-property">city</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在希望当某个属性是 nullish 时，短路并返回 undefined，可以用 ?.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">stu</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-property">address</span>?.<span class="hljs-property">city</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用传统办法 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">stu</span>) &#123;<br>    <span class="hljs-keyword">if</span>(stu.<span class="hljs-property">address</span> === <span class="hljs-literal">undefined</span> || stu.<span class="hljs-property">address</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-property">address</span>.<span class="hljs-property">city</span>)<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103210444.png" style="zoom:80%;"><br><h4 id="8-4-…"><a href="#8-4-…" class="headerlink" title="8.4 …"></a>8.4 …</h4><p>展开运算符</p><p>作用1：打散数组，把元素传递给多个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a,b,c</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c);<br>&#125;<br></code></pre></td></tr></table></figure><p>需求，把数组元素依次传递给函数参数</p><p>传统写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(arr[<span class="hljs-number">0</span>],arr[<span class="hljs-number">1</span>],arr[<span class="hljs-number">2</span>]);<span class="hljs-comment">// 输出 1,2,3</span><br></code></pre></td></tr></table></figure><p>展开运算符写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(...arr);<span class="hljs-comment">// 输出 1,2,3</span><br></code></pre></td></tr></table></figure><ul><li>打散可以理解为【去掉了】数组外侧的中括号，只剩下数组元素</li></ul><img src="/2023/11/01/JS/20231103210859.png" style="zoom:80%;"><br><p>作用2：复制数组或对象</p><p>数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arr2 = [...arr1];<span class="hljs-comment">// 复制数组</span><br></code></pre></td></tr></table></figure><p>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-keyword">let</span> obj2 = &#123;...obj1&#125;;<span class="hljs-comment">// 复制对象</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103215340.png" style="zoom:67%;"><p><strong>注意</strong>：展开运算符复制属于浅拷贝，更深一层的数据采用了引用的形式，例如这里的city就是引用了原来的地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> o1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">address</span>: &#123;<span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;北京&#x27;</span>&#125; &#125;<br><br><span class="hljs-keyword">let</span> o2 = &#123;...o1&#125;;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103215511.png" style="zoom:80%;"><br><p>作用3：合并数组或对象</p><p>合并数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> a2 = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">let</span> b1 = [...a1,...a2];<span class="hljs-comment">// 结果 [1,2,3,4]</span><br><span class="hljs-keyword">let</span> b2 = [...a2,<span class="hljs-number">5</span>,...a1]<span class="hljs-comment">// 结果 [3,4,5,1,2]</span><br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103215720.png" style="zoom:80%;"><p>合并对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> o1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>&#125;;<br><span class="hljs-keyword">let</span> o2 = &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;;<br><span class="hljs-keyword">let</span> o3 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;李四&#x27;</span>&#125;;<br><br><span class="hljs-keyword">let</span> n1 = &#123;...o1, ...o2&#125;;<span class="hljs-comment">// 结果 &#123;name:&#x27;张三&#x27;,age:18&#125;</span><br><br><span class="hljs-keyword">let</span> n2 = &#123;...o1, ...o2, ...o3&#125;; <span class="hljs-comment">// 结果&#123;name:&#x27;李四&#x27;,age:18&#125;</span><br></code></pre></td></tr></table></figure><ul><li>复制对象时出现同名属性，后面的会覆盖前面的</li></ul><img src="/2023/11/01/JS/20231103220144.png" style="zoom:80%;"><br><h4 id="8-5"><a href="#8-5" class="headerlink" title="8.5 []{}"></a>8.5 []{}</h4><p>解构赋值</p><p><strong>[]</strong></p><p>用在声明变量时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">let</span> [a, b, c] = arr;<span class="hljs-comment">// 结果 a=1, b=2, c=3</span><br></code></pre></td></tr></table></figure><p>用在声明参数时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">[a,b,c]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c) <span class="hljs-comment">// 结果 a=1, b=2, c=3</span><br>&#125;<br><br><span class="hljs-title function_">test</span>(arr);<br></code></pre></td></tr></table></figure><br><p><strong>{}</strong></p><p>用在声明变量时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;name,age&#125; = obj;<span class="hljs-comment">// 结果 name=张三, age=18</span><br></code></pre></td></tr></table></figure><p>用在声明参数时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">&#123;name, age&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// 结果 name=张三, age=18</span><br>&#125;<br><br><span class="hljs-title function_">test</span>(obj)<br></code></pre></td></tr></table></figure><br><hr><h3 id="9-控制语句"><a href="#9-控制语句" class="headerlink" title="9. 控制语句"></a>9. 控制语句</h3><ul><li><code>if ... else</code></li><li><code>switch</code></li><li><code>while</code></li><li><code>do ... while</code></li><li><code>for</code> </li><li><code>for ... in</code> </li><li><code>for ... of</code> </li><li><code>try ... catch</code></li></ul><br><h4 id="9-1-for-in"><a href="#9-1-for-in" class="headerlink" title="9.1 for in"></a>9.1 for in</h4><p>主要用来遍历对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> father = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>, <span class="hljs-attr">study</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> n <span class="hljs-keyword">in</span> father) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其中 const n 代表遍历出来的属性名</p></li><li><p>注意1：方法名也能被遍历出来（它其实也算一种特殊属性）</p><img src="/2023/11/01/JS/20231103221046.png" style="zoom: 80%;"></li><li><p>注意2：遍历子对象时，父对象的属性会跟着遍历出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> son = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(father);<br>son.<span class="hljs-property">sex</span> = <span class="hljs-string">&quot;男&quot;</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> n <span class="hljs-keyword">in</span> son) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103221337.png" style="zoom:80%;"></li><li><p>注意3：在 for in 内获取属性值，要使用 [] 语法，而不能用 . 语法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> n <span class="hljs-keyword">in</span> son) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n, son[n]);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103221558.png" style="zoom:80%;"><br><h4 id="9-2-for-of"><a href="#9-2-for-of" class="headerlink" title="9.2 for of"></a>9.2 for of</h4><p>主要用来遍历数组，也可以是Map、Set等可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> a1) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><br><span class="hljs-keyword">let</span> a2 = [<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">22</span>&#125;<br>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> obj <span class="hljs-keyword">of</span> a2) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>, obj.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> &#123;name,age&#125; <span class="hljs-keyword">of</span> a2) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103221953.png" style="zoom:80%;"><br><h4 id="9-3-try-catch"><a href="#9-3-try-catch" class="headerlink" title="9.3 try catch"></a>9.3 try catch</h4><p>对有可能出现异常的代码进行try catch处理，finally中放的代码一定会被执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stu1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>, <span class="hljs-attr">address</span>: &#123;<span class="hljs-attr">city</span>:<span class="hljs-string">&#x27;北京&#x27;</span>&#125;&#125;;<br><span class="hljs-keyword">let</span> stu2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">stu</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-property">address</span>.<span class="hljs-property">city</span>)   <br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出现了异常&#x27;</span>, e.<span class="hljs-property">message</span>)<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/01/JS/20231103222212.png" style="zoom:80%;"><br><hr><h3 id="10-node的安装"><a href="#10-node的安装" class="headerlink" title="10.node的安装"></a>10.node的安装</h3><p><strong>安装 nvm</strong></p><p>nvm 即 (node version manager)，好处是方便切换 node.js 版本</p><p>安装注意事项</p><ol><li>要卸载掉现有的 nodejs</li><li>提示选择 nvm 和 nodejs 目录时，一定要避免目录中出现空格</li><li>选用【以管理员身份运行】cmd 程序来执行 nvm 命令</li><li>首次运行前设置好国内镜像地址</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">nvm node_mirror http:<span class="hljs-regexp">//</span>npm.taobao.org<span class="hljs-regexp">/mirrors/</span>node/<br>nvm npm_mirror https:<span class="hljs-regexp">//</span>npm.taobao.org<span class="hljs-regexp">/mirrors/</span>npm/<br></code></pre></td></tr></table></figure><p>首先查看有哪些可用版本</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">nvm list available<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   CURRENT    </span>|<span class="hljs-string">     LTS      </span>|<span class="hljs-string">  OLD STABLE  </span>|<span class="hljs-string"> OLD UNSTABLE </span>|<br>|<span class="hljs-string">--------------</span>|<span class="hljs-string">--------------</span>|<span class="hljs-string">--------------</span>|<span class="hljs-string">--------------</span>|<br>|<span class="hljs-string">    21.1.0    </span>|<span class="hljs-string">    20.9.0    </span>|<span class="hljs-string">   0.12.18    </span>|<span class="hljs-string">   0.11.16    </span>|<br>|<span class="hljs-string">    21.0.0    </span>|<span class="hljs-string">   18.18.2    </span>|<span class="hljs-string">   0.12.17    </span>|<span class="hljs-string">   0.11.15    </span>|<br>|<span class="hljs-string">    20.8.1    </span>|<span class="hljs-string">   18.18.1    </span>|<span class="hljs-string">   0.12.16    </span>|<span class="hljs-string">   0.11.14    </span>|<br>|<span class="hljs-string">    20.8.0    </span>|<span class="hljs-string">   18.18.0    </span>|<span class="hljs-string">   0.12.15    </span>|<span class="hljs-string">   0.11.13    </span>|<br>|<span class="hljs-string">    20.7.0    </span>|<span class="hljs-string">   18.17.1    </span>|<span class="hljs-string">   0.12.14    </span>|<span class="hljs-string">   0.11.12    </span>|<br>|<span class="hljs-string">    20.6.1    </span>|<span class="hljs-string">   18.17.0    </span>|<span class="hljs-string">   0.12.13    </span>|<span class="hljs-string">   0.11.11    </span>|<br>|<span class="hljs-string">    20.6.0    </span>|<span class="hljs-string">   18.16.1    </span>|<span class="hljs-string">   0.12.12    </span>|<span class="hljs-string">   0.11.10    </span>|<br>|<span class="hljs-string">    20.5.1    </span>|<span class="hljs-string">   18.16.0    </span>|<span class="hljs-string">   0.12.11    </span>|<span class="hljs-string">    0.11.9    </span>|<br>|<span class="hljs-string">    20.5.0    </span>|<span class="hljs-string">   18.15.0    </span>|<span class="hljs-string">   0.12.10    </span>|<span class="hljs-string">    0.11.8    </span>|<br>|<span class="hljs-string">    20.4.0    </span>|<span class="hljs-string">   18.14.2    </span>|<span class="hljs-string">    0.12.9    </span>|<span class="hljs-string">    0.11.7    </span>|<br>|<span class="hljs-string">    20.3.1    </span>|<span class="hljs-string">   18.14.1    </span>|<span class="hljs-string">    0.12.8    </span>|<span class="hljs-string">    0.11.6    </span>|<br>|<span class="hljs-string">    20.3.0    </span>|<span class="hljs-string">   18.14.0    </span>|<span class="hljs-string">    0.12.7    </span>|<span class="hljs-string">    0.11.5    </span>|<br>|<span class="hljs-string">    20.2.0    </span>|<span class="hljs-string">   18.13.0    </span>|<span class="hljs-string">    0.12.6    </span>|<span class="hljs-string">    0.11.4    </span>|<br>|<span class="hljs-string">    20.1.0    </span>|<span class="hljs-string">   18.12.1    </span>|<span class="hljs-string">    0.12.5    </span>|<span class="hljs-string">    0.11.3    </span>|<br>|<span class="hljs-string">    20.0.0    </span>|<span class="hljs-string">   18.12.0    </span>|<span class="hljs-string">    0.12.4    </span>|<span class="hljs-string">    0.11.2    </span>|<br>|<span class="hljs-string">    19.9.0    </span>|<span class="hljs-string">   16.20.2    </span>|<span class="hljs-string">    0.12.3    </span>|<span class="hljs-string">    0.11.1    </span>|<br>|<span class="hljs-string">    19.8.1    </span>|<span class="hljs-string">   16.20.1    </span>|<span class="hljs-string">    0.12.2    </span>|<span class="hljs-string">    0.11.0    </span>|<br>|<span class="hljs-string">    19.8.0    </span>|<span class="hljs-string">   16.20.0    </span>|<span class="hljs-string">    0.12.1    </span>|<span class="hljs-string">    0.9.12    </span>|<br>|<span class="hljs-string">    19.7.0    </span>|<span class="hljs-string">   16.19.1    </span>|<span class="hljs-string">    0.12.0    </span>|<span class="hljs-string">    0.9.11    </span>|<br>|<span class="hljs-string">    19.6.1    </span>|<span class="hljs-string">   16.19.0    </span>|<span class="hljs-string">   0.10.48    </span>|<span class="hljs-string">    0.9.10    </span>|<br></code></pre></td></tr></table></figure><p>建议安装 LTS（长期支持版）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> install <span class="hljs-number">18</span>.<span class="hljs-number">17</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>执行 nvm list 会列出已安装版本</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvm list</span><br></code></pre></td></tr></table></figure><p>切换到 16.16.0</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> use <span class="hljs-number">18</span>.<span class="hljs-number">17</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>安装后 nvm 自己的环境变量会自动添加，但可能需要手工添加 nodejs 的 PATH 环境变量</p><br><p><strong>检查 npm</strong></p><p>npm 是 js 的包管理器，就类似于 java 界的 maven，要确保它使用的是国内镜像</p><p>检查镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">get</span> registry<br></code></pre></td></tr></table></figure><p>如果返回的不是 <code>https://registry.npm.taobao.org/</code>，需要做如下设置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org/</span><br></code></pre></td></tr></table></figure><br><p><strong>搭建前端服务器</strong></p><p>新建一个保存项目的 client 文件夹，进入文件夹执行</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install <span class="hljs-built_in">express</span> --<span class="hljs-built_in">save</span>-dev<br></code></pre></td></tr></table></figure><p>执行上面指令后会生成下面三个文件<br><img src="/2023/11/01/JS/20231104142223.png" style="zoom:67%;"></p><p>修改 package.json 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.18.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>其中 devDependencies 是 npm install –save-dev 添加的</li></ul><p>编写 main.js 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./&#x27;</span>))<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">7070</span>)<br></code></pre></td></tr></table></figure><p>执行 js 代码（运行前端服务器）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">main</span>.js<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream流</title>
    <link href="/2023/10/24/Stream%E6%B5%81/"/>
    <url>/2023/10/24/Stream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站视频完成<a href="https://www.bilibili.com/video/BV1te411w722?vd_source=db8e7458ec195ac74979ce5478cbc624">Java-Stream流从入门到精通</a></p><p><strong>什么是Stream流</strong></p><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象<br>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码<br>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等<br>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果<br></p><br><p><strong>Stream流的作用</strong>：结合了Lambda表达式，简化了集合、数组的操作</p><p><strong>Stream流的使用步骤</strong></p><ol><li>先得到一条Stream流，并把数据放上去</li><li>利用Stream流中的API进行各种操作<ul><li>中间方法：过滤、转换方法调用完毕之后、还可以调用其他方法</li><li>终结方法：统计、打印    最后一步，调用完毕之后，不能再调用其他方法</li></ul></li></ol><br><p><strong>把数据放到Stream流上去</strong></p><table><thead><tr><th align="center">获取方式</th><th align="center">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">单例集合</td><td align="center">default Stream<E> stream()</E></td><td align="left">Collection中的默认方法</td></tr><tr><td align="center">双列集合</td><td align="center">无</td><td align="left">无法直接使用Stream流</td></tr><tr><td align="center">数组</td><td align="center">public static<T> Stream<T> stream (T… values)</T></T></td><td align="left">Arrays工具类中的静态方法</td></tr><tr><td align="center">一堆零散的数据</td><td align="center">public static<T> Stream<T> of (T… values)</T></T></td><td align="left">Stream接口中你的静态方法</td></tr></tbody></table><br><p>单例集合获取Stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用Stream流遍历集合中的元素</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br><br>list.stream().forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><br><p>双列集合获取Stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建双列集合</span><br>HashMap&lt;String, Integer&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">// 添加数据</span><br>hm.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>);<br>hm.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br>hm.put(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>);<br>hm.put(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 第一中获取Stream流方法</span><br>hm.keySet().stream().forEach(s -&gt; System.out.println(s));<br>hm.values().stream().forEach(x -&gt; System.out.println(x));<br><br><span class="hljs-comment">// 第二种</span><br>hm.entrySet().stream().forEach(y -&gt; System.out.println(y));<br></code></pre></td></tr></table></figure><br><p>数组获取Stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>Arrays.stream(arr).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><br><p>一堆零散数据获取Stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前提是这些数据的数据类型相同</span><br>Stream(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)..forEach(s -&gt; System.out.println(s));<br>Stream(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)..forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><br><p><strong>Stream流的中间方法</strong></p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Stream<T>  <font color="red">filter</font>(Predicate&lt;? super T&gt; predicate)</T></td><td align="left">过滤</td></tr><tr><td align="left">Stream<T>  <font color="red">limit</font>(long maxSize)</T></td><td align="left">获取前面几个元素</td></tr><tr><td align="left">Stream<T>  <font color="red">skip</font>(long n)</T></td><td align="left">跳过前面几个元素</td></tr><tr><td align="left">Stream<T>  <font color="red">distinct</font>()</T></td><td align="left">元素去重，依赖于hashCode和equals方法</td></tr><tr><td align="left">static <T> Stream<T> <font color="red">concat</font>(Stream a, Stream b)</T></T></td><td align="left">合并a和b两个流为一个流</td></tr><tr><td align="left">Stream<R>  <font color="red">map</font>(Function&lt;T, R&gt; mapper)</R></td><td align="left">转换流中的数据类型</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程</li><li>修改Stream流中的数据，不会影响原来集合或者数据中的数据</li></ul><br><p>filter、limit、skip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>, <span class="hljs-string">&quot;赵敏&quot;</span>, <span class="hljs-string">&quot;张强&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;张翠山&quot;</span>, <span class="hljs-string">&quot;张良&quot;</span>, <span class="hljs-string">&quot;王二麻子&quot;</span>, <span class="hljs-string">&quot;谢广坤&quot;</span>);<br><br><span class="hljs-comment">// filter 过滤  把张开头的留下，其余的数据过滤</span><br>list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(s -&gt; System.out.println(s));<br><br><span class="hljs-comment">// limit: 获取前面几个元素skip: 跳过前面几个元素</span><br><span class="hljs-comment">// 获取&quot;张强&quot;, &quot;张三丰&quot;, &quot;张翠山&quot;</span><br><span class="hljs-comment">// 实现方法一：先获取前面6个元素，再跳过前面3个元素</span><br>list.stream().limit(<span class="hljs-number">6</span>).skip(<span class="hljs-number">3</span>).forEach(s -&gt; System.out.println(s));<br><span class="hljs-comment">// 实现方法二：先跳过前面3个，在获取前面3个</span><br>list.stream().skip(<span class="hljs-number">3</span>).limit(<span class="hljs-number">3</span>).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><br><p>distinct、concat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// distinct : 元素去重concat : 合并两个流</span><br>ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list1, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>);<br><br><span class="hljs-comment">// 去重输出</span><br>list1.stream().distinct().forEach(s -&gt; System.out.println(s));<br><br><span class="hljs-comment">// 合并两个流</span><br>ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list1, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>);<br>Stream.concat(list1.stream(), list2.stream());<br></code></pre></td></tr></table></figure><br><p>map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// map 转换流中的数据类型</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;张无忌-15&quot;</span>, <span class="hljs-string">&quot;周芷若-18&quot;</span>, <span class="hljs-string">&quot;赵敏-17&quot;</span>, <span class="hljs-string">&quot;张强-31&quot;</span>, <span class="hljs-string">&quot;张三丰-23&quot;</span>, <span class="hljs-string">&quot;张翠山-15&quot;</span>, <span class="hljs-string">&quot;张良-20&quot;</span>, <span class="hljs-string">&quot;王二麻子-25&quot;</span>, <span class="hljs-string">&quot;谢广坤-40&quot;</span>);<br><span class="hljs-comment">// 需求：只获取里面的年龄并进行打印</span><br>list.stream()<br>    .map(s -&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]))<br>    .forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><br><p><strong>Stream流的终结方法</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void forEach(Consumer action)</td><td align="center">遍历</td></tr><tr><td align="center">long count()</td><td align="center">统计</td></tr><tr><td align="center">toArray()</td><td align="center">收集流中的数据，放到数组中</td></tr><tr><td align="center">collect(Collector collector)</td><td align="center">收集流中的数据，放到集合中</td></tr></tbody></table><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>, <span class="hljs-string">&quot;赵敏&quot;</span>, <span class="hljs-string">&quot;张强&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;张翠山&quot;</span>, <span class="hljs-string">&quot;张良&quot;</span>, <span class="hljs-string">&quot;王二麻子&quot;</span>, <span class="hljs-string">&quot;谢广坤&quot;</span>);<br><br><span class="hljs-comment">// 使用forEach遍历集合</span><br>list.stream().forEach(a -&gt; System.out.println(s));<br><br><span class="hljs-comment">// 使用count统计个数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).count();<br>System.out.println(count);<br><br><span class="hljs-comment">// 收集流流中的数据，放到数组中 toArray</span><br>Object[] arr1 = list.stream().toArray();<br><span class="hljs-comment">// 指定数组数据类型</span><br>String[] arr2 = list.stream().toArray(value -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[value]);<br></code></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;张无忌-男-15&quot;</span>, <span class="hljs-string">&quot;周芷若-女-18&quot;</span>, <span class="hljs-string">&quot;赵敏-女--17&quot;</span>, <span class="hljs-string">&quot;张强-男-31&quot;</span>, <span class="hljs-string">&quot;张三丰-男-23&quot;</span>, <span class="hljs-string">&quot;张翠山-女-15&quot;</span>, <span class="hljs-string">&quot;张良-男-20&quot;</span>, <span class="hljs-string">&quot;王二麻子-男-25&quot;</span>, <span class="hljs-string">&quot;谢广坤-男-40&quot;</span>);<br><br><span class="hljs-comment">// 把所有的男性收集起来,收集到List集合中</span><br>List&lt;String&gt; newList = list.stream()<br>    .filter(s -&gt; <span class="hljs-string">&quot;男&quot;</span>.equals(s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]))<br>    .collect(Collectors.toList());<br><br><span class="hljs-comment">// 把所有的男性收集起来,收集到Set集合中</span><br>List&lt;String&gt; newSet = list.stream()<br>    .filter(s -&gt; <span class="hljs-string">&quot;男&quot;</span>.equals(s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]))<br>    .collect(Collectors.toSet());<br><br><span class="hljs-comment">// 区别：Set集合会去重</span><br><br><span class="hljs-comment">// 把所有的男性收集起来,收集到Map集合中,键：姓名，值：年龄</span><br>Map&lt;String, Integer&gt; newMap = list.stream()<br>    .filter(s -&gt; <span class="hljs-string">&quot;男&quot;</span>.equals(s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]))<br>    .collect(Collectors.toMap(<br>    s -&gt; s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">0</span>],<br>        s -&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">3</span>])<br>));<br><span class="hljs-comment">// toMap()中，第一个参数是键，第二个参数是值</span><br><br></code></pre></td></tr></table></figure><br><p><strong>总结</strong></p><ol><li><p>Stream流的作用</p><p>结合了Lambda表达式，简化集合、数组的操作</p></li><li><p>Stream流的使用步骤</p><ul><li>获取Stream流对象</li><li>使用中间方法处理数据</li><li>使用终结方法处理数据</li></ul></li><li><p>如何获取Stream流对象</p><ul><li>单列集合：Collection中的默认方法Stream</li><li>双列集合：不能直接获取，要转为单列集合</li><li>数组：Arrays工具类中的静态方法Stream</li><li>零散的数据：Stream接口中的静态方法of</li></ul></li><li><p>常见方法</p><ul><li>中间方法：filter、limit、skip、distinct、concat、map</li><li>终结方法：forEach、count、collect</li></ul></li></ol><br><p><strong>练习题</strong></p><p>定义一个集合，并添加一些整数1,2,3,4,5,6,7,8,9,10<br>过滤奇数，只留下偶数<br>并将结果存下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);<br>List&lt;Integer&gt; collect = list.stream()<br>        .filter(s -&gt; s % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        .collect(Collectors.toList());<br>System.out.println(collect);<br></code></pre></td></tr></table></figure><br><p>创建一个ArrayList集合，并添加一下字符串，字符串中前面是姓名，后面是年龄<br>“张三，23”<br>“李四，24”<br>“王五，25”<br>保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-string">&quot;张三，23&quot;</span>,<span class="hljs-string">&quot;李四，24&quot;</span>,<span class="hljs-string">&quot;王五，25&quot;</span>);<br>Map&lt;String, Integer&gt; map = list.stream()<br>        .filter(s -&gt; Integer.parseInt((s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">1</span>])) &gt;= <span class="hljs-number">24</span>)<br>        .collect(Collectors.toMap(<br>                        s -&gt; (s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">0</span>]),<br>                        s -&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">1</span>])));<br>System.out.println(map);<br></code></pre></td></tr></table></figure><br><p>现在有两个ArrayList集合，<br>第一个集合中：存储6名男演员的名字和年龄，第二个集合中：存储6名女演员的名字和年龄<br>姓名和年龄中间用逗号隔开。如：”张三，23”<br>要求完成如下的操作：</p><ol><li>男演员只要名字为3个字的前两人</li><li>女演员只要姓杨的，并且不要第一个</li><li>把过滤后的男演员姓名和女演员姓名合并到一起</li><li>将上一步的演员信息封装成Actor对象</li><li>将所有的演员对象都保存到List集合中</li></ol><p>演员类属性: name, age</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; manList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(manList,<span class="hljs-string">&quot;蔡坤坤，24&quot;</span>,<span class="hljs-string">&quot;叶齁咸，23&quot;</span>,<span class="hljs-string">&quot;刘不甜，22&quot;</span>,<span class="hljs-string">&quot;吴签，24&quot;</span>,<span class="hljs-string">&quot;谷嘉，30&quot;</span>,<span class="hljs-string">&quot;肖凉凉，27&quot;</span>);<br>ArrayList&lt;String&gt; womenList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(womenList,<span class="hljs-string">&quot;赵小颖，35&quot;</span>,<span class="hljs-string">&quot;杨颖，36&quot;</span>,<span class="hljs-string">&quot;高圆圆，43&quot;</span>,<span class="hljs-string">&quot;张天天，31&quot;</span>,<span class="hljs-string">&quot;刘诗，35&quot;</span>,<span class="hljs-string">&quot;杨小幂，33&quot;</span>);<br><br><span class="hljs-comment">// 男演员只要名字为3个字的前两人</span><br>Stream&lt;String&gt; menStream = manList.stream().filter(s -&gt; s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">0</span>].length() == <span class="hljs-number">3</span>).limit(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 女演员只要姓杨的，并且不要第一个</span><br>Stream&lt;String&gt; womenStream = womenList.stream().filter(s -&gt; s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">0</span>].startsWith(<span class="hljs-string">&quot;杨&quot;</span>)).skip(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 把过滤后的男演员和女演员合并到一起</span><br>List&lt;Actor&gt; actorList = Stream.concat(menStream, womenStream)<br>        .map(s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Actor</span>(s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">0</span>]<br>                , Integer.parseInt(s.split(<span class="hljs-string">&quot;，&quot;</span>)[<span class="hljs-number">1</span>])))<br>        .collect(Collectors.toList());<br>System.out.println(actorList);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Actor类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Actor</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Actor</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Actor</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Actor&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不可变集合</title>
    <link href="/2023/10/22/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88/"/>
    <url>/2023/10/22/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站视频完成<a href="https://www.bilibili.com/video/BV1te411w722?vd_source=db8e7458ec195ac74979ce5478cbc624">Java-Stream流从入门到精通</a></p><p><strong>什么是不可变集合？</strong></p><img src="/2023/10/22/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88/20231022161920.png" style="zoom:67%;"><p><strong>不可变集合就是不能修改的集合</strong></p><p>应用场景:</p><ul><li>如果某个数据不能被修改，把它防御性的拷贝到不可变集合中是一个很好的实践</li><li>当集合对象被不可信的库调用的时候，不可变形式是安全的</li></ul><p>简单理解就是不想让别人修改集合中的内容<br>例如扑克牌，集合中存储扑克牌的种类和数量是不可变的</p><p><img src="/2023/10/22/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88/20231022162002.png"></p><br><p><strong>创建不可变集合的书写格式</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">static <E> List<E> of (E…elements)</E></E></td><td align="center">创建一个具有指定元素的List集合对象</td></tr><tr><td align="center">static <E> Set<E> of (E…elements)</E></E></td><td align="center">创建一个具有指定元素的Set集合对象</td></tr><tr><td align="center">static &lt;E,V&gt; Map&lt;E,V&gt; of (E…elements)</td><td align="center">创建一个具有指定元素的Map集合对象</td></tr></tbody></table><p>创建不可变List集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一旦创建完成之后，是无法进行修改的，在下面的代码中，只能进行查询操作</span><br>List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;赵六&quot;</span>); <span class="hljs-comment">// 该方法在jdk1.9及以后才有</span><br></code></pre></td></tr></table></figure><br><p>创建不可变Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一旦创建完成之后，是无法进行修改的，在下面的代码中，只能进行查询操作</span><br><span class="hljs-comment">// Map中的元素不能重复</span><br>Set&lt;String&gt; set = Set.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;赵六&quot;</span>); <span class="hljs-comment">// 该方法在jdk1.9及以后才有</span><br></code></pre></td></tr></table></figure><br><p>创建不可变Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一旦创建完成之后，是无法进行修改的，在下面的代码中，只能进行查询操作</span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">Map中的键位不能重复</span><br><span class="hljs-comment">Map里面的of方法，参数是有上限的，最多只能传递20个参数，也就是10对键值对，因为形参列表中只能有一个可变参数</span><br><span class="hljs-comment">如果我们要创建多个键值对对象，数量大于10个，在Map接口中还有一个方法ofEntries，把键和值看做一个整体来作为可变形参</span><br><span class="hljs-comment">*/</span><br>Map.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;北京&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;上海&quot;</span>); <span class="hljs-comment">// 张三是key，北京是value；李四是key，上海是value</span><br></code></pre></td></tr></table></figure><br><p>Map的ofEntries</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Map的不可变集合，键值对数量超过10</span><br><span class="hljs-comment">// 1.创建一个普通的Map集合</span><br>HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>map.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>map.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>map.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>map.put(<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>);<br>map.put(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>);<br>map.put(<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>);<br>map.put(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>);<br>map.put(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>);<br>map.put(<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>);<br>map.put(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>);<br><br><span class="hljs-comment">// 2.利用上面的数据来获取一个不可变集合</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">方法一</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 获取到所有的键值对对象(Entry对象)</span><br><span class="hljs-comment">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="hljs-comment">// 把entries变成一个数组</span><br><span class="hljs-comment">Map.Entry[] arr1 = new Map.Entry(0);</span><br><span class="hljs-comment">// toArray方法在底层会比较集合的长度和数组长度两者的大小</span><br><span class="hljs-comment">// 如果集合的长度 &gt; 数组的长度 : 数据在集合中放不下，此时会根据实际数据个数，查询创建数组</span><br><span class="hljs-comment">Map.Entry[] arr2 = entries.toArray(arr1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 不可变的Map集合</span><br><span class="hljs-comment">Map map = Map.ofEntries(arr2);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-comment">//Map&lt;Object, Object&gt; map = Map.ofEntries(map.entrySet().toArray(new Map.Entry[0]));</span><br><br><span class="hljs-comment">// 方法上：jdk 10 才开始有</span><br>Map&lt;String, String&gt; map = Map.copyOf(map);<br><br></code></pre></td></tr></table></figure><br><p><strong>总结</strong></p><ol><li><p>不可变集合的特点</p><p>定义完成后不可以修改，或者添加、删除</p></li><li><p>创建不可变集合</p><p>List、Set、Map接口中，都存在of方法可以创建不可变集合</p></li><li><p>三种方式的细节</p><ul><li>List：直接用</li><li>Set：元素不能重复</li><li>Map：元素不能重复，键值对数量最多是10个，超过10个用ofEntries方法</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公共字段自动填充</title>
    <link href="/2023/10/21/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/"/>
    <url>/2023/10/21/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/</url>
    
    <content type="html"><![CDATA[<p>在做项目的时候，很多数据库表会有<font color="red">相同字段</font>，例如很多表都会记下数据的<font color="red">创造时间、修改时间、创造者、修改者</font>，便于后期维护。如果每次对数据的增加和修改操作都需要手动添加后修改这些字段，则会有大量的相同代码，也影响了代码的可读性。为此，我们可以利用<font color="red">反射机制和AOP（面向切面编程）</font>，对这些公共字段进行<font color="red">统一处理</font></p><br><img src="/2023/10/21/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/20231021231450.png" style="zoom:67%;"><img src="/2023/10/21/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/20231021231417.png" style="zoom: 67%;"><table><thead><tr><th align="center">序号</th><th align="center">含义</th><th align="center">数据类型</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">创建时间</td><td align="center">datetime</td><td align="center">insert</td></tr><tr><td align="center">2</td><td align="center">创建人id</td><td align="center">bigint</td><td align="center">insert</td></tr><tr><td align="center">3</td><td align="center">修改时间</td><td align="center">datetime</td><td align="center">insert、update</td></tr><tr><td align="center">4</td><td align="center">修改人id</td><td align="center">bigint</td><td align="center">insert、update</td></tr></tbody></table><p><strong>解决方案</strong></p><ul><li>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法</li><li>自定义切面类AutoFillAspect，统一拦截加入了AutoFill注解的方法，通过反射为公共字段赋值</li><li>在Mapper的方法上加入AutoFill注解</li></ul><p>技术点： 枚举、注解、AOP、反射</p><br><p><strong>自定义注解AutoFill</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 自定义注解，用于识别某个方法需要进行功能字段自动填充</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFill &#123;<br>    <span class="hljs-comment">// 指定数据库操作的类型   update  insert</span><br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据库操作类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OperationType</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新操作</span><br><span class="hljs-comment">     */</span><br>    UPDATE,<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入操作</span><br><span class="hljs-comment">     */</span><br>    INSERT<br>&#125;<br></code></pre></td></tr></table></figure><p>OperationType 是自定义的枚举类</p><p>@Target 和 @Retention，可以用来修饰注解，是注解的注解，被称为元注解</p><p><strong>@Target :  目标，即该注解可以声明在哪些目标元素之前，也可理解为注释类型的程序元素的种类</strong></p><ul><li>ElementType.PACKAGE：该注解只能声明在一个包名前</li><li>ElementType.ANNOTATION_TYPE：该注解只能声明在一个注解类型前</li><li>ElementType.TYPE：该注解只能声明在一个类前</li><li>ElementType.CONSTRUCTOR：该注解只能声明在一个类的构造方法前</li><li>ElementType.LOCAL_VARIABLE：该注解只能声明在一个局部变量前</li><li>ElementType.METHOD：该注解只能声明在一个类的方法前</li><li>ElementType.PARAMETER：该注解只能声明在一个方法参数前</li><li>ElementType.FIELD：该注解只能声明在一个类的字段前</li></ul><p>**@Retention ：保留，可以理解为如何保留，即告诉编译程序如何处理，也可理解为注解类的生命周期 **</p><ul><li>RetentionPolicy.SOURCE  : 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃</li><li>RetentionPolicy.CLASS  : 注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期</li><li>RetentionPolicy.RUNTIME  : 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在</li></ul><br><p><strong>自定义切面类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java">**<br> * <span class="hljs-meta">@description</span>: 自定义切面<br> */<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 切入点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.sky.annotation.AutoFill)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span>&#123;&#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 前置通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始进行公共字段自动填充---&quot;</span>);<br><br>        <span class="hljs-comment">// 获取到当前被拦截的方法上的数据库操作类型</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature(); <span class="hljs-comment">// 方法签名对象</span><br>        <span class="hljs-type">AutoFill</span> <span class="hljs-variable">autoFill</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(AutoFill.class); <span class="hljs-comment">// 获得方法上的注解对象</span><br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">operationType</span> <span class="hljs-operator">=</span> autoFill.value(); <span class="hljs-comment">// 获得数据库操作类型</span><br><br>        <span class="hljs-comment">// 获取到当前被拦截的方法的参数--实体对象</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 在写新增和修改方法时，把实体放在第一个参数</span><br><br>        <span class="hljs-comment">// 准备赋值的数据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">currentId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>        <span class="hljs-comment">// 根据当前不同的操作类型，为对应的属性通过反射来赋值</span><br>        <span class="hljs-keyword">if</span> (operationType == OperationType.INSERT) &#123;<br>            <span class="hljs-comment">// 为4个字段赋值</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);<br><br>                <span class="hljs-comment">// 通过反射为对象属性赋值</span><br>                setCreateTime.invoke(entity,now);<br>                setCreateUser.invoke(entity,currentId);<br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operationType == OperationType.UPDATE) &#123;<br>            <span class="hljs-comment">// 为2个字段赋值</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                <span class="hljs-comment">// 通过反射为对象属性赋值</span><br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在执行update和save方法前就需要对公共字段赋值，所以这里使用的是前置通知<br>@Pointcut(“@annotation(com.sky.annotation.AutoFill)”)，com.sky.annotation.AutoFill 是自定义注解AutoFill类的位置<br>update方法只需要为2个公共字段赋值，save方法需要为4个公共字段赋值</p><br><p><strong>在Mapper的方法上加入AutoFill注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoFill(value = OperationType.INSERT)</span><br><span class="hljs-meta">@Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user) &quot; +</span><br><span class="hljs-meta">            &quot;values &quot; +</span><br><span class="hljs-meta">            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;)&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Employee employee)</span>;<br><br><br><span class="hljs-meta">@AutoFill(value = OperationType.UPDATE)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2023/10/18/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/10/18/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Lambda表达式"><a href="#1-什么是Lambda表达式" class="headerlink" title="1. 什么是Lambda表达式"></a>1. 什么是Lambda表达式</h3><p>Lambda表达式是一个<font color="red">匿名函数</font>,我们可以把Lambda表达式理解为是<font color="red">一段可以传递的代码</font>(将代码像数据一样传递)。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升</p><br><p><strong>简单案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(o1, o2) -&gt; Integer.compare(o1, o2);<br></code></pre></td></tr></table></figure><p><strong>格式</strong></p><p>-&gt;:lambda操作符或箭头操作符<br>-&gt;的左边:lambda形参列表，对应着要重写的接口中的抽象方法的形参列表<br>-&gt;的右边:Lambda体，对应着接口的实现类要重写的方法的方法体</p><br><h3 id="2-Lambda表达式的语法"><a href="#2-Lambda表达式的语法" class="headerlink" title="2. Lambda表达式的语法"></a>2. Lambda表达式的语法</h3><p><strong>语法格式一：无参，无返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;小白学Java&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br>r1. run();<br><br>System.out.println(<span class="hljs-string">&quot;*************************&quot;</span>);<br><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>     System.out.println(<span class="hljs-string">&quot;小白学Lambda&quot;</span>);<br>&#125;;<br>r2.run();<br></code></pre></td></tr></table></figure><br><p><strong>语法格式二：需要一个传输，但是没有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Consumer&lt;String&gt; con = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accpet</span><span class="hljs-params">(String s)</span> &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;;<br>con.accpet(<span class="hljs-string">&quot;谎言和誓言的区别是什么？&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;*************************&quot;</span>);<br><br>Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;<br>   System.out.println(s);<br>&#125;;<br>con1.accept(<span class="hljs-string">&quot;一个是说的人当真了，一个是听的人当真了&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>语法格式三：数据类型可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Consumer&lt;String&gt; con = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>           System.out.println(s);<br>&#125;;<br>con.accpet(<span class="hljs-string">&quot;如果大学可以重来，你最想重来的事是什么？&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;*************************&quot;</span>);<br><br>Consumer&lt;String&gt; con1 = (s) -&gt; &#123;<br>    System.out.println(s);<br>&#125;;<br>con1.accept(<span class="hljs-string">&quot;多去其它地方玩玩，别一直搁长沙玩&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>语法格式四：形参列表只有一个的时候，小括号也可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>Consumer&lt;String&gt; con1 = s -&gt; &#123;<br>    System.out.println(s);<br>&#125;;<br>con1.accept(<span class="hljs-string">&quot;多去其它地方玩玩，别一直搁长沙玩&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br><hr><h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h3><p><font color="red">如果接口中只声明有一个抽象方法，则此接口就称为函数式接口</font>，因为只有给函数式接口提供实现类对象时，我们才能使用Lambda表达式</p><p>jdk1.8中声明的函数式接口都在java.uti.function包下</p><br><p><strong>四大核心函数式接口</strong></p><table><thead><tr><th align="center">函数式接口</th><th align="center">称谓</th><th align="center">参数类型</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">Consumer<T></T></td><td align="center">消费型接口</td><td align="center">T</td><td align="center">对类型为T的对象应用操作，包含方法：void accept(T t)</td></tr><tr><td align="center">Supplier<T></T></td><td align="center">供给型接口</td><td align="center">无</td><td align="center">返回类型为T的对象，包括方法：T get()</td></tr><tr><td align="center">Function&lt;T,R&gt;</td><td align="center">函数型接口</td><td align="center">T</td><td align="center">对类型为T的对象应用操作，并返回结果。结果是R类型的对象，包含方法R apply(T t)</td></tr><tr><td align="center">Predicate<T></T></td><td align="center">判断型接口</td><td align="center">T</td><td align="center">确定类型为T的对象是否满足某约束，并返回boolean值，包含方法boolean test(T t)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-基础篇</title>
    <link href="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="一-JVM"><a href="#一-JVM" class="headerlink" title="一. JVM"></a>一. JVM</h2><h3 id="1-初识JVM"><a href="#1-初识JVM" class="headerlink" title="1. 初识JVM"></a>1. 初识JVM</h3><p><strong>什么是JVM？</strong></p><p><font color="red">JVM</font> 全程 Java Virtual Machine，中文译名<font color="red">Java虚拟机</font><br>JVM本质上是一个运行在计算机上的程序，他的&lt;&#x2F;职责是运行<font color="red">Java字节码文件</font><br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017143311.png" style="zoom: 50%;"></p><br><h3 id="2-JVM的功能"><a href="#2-JVM的功能" class="headerlink" title="2. JVM的功能"></a>2. JVM的功能</h3><ul><li>解释和运行<ul><li>对字节码文件中的指令，实时的解释成机器码，让计算机执行</li></ul></li><li>内存管理<ul><li>自动为对象、方法等分配内存</li><li>自动的垃圾回收机制，回收不再利用的对象</li></ul></li><li>即时编译<ul><li>对热点代码进行优化，提升执行效率</li></ul></li></ul><br><p><strong>即时编译</strong></p><ul><li><p>Java语言如果不做任何优化，性能不如C、C++等语言</p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017144235.png" style="zoom: 50%;"></li><li><p>Java需要实时解释，主要是为了支持跨平台特性</p></li><li><p>由于JVM需要实时解释虚拟机指令，不做任何优化性能不如直接运行机器码的C、C++等语言</p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017144309.png" style="zoom: 50%;"></li></ul><br><p><strong>常见的JVM</strong></p><table><thead><tr><th align="center">名称</th><th align="center">作者</th><th align="center">支持版本</th><th align="center">社区活跃度 （github star）</th><th align="center">特性</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">HotSpot  (Oracle JDK版)</td><td align="center">Oracle</td><td align="center">所有版本</td><td align="center">高(闭源)</td><td align="center">使用最广泛，稳定可靠，社区活跃 JIT支持 Oracle JDK默认虚拟机</td><td align="center">默认</td></tr><tr><td align="center">otSpot  (Open JDK版)</td><td align="center">Oracle</td><td align="center">所有版本</td><td align="center">中(16.1k)</td><td align="center">同上 开源，Open JDK默认虚拟机</td><td align="center">默认 对JDK有二次开发需求</td></tr><tr><td align="center">GraalVM</td><td align="center">Oracle</td><td align="center">11, 17,19 企业版支持8</td><td align="center">高（18.7k）</td><td align="center">多语言支持 高性能、JIT、AOT支持</td><td align="center">微服务、云原生架构 需要多语言混合编程</td></tr><tr><td align="center">Dragonwell JDK 龙井</td><td align="center">Alibaba</td><td align="center">标准版 8,11,17 扩展版11,17</td><td align="center">低(3.9k)</td><td align="center">基于OpenJDK的增强 高性能、bug修复、安全性提升 JWarmup、ElasticHeap、Wisp特性支</td><td align="center">电商、物流、金融领域 对性能要求比较高</td></tr><tr><td align="center">Eclipse OpenJ9</td><td align="center">IBM</td><td align="center">8,11,17,19,20</td><td align="center">低(3.1k)</td><td align="center">高性能、可扩展 JIT、AOT特性支持</td><td align="center">微服务、云原生架构</td></tr></tbody></table><br><p><strong>HotSpot的发展历程</strong></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017145327.png" style="zoom: 67%;"><br><p><strong>总结</strong></p><ol><li><p>JVM到底是什么？</p><p>JVM 全称是 Java Virtual Machine，中文译名 Java虚拟机，是一个运行在计算 机上的程序，他的职责是运行Java字节码文件</p></li><li><p>JVM的三大核心功能是什么？</p><p>JVM 包含内存管理、解释执行虚拟机指令、即时编译三大功能。</p></li><li><p>常见的JVM虚拟机有哪些？</p><p>常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK也 提供了一款功能增强版的JVM。其中使用最广泛的是HotSpot虚拟机</p></li></ol><br><hr><h2 id="二-字节码文件详解"><a href="#二-字节码文件详解" class="headerlink" title="二. 字节码文件详解"></a>二. 字节码文件详解</h2><h3 id="1-Java虚拟机的组成"><a href="#1-Java虚拟机的组成" class="headerlink" title="1.  Java虚拟机的组成"></a>1.  Java虚拟机的组成</h3><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231018133846.png"></p><br><hr><h3 id="2-字节码文件的组成"><a href="#2-字节码文件的组成" class="headerlink" title="2. 字节码文件的组成"></a>2. 字节码文件的组成</h3><p>字节码文件中保存了源代码编译之后的内容，以二进制的方式存储，无法直接用记事本打开阅读<br>推荐使用 jclasslib工具查看字节码文件,Github地址： <a href="https://github.com/ingokegel/jclasslib">https://github.com/ingokegel/jclasslib</a></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026135449.png" style="zoom:80%;"><br><p><strong>字节码文件一般包含5个部分</strong></p><ul><li><p>基础信息</p><p>魔数、字节码文件对应的Java版本号 访问标识(public final等等) 父类和接口</p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026135908.png"></p></li><li><p>常量池</p><p>保存了字符串常量、类或接口名、字段名 主要在字节码指令中使</p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026135928.png"></p></li><li><p>字段</p><p>当前类或接口声明的字段信息</p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026140014.png"></p></li><li><p>方法</p><p>当前类或接口声明的方法信息 字节码指令</p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026140032.png"></p></li><li><p>属性</p><p>类的属性，比如源码的文件名 内部类的列表等</p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026140135.png"></p></li></ul><br><hr><h3 id="3-基本信息"><a href="#3-基本信息" class="headerlink" title="3. 基本信息"></a>3. 基本信息</h3><p><strong>Magis魔数</strong></p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026150614.png"></p><ul><li>文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容</li><li>软件使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错</li><li>Java字节码文件中，将文件头称为magic魔数</li></ul><table><thead><tr><th align="center">文件类型</th><th align="center">字节数</th><th align="center">文件头</th></tr></thead><tbody><tr><td align="center">JPEG(jpg)</td><td align="center">3</td><td align="center">FFD8FF</td></tr><tr><td align="center">PNG(png)</td><td align="center">4</td><td align="center">89504E47(文件尾也有要求)</td></tr><tr><td align="center">bmp</td><td align="center">2</td><td align="center">424D</td></tr><tr><td align="center">XML(xml)</td><td align="center">5</td><td align="center">3C3F786D6C</td></tr><tr><td align="center">AVI(avi)</td><td align="center">4</td><td align="center">41564920</td></tr><tr><td align="center">Java字节码文件(.class)</td><td align="center">4</td><td align="center">CAFEBABE</td></tr></tbody></table><br><p><strong>主副版本号</strong></p><ul><li><font color="red">主副版本号指的是编译字节码文件的JDK版本号</font>，主版本号用来标识大版本号，JDK1.0-1.1使用了 45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同 版本的标识，一般只需要关心主版本号</li><li>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容</li></ul><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026161923.png" style="zoom: 67%;"><p>1.2之后大版本号计算方法就是: 主版本号 – 44 比如主版本号52就是JDK1.8</p><br><p>主版本号不兼容导致的错误</p><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026162108.png"></p><p>解决方案</p><ul><li>升级JDK版本 </li><li>将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求</li></ul><br><hr><h3 id="4-常量池"><a href="#4-常量池" class="headerlink" title="4. 常量池"></a>4. 常量池</h3><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027105433.png" style="zoom:67%;"><ul><li>字节码文件中常量池的作用：避免相同的内容重复定义，节省空间</li><li>常量池中的数据都有一个编号，编号从1开始，在字段或字节码指令中可以通过编号快速找到对应的数据</li><li>字节码指令通过编号引用到常量池的过程称为<font color="red">符号引用</font></li></ul><br><hr><h3 id="5-方法"><a href="#5-方法" class="headerlink" title="5. 方法"></a>5. 方法</h3><ul><li>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中</li><li>操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置</li></ul><p><strong>解析int i &#x3D; 0; int j &#x3D; i + 1;</strong></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027163754.png" style="zoom:67%;"><ul><li>iconst_0: 把0放入操作上栈</li><li>istore_1: 从操作数栈取出放入 局部变量表1号位置</li><li>iload_1: 将局部变量表1中的数 据放入操作数栈</li><li>iconst_1: 将常量1放入操作数栈</li><li>iadd: 将操作数栈顶部的两个 数据进行累加,结果放入栈中</li><li>istore_2: 将相加后的结果取出放入局部变量表2号位置</li><li>return: 方法结束、返回</li></ul><br><p><strong>解析i &#x3D; 0; i &#x3D; i++;</strong></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027164322.png" style="zoom:67%;"><br><p><strong>解析i &#x3D; 0; i &#x3D; ++i;</strong></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027164338.png" style="zoom: 67%;"><br><p><strong>int i &#x3D; 0; i &#x3D; i++;最终i的值是多少?</strong></p><p>最终i的值是0，通过分析字节码文件发现，i++ 是先把0取出来放入操作数栈中，接下来在局部变量表中对i进行加1，i变成了1，最近再将之前操作数栈中的0取出来放入i，最后i就变成了0</p><br><hr><h3 id="6-字节码文件常用工具"><a href="#6-字节码文件常用工具" class="headerlink" title="6. 字节码文件常用工具"></a>6. 字节码文件常用工具</h3><ul><li>javap -v 命令</li><li>jclasslib插件</li><li>阿里arthas</li></ul><br><p><strong>javao -v命令</strong></p><ul><li>javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内 容</li><li>直接输入javap查看所有参数</li><li>输入javap -v 字节码文件名称 查看具体的字节码信息。（如果jar包需要先使用 jar –xvf 命令解压）</li></ul><br><p><strong>jclasslibidea插件</strong></p><p>jclasslib也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码 文件内容</p><p>首先应该下载并安装插件<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028121044.png" style="zoom: 50%;"></p><br><p>编译完代码后即可打开字节码文件<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028121407.png"></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028121602.png" style="zoom:67%;"><br><p><strong>阿里arthas</strong></p><ul><li>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修 改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率</li><li>官网：<a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li><li>dump 类的全限定名：dump已加载类的字节码文件到特定目录</li><li>ad 类的全限定名： 反编译已加载类的源码</li></ul><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028122520.png" style="zoom:67%;"><br><hr><h2 id="三-类的生命周期"><a href="#三-类的生命周期" class="headerlink" title="三. 类的生命周期"></a>三. 类的生命周期</h2><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133012.png" style="zoom:67%;"><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133121.png" style="zoom: 50%;"><br><h3 id="1-加载阶段"><a href="#1-加载阶段" class="headerlink" title="1.  加载阶段"></a>1.  加载阶段</h3><ol><li><p>加载(Loading)阶段第一步是<font color="red">类加载器</font>根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。 程序员可以使用Java代码拓展的不同的渠道<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133906.png" style="zoom:67%;"></p></li><li><p>类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133928.png" style="zoom:67%;"></p></li><li><p>类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。 生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133958.png" style="zoom:67%;"></p></li><li><p>同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。 作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后)<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028134029.png" style="zoom:67%;"></p></li></ol><br><p>对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息,<font color="red">这样Java虚拟机就能很好地控制开发者访问数据的范围</font></p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028134100.png" style="zoom:67%;"><br><hr><h3 id="2-连接阶段"><a href="#2-连接阶段" class="headerlink" title="2. 连接阶段"></a>2. 连接阶段</h3><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028141240.png" style="zoom:67%;"><br><p><strong>验证</strong></p><p>连接的第一个环节是验证，验证的主要目的是检查Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与<br>主要包含4个部分</p><ol><li>文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求</li><li>元信息验证，例如类必须有父类（super不能为空）</li><li>验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去</li><li>符号引用验证，例如是否访问了其他类中private的方法等</li></ol><br><p><strong>准备</strong></p><p>准备阶段为静态变量（static）分配内存并设置初始值<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028142605.png" style="zoom:67%;"></p><p>准备阶段只会给静态变量赋初始值，而每一种基本数据类型和引用数据类型都有其初始值</p><table><thead><tr><th align="center">数据类型</th><th align="center">初始值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">o</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">short</td><td align="center">0</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td></tr><tr><td align="center">byte</td><td align="center">0</td></tr><tr><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">double</td><td align="center">0.0</td></tr><tr><td align="center">引用数据类型</td><td align="center">null</td></tr></tbody></table><br><p>final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028142623.png" style="zoom:67%;"></p><br><p><strong>解析</strong></p><ul><li>解析阶段主要是将常量池中的符号引用替换为直接引用</li><li>直接引用不在使用编号，而是使用内存中地址进行访问具体的数据</li></ul><br><hr><h3 id="3-初始化阶段"><a href="#3-初始化阶段" class="headerlink" title="3. 初始化阶段"></a>3. 初始化阶段</h3>]]></content>
    
    
    <categories>
      
      <category>JVM篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建个人博客</title>
    <link href="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo搭建个人博客"><a href="#Hexo搭建个人博客" class="headerlink" title="Hexo搭建个人博客"></a>Hexo搭建个人博客</h2><br><hr><h3 id="1-Git的下载安装"><a href="#1-Git的下载安装" class="headerlink" title="1. Git的下载安装"></a>1. Git的下载安装</h3><p>下载地址为 <a href="https://git-scm.com/">git-scm.com</a>或者<a href="http://gitforwindows.org/">gitforwindows.org</a>，或者<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">阿里镜像</a></p><p>git-scm为官方下载地址，gitforwindows只能下载Windows版本</p><br><hr><h3 id="2-nodejs的下载"><a href="#2-nodejs的下载" class="headerlink" title="2. nodejs的下载"></a>2. nodejs的下载</h3><p><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231005142742.png" alt="'" style="zoom:67%;"><p>LTS:长期支持版本</p><br><hr><h3 id="3-nodejs的安装"><a href="#3-nodejs的安装" class="headerlink" title="3. nodejs的安装"></a>3. nodejs的安装</h3><p>一直下一步就行了</p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231005143046.png" style="zoom:60%;"><p>安装成功</p><br><hr><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4. 安装hexo"></a>4. 安装hexo</h3><p> 以管理员身份打开powershell或者打开git</p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231005143325.png" style="zoom: 50%;"><p>查看node版本node -v</p><p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231005143619.png"></p><br><p>由于 npm在国内的镜像powwer源的速度很慢，所以我们先安装cnpm（淘宝镜像源）。由于使用powershell报错，所以接下来使用git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">npm install -g cnpm --registry=https://registry.npm.taobao.org<br># 查看cnpm版本<br>cnpm -v<br></code></pre></td></tr></table></figure><p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006104324.png"></p><br><p>用cnpm全局安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006104806.png" style="zoom:67%;"><br><p>用hexo -v指令才确认是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo -v<br></code></pre></td></tr></table></figure><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006105038.png" style="zoom:80%;"><br><p>创建一个blog文件夹并切换到该文件夹</p><p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006105309.png"></p><p>初始化博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo init<br></code></pre></td></tr></table></figure><p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006105757.png"></p><br><p>初始化后会在blog文件夹中生成一些文件</p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006105844.png" style="zoom:67%;"><br><p>在本地启动博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo s<br></code></pre></td></tr></table></figure><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006110112.png" style="zoom:67%;"><p>访问4000端口</p><img src="/2023/10/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/20231006110205.png" style="zoom:67%;"><br><p>新建文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo n &quot;&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务面试题</title>
    <link href="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231013145620.png" style="zoom:80%;"><br><hr><h2 id="一-Spring-Cloud"><a href="#一-Spring-Cloud" class="headerlink" title="一. Spring Cloud"></a>一. Spring Cloud</h2><h3 id="1-Spring-Cloud的5大组件有哪些？"><a href="#1-Spring-Cloud的5大组件有哪些？" class="headerlink" title="1. Spring Cloud的5大组件有哪些？"></a>1. Spring Cloud的5大组件有哪些？</h3><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231013145753.png" style="zoom:67%;"><ul><li>Eureka：注册中心</li><li>Ribbon：负载均衡</li><li>Feign：远程调用</li><li>Hystrix：服务熔断</li><li>Zuul&#x2F;Gateway：网关</li></ul><br><p>随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件</p><ul><li>注册中心：Nacos</li><li>负载均衡：Ribbon</li><li>服务调用：Feign</li><li>服务保护：sentinel</li><li>服务网关：Gateway</li></ul><br><hr><h3 id="2-Spring-Cloud是如何实现服务注册发现"><a href="#2-Spring-Cloud是如何实现服务注册发现" class="headerlink" title="2. Spring Cloud是如何实现服务注册发现"></a>2. Spring Cloud是如何实现服务注册发现</h3><ul><li>注册中心的核心作用是：服务注册和发现</li><li>常见的注册中心：eureka、nacos、zookeeper</li></ul><br><p><strong>Eureka的作用</strong></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014195203.png" style="zoom:67%;"><br><p><strong>Nacos的作用</strong></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014195259.png" style="zoom:67%;"><br><p><strong>服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</strong></p><ul><li>我们当时学习的时候采用的eureka作为注册中心，这个也是spring cloud体系中的一个核心组件</li><li><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等</li><li><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li><li><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除</li></ul><br><p><strong>Nacos和Eureka的区别</strong></p><ul><li>Nacos与eureka的共同点（注册中心）<ol><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ol></li><li>Nacos与Eureka的区别（注册中心）<ol><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ol></li><li>Nacos还支持了配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因</li></ul><br><hr><h3 id="3-负载均衡如何实现的"><a href="#3-负载均衡如何实现的" class="headerlink" title="3. 负载均衡如何实现的"></a>3. 负载均衡如何实现的</h3><ul><li>负载均衡 Ribbon，发起远程调用feign就会使用Ribbon</li><li>Ribbon负载均衡策略有哪些 ?</li><li>如果想自定义负载均衡策略如何实现 ?</li></ul><br><p><strong>Ribbon负载均衡流程</strong></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014195930.png" style="zoom:67%;"><br><p><strong>Ribbon负载均衡策略</strong></p><ul><li><font color="red">RoundRobinRule：简单轮询服务列表来选择服务器</font></li><li><font color="red">WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</font></li><li><font color="red">RandomRule：随机选择一个可用的服务器</font></li><li>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li><li>RetryRule：重试机制的选择逻辑</li><li>AvailabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li><li><font color="red">ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</font></li></ul><br><p><strong>自定义负载均衡的实现</strong></p><p>可以自己创建类实现IRule接口 , 然后再通过配置类或者配置文件配置即可 ，通过定义IRule实现可以修改负载均衡规则，有两种方式：<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014200850.png" style="zoom:67%;"></p><br><p><strong>负载均衡如何实现的？</strong></p><p>微服务的负载均衡主要使用了一个组件Ribbon，比如，我们在使用feign远程调用的过程中，底层的负载均衡就是使用了ribbon</p><br><p><strong>Ribbon负载均衡策略有哪些？</strong></p><ul><li>RoundRobinRule：简单轮询服务列表来选择服务器</li><li>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</li><li>RandomRule：随机选择一个可用的服务器</li><li>ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询(默认)</li></ul><br><p><strong>如果想自定义负载均衡策略如何实现？</strong></p><p>提供了两种方式：</p><ol><li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li><li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）</li></ol><br><hr><h3 id="4-什么是服务雪崩"><a href="#4-什么是服务雪崩" class="headerlink" title="4. 什么是服务雪崩"></a>4. 什么是服务雪崩</h3><p>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形<br>解决方法: 熔断降级</p><p><strong>服务降级</strong></p><p>服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014202100.png" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;leadnews-article&quot;, fallback = IArticleClientFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IArticleClient</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/api/v1/article/save&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">saveArticle</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ArticleDto dto)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IArticleClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IArticleClient</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">saveArticle</span><span class="hljs-params">(ArticleDto dto)</span> &#123;<br>        <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR, <span class="hljs-string">&quot;获取数据失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>服务熔断</strong></p><p>Hystrix 熔断机制，用于监控微服务调用情况， 默认是关闭的，如果需要开启需要在引导类上添加注解：@EnableCircuitBreaker<br>如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014202129.png" style="zoom:67%;"><br><p><strong>什么是服务雪崩，怎么解决这个问题？</strong></p><ul><li>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</li><li>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑</li><li>服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</li></ul><br><hr><h3 id="5-微服务是怎么监控的"><a href="#5-微服务是怎么监控的" class="headerlink" title="5. 微服务是怎么监控的"></a>5. 微服务是怎么监控的</h3><p><strong>skywalking</strong></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014203502.png" style="zoom:67%;"><ul><li>服务（service）：业务资源应用系统（微服务）</li><li>端点（endpoint）：应用系统对外暴露的功能接口（接口）</li><li>实例（instance）：物理机</li></ul><br><p><strong>微服务是怎么监控的？</strong></p><p>我在学习的时候采用的skywalking进行监控的</p><ol><li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li><li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li></ol><br><hr><h2 id="二-业务相关"><a href="#二-业务相关" class="headerlink" title="二. 业务相关"></a>二. 业务相关</h2><h3 id="1-限流的实现"><a href="#1-限流的实现" class="headerlink" title="1. 限流的实现"></a>1. 限流的实现</h3><p>为什么要限流？<br>并发量大（突发流量）、防止用户恶意刷接口</p><p>限流的实现方式：</p><ul><li>Tomcat：可以设置最大连接数</li><li>Nginx，漏桶算法</li><li>网关，令牌桶算法</li><li>自定义拦截器</li></ul><br><p><strong>Nginx限流</strong></p><p>控制速率（突发流量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">http &#123;<br>    limit_req_zone $binary_remote_addr zone=servicelRateLimit:10m rate=10r/s<br>    server &#123;<br>        listen<span class="hljs-number">80</span>;<br>        server_name localhost;<br>        location / &#123;<br>            limit_req_zone = servicelRateLimit burst=<span class="hljs-number">20</span> nodelay;<br>            proxy_pass http:<span class="hljs-comment">//targetserver;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>语法: limit_req_zone key zone rate</li><li>key:定义限流对象，binary_remote_addr就是一种key，基于客户端ip限流</li><li>Zone：定义共享存储区来存储访问信息，10m可以存储16wip地址访问信息</li><li>Rate：最大访问速率，rate&#x3D;10r&#x2F;s 表示每秒最多请求10个请求</li><li>burst&#x3D;20：相当于桶的大小</li><li>Nodelay：快速处理</li></ul><br><p>控制并发连接数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">http &#123;<br>    limit_conn_zone $binary_remote_addr zone=perip:10m;<br>    limit_conn_zone $server_name zone=perserver:10m;<br>    server &#123;<br>        listen <span class="hljs-number">80</span>;<br>        server_name localhost;<br>        location / &#123;<br>            ...<br>            limit_conn perip <span class="hljs-number">20</span>;<br>            limit_conn perserver <span class="hljs-number">100</span>;<br>            proxy_pass http:<span class="hljs-comment">//targetserver;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>limit_conn perip 20：对应的key是 $binary_remote_addr，表示限制单个IP同时最多能持有20个连接。</li><li>limit_conn perserver 100：对应的key是 $server_name，表示虚拟主机(server) 同时能处理并发连接的总数</li></ul><br><p><strong>网关限流</strong></p><p>yml配置文件中，微服务路由设置添加局部过滤器RequestRateLimiter</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">id:</span> <span class="hljs-string">gateway-consumer</span><br><span class="hljs-attr">uri:</span> <span class="hljs-string">lb://GATEWAY-CONSUMER</span><br><span class="hljs-attr">predicates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span><br><span class="hljs-attr">filters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span><br>  <span class="hljs-attr">args:</span><br>  <span class="hljs-comment"># 使用SpEL从容器中获取对象</span><br>  <span class="hljs-attr">key-resolver:</span> <span class="hljs-string">&#x27;#&#123;@pathKeyResolver&#125;&#x27;</span><br>  <span class="hljs-comment"># 命令桶每秒填充平均速率</span><br>  <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">1</span><br>  <span class="hljs-comment"># 命令桶的上限</span><br>  <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><ul><li>key-resolver ：定义限流对象（ ip 、路径、参数），需代码实现，使用spel表达式获取</li><li>replenishRate ：令牌桶每秒填充平均速率。</li><li>urstCapacity ：令牌桶总容量。</li></ul><br><hr><h3 id="2-CAP和BASE"><a href="#2-CAP和BASE" class="headerlink" title="2. CAP和BASE"></a>2. CAP和BASE</h3><p><strong>CAP定理</strong></p><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance （分区容错性）</li></ul><p>Eric Brewer 说，分布式系统无法同时满足这三个指标<br>这个结论就叫做 CAP 定理。</p><br><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017212903.png" style="zoom:67%;"></p><br><p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017212937.png" style="zoom:60%;"></p><br><p>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。<br>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017213002.png" style="zoom:67%;"></p><br><ul><li>分布式系统节点之间肯定是需要网络连接的，分区（P）是必然存在的</li><li>如果保证访问的高可用性（A）,可以持续对外提供服务，但不能保证数据的强一致性–&gt; AP</li><li>如果保证访问的数据强一致性（C）,就要放弃高可用性  –&gt; CP</li></ul><br><p><strong>BASE理论</strong></p><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li>BasicallyAvailable （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li><li>Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li><li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li></ul><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017213036.png" style="zoom:67%;"><br><p><strong>解释一下CAP和BASE</strong></p><ul><li>CAP 定理(一致性、可用性、分区容错性)<ol><li>分布式系统节点通过网络连接，一定会出现分区问题（P）</li><li>当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足</li></ol></li><li>BASE理论<ol><li>基本可用</li><li>软状态</li><li>最终一致</li></ol></li><li>解决分布式事务的思想和模型<ol><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）</li></ol></li></ul><br><hr><h3 id="3-分布式事务解决方案"><a href="#3-分布式事务解决方案" class="headerlink" title="3. 分布式事务解决方案"></a>3. 分布式事务解决方案</h3><p>你采用哪种分布式事务解决方法？</p><ul><li>Seata框架（XA、AT、TCC）</li><li>MQ</li></ul><br><p><strong>Seata框架</strong></p><p>Seata事务管理中有三个重要的角色：</p><ul><li><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214433.png" style="zoom: 80%;"><br><p><strong>Seata的XA模式</strong></p><p>RM一阶段的工作：</p><ol><li>注册分支事务到TC</li><li>执行分支业务SQL但不提交</li><li>报告执行状态到TC</li></ol><p>TC二阶段的工作：</p><ul><li>TC检测各分支事务执行状态<ul><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ul></li></ul><p>RM二阶段的工作：</p><ul><li>接受TC指令，提交或回滚事务</li></ul><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214725.png" style="zoom: 80%;"><br><p><strong>AT模式原理</strong></p><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷</p><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214744.png" style="zoom: 80%;"><br><p><strong>TCC模式原理</strong></p><ol><li>Try：资源的检测和预留； </li><li>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</li><li>Cancel：预留资源释放，可以理解为try的反向操作。</li></ol><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214807.png" style="zoom:80%;"><br><p><strong>MQ分布式事务</strong></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214832.png" style="zoom:80%;"><p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好</p><br><hr><h3 id="4-分布式服务的接口幂等性设计"><a href="#4-分布式服务的接口幂等性设计" class="headerlink" title="4. 分布式服务的接口幂等性设计"></a>4. 分布式服务的接口幂等性设计</h3><p>幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</p><p>需要幂等场景</p><ul><li>用户重复点击(网络波动)</li><li>MQ消息重复</li><li>应用使用失败或超时重试机制</li></ul><br><p><strong>接口幂等</strong></p><p>基于RESTful API的角度对部分常见类型请求的幂等性特点进行分析</p><table><thead><tr><th><strong>请求方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>GET</td><td>查询操作，天然幂等</td></tr><tr><td>POST</td><td>新增操作，请求一次与请求多次造成的结果不同，不是幂等的</td></tr><tr><td>PUT</td><td>更新操作，如果是以绝对值更新，则是幂等的。如果是通过增量的方式更新，则不是幂等的</td></tr><tr><td>DELETE</td><td>删除操作，根据唯一值删除，是幂等的</td></tr></tbody></table><br><p><strong>token+redis</strong></p><p>创建商品、提交订单、转账、支付等操作</p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017220614.png" style="zoom:67%;"><br><p><strong>分布式锁</strong></p><ul><li>快速失败（抢不到锁的线程）</li><li>控制锁的力度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrder</span><span class="hljs-params">(Item item)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//获取锁（重入锁），执行锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;heimalock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//判断是否获取成功</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            log.info(<span class="hljs-string">&quot;下单操作获取锁失败,order:&#123;&#125;&quot;</span>,item);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;新增或修改失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//下单操作</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>分布式服务的接口幂等性如何设计？</strong></p><ul><li>幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</li><li>如果是新增数据，可以使用数据库的唯一索引</li><li>如果是新增或修改数据<ul><li>分布式锁，性能较低</li><li>使用token+redis来实现，性能较好<ul><li>第一次请求，生成一个唯一token存入redis，返回给前端</li><li>第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token；如果不存在，则直接返回，不处理业务</li></ul></li></ul></li></ul><br><hr><h3 id="5-分布式任务调度"><a href="#5-分布式任务调度" class="headerlink" title="5. 分布式任务调度"></a>5. 分布式任务调度</h3><p><strong>XXL-JOB解决的问题</strong></p><ul><li>解决集群任务的重复执行问题</li><li>cron表达式定义灵活</li><li>定时任务失败了，重试和统计</li><li>任务量大，分片执行</li></ul><br><p><strong>XXL-JOB路由策略有哪些？</strong></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017224713.png" style="zoom: 80%;"><ol><li>FIRST（第一个）：固定选择第一个机器；</li><li>LAST（最后一个）：固定选择最后一个机器；</li><li>ROUND（轮询）</li><li>RANDOM（随机）：随机选择在线的机器；</li><li>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</li><li>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</li><li>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</li><li>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</li><li>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</li><li>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</li></ol><br><p><strong>XXL-JOB任务执行失败怎么解决？</strong></p><p>故障转移+失败重试，查看日志分析—-&gt; 邮件告警<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017225001.png" style="zoom:67%;"></p><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017225020.png" style="zoom:80%;"><br><p><strong>如果有大数据量的任务同时都需要执行，怎么解决？</strong></p><p>执行器集群部署时，任务路由策略选择分片广播情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017225039.png" style="zoom:67%;"></p><p>分片参数</p><ul><li>index：当前分片序号(从0开始)，执行器集群列表中当前执行器的序号；</li><li>total：总分片数，执行器集群的总机器数量；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@XxlJob(&quot;shadingSample&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shardingJobHandler</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 分片参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">shardIndex</span> <span class="hljs-operator">=</span> XxlJobHelper.getShardIndex();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">shardTotal</span> <span class="hljs-operator">=</span> XxlJobHelper.getShardTotal();<br>    XxlJobHelper.log(<span class="hljs-string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);<br>    <span class="hljs-comment">// 业务逻辑</span><br>    List&lt;Integer&gt; list = getList();<br>    <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>        <span class="hljs-keyword">if</span>(integer % shardTotal == shardIndex)&#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span>+shardIndex+<span class="hljs-string">&quot;分片执行，执行数据为：&quot;</span>+integer);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>xxl-job路由策略有哪些？</strong><br>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</p><p><strong>xxl-job任务执行失败怎么解决？</strong></p><ul><li>路由策略选择故障转移，使用健康的实例来执行任务</li><li>设置重试次数</li><li>查看日志+邮件告警来通知相关负责人解决</li></ul><p><strong>如果有大数据量的任务同时都需要执行，怎么解决？</strong></p><ul><li>让多个实例一块去执行（部署集群），路由策略分片广播</li><li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程面试题</title>
    <link href="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009092213.png"></p><br><hr><h2 id="一-线程的基础知识"><a href="#一-线程的基础知识" class="headerlink" title="一. 线程的基础知识"></a>一. 线程的基础知识</h2><h3 id="1-线程与进程的区别"><a href="#1-线程与进程的区别" class="headerlink" title="1. 线程与进程的区别"></a>1. 线程与进程的区别</h3><p>程序由<font color="red">指令</font>和<font color="red">数据</font>组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的<br><font color="red">当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</font></p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009092934.png" style="zoom: 50%;"><br><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>一个进程之内可以分为一到多个线程。</p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009092953.png" style="zoom:67%;"><br><p><strong>二者对比</strong></p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li></ul><br><hr><h3 id="2-并行与并发有什么区别"><a href="#2-并行与并发有什么区别" class="headerlink" title="2. 并行与并发有什么区别"></a>2. 并行与并发有什么区别</h3><p><strong>单核CPU</strong></p><ul><li>单核CPU下线程实际还是串行执行的</li><li>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</li><li>总结为一句话就是： 微观串行，宏观并行</li><li>一般会将这种线程轮流使用CPU的做法称为并发</li></ul><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009094008.png" style="zoom: 67%;"><br><p><strong>多核CPU</strong></p><p>每个核都可以调度运行线程，这时候线程可以是并行的<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009094026.png" style="zoom: 80%;"></p><p>&lt;br&#x2F; &gt;</p><p><strong>两者区别</strong></p><p>并发（concurrent）是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）是同一时间动手做（doing）多件事情的能力</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li></ul><br><p><strong>总结</strong></p><p>现在都是多核CPU，在多核CPU下</p><ul><li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li><li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li></ul><br><hr><h3 id="3-创建线程的方式"><a href="#3-创建线程的方式" class="headerlink" title="3. 创建线程的方式"></a>3. 创建线程的方式</h3><p>共有四种方式可以创建线程，分别是：</p><ul><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread...run...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建MyThread对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;<br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br></li><li><p>实现runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyRunnable...run...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建MyRunnable对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">// 创建Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);<br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br></li><li><p>实现Callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建MyCallable对象</span><br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>() ;<br>        <span class="hljs-comment">// 创建FutureTask</span><br>        FutureTask&lt;String&gt; ft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(mc) ;<br>        <span class="hljs-comment">// 创建Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft) ;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft) ;<br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        <span class="hljs-comment">// 调用ft的get方法获取执行结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ft.get();<br>        <span class="hljs-comment">// 输出</span><br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br></li><li><p>线程池创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExecutors</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyRunnable...run...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        threadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyExecutors</span>()) ;<br>        <span class="hljs-comment">// 关闭线程池</span><br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><br><p><strong>runnable和callable有什么区别</strong></p><ol><li>Runnable 接口run方法没有返回值</li><li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ol><br><p><strong>线程的run()和start()有什么区别</strong></p><p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。<br>run(): 封装了要被线程执行的代码，可以被调用多次。</p><br><p><strong>总结</strong></p><ol><li><p>创建线程的方法</p><ul><li>继承Thread类</li><li>实现runnable接口</li><li>实现Callable接口</li><li>线程池创建线程(项目中使用方式)</li></ul></li><li><p>runnable和callable有什么区别</p><ul><li>Runnable 接口run方法没有返回值</li><li>Callable接口call方法有返回值，需要FutureTask获取结果</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ul></li><li><p>run()和start()有什么区别</p><ul><li>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li><li>run(): 封装了要被线程执行的代码，可以被调用多次。</li></ul></li></ol><br><hr><h3 id="4-线程包括哪些状态，状态之间是如何变化的"><a href="#4-线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="4. 线程包括哪些状态，状态之间是如何变化的"></a>4. 线程包括哪些状态，状态之间是如何变化的</h3><p>线程的状态可以参考JDK中的Thread类中的枚举State</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">//尚未启动的线程的线程状态</span><br>    NEW,<br>    <span class="hljs-comment">//可运行线程的线程状态。</span><br>    RUNNABLE,<br>    <span class="hljs-comment">//线程阻塞等待监视器锁的线程状态。</span><br>    BLOCKED,     <br>    <span class="hljs-comment">//等待线程的线程状态</span><br>    WAITING,<br>    <span class="hljs-comment">//具有指定等待时间的等待线程的线程状态</span><br>    TIMED_WAITING,<br>    <span class="hljs-comment">//已终止线程的线程状态。线程已完成执行</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009111306.png"></p><br><p><strong>总结</strong></p><ol><li><p>线程包括哪些状态</p><p>新建（NEW）、可运行（RUNNABLE）、阻塞（BLOCKED）、等待（ WAITING ）、时间等待（TIMED_WALTING）、终止（TERMINATED）</p></li><li><p>线程状态之间是如何变化的</p><ul><li>创建线程对象是新建状态</li><li>调用了start()方法转变为可执行状态</li><li>线程获取到了CPU的执行权，执行结束是终止状态</li><li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul><li>如果没有获取锁（synchronized或lock）进入阻塞状态，获得锁再切换为可执行状态</li><li>如果线程调用了wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态</li><li>如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态</li></ul></li></ul></li></ol><br><hr><h3 id="5-新建三个线程，如何保证他们按顺序执行"><a href="#5-新建三个线程，如何保证他们按顺序执行" class="headerlink" title="5.  新建三个线程，如何保证他们按顺序执行"></a>5.  新建三个线程，如何保证他们按顺序执行</h3><p>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？<br>可以使用线程中的join方法解决<br><font face="仿宋">join() 等待线程运行结束</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;t1&quot;</span>);<br>&#125;) ;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t1.join();                          <span class="hljs-comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;t2&quot;</span>);<br>&#125;) ;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t2.join();                              <span class="hljs-comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;t3&quot;</span>);<br>&#125;) ;<br><span class="hljs-comment">// 启动线程</span><br>t1.start();<br>t2.start();<br>t3.start();<br></code></pre></td></tr></table></figure><br><hr><h3 id="6-notify-和notifyAll-有什么区别"><a href="#6-notify-和notifyAll-有什么区别" class="headerlink" title="6. notify()和notifyAll()有什么区别"></a>6. notify()和notifyAll()有什么区别</h3><ul><li>notifyAll：唤醒所有wait的线程</li><li>notify：只随机唤醒一个 wait 线程</li></ul><br><hr><h3 id="7-Java中的wait和sleep方法的不同"><a href="#7-Java中的wait和sleep方法的不同" class="headerlink" title="7. Java中的wait和sleep方法的不同"></a>7. Java中的wait和sleep方法的不同</h3><p><strong>共同点</strong>：<br>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</p><p><strong>不同点：</strong></p><ol><li><p>方法的归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ol><br><hr><h3 id="8-如何停止一个正在运行的线程"><a href="#8-如何停止一个正在运行的线程" class="headerlink" title="8. 如何停止一个正在运行的线程"></a>8. 如何停止一个正在运行的线程</h3><p>有三种方式可以停止线程</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程<ul><li>打断阻塞的线程（ sleep，wait，join ）的线程，线程会抛出InterruptedException异常</li><li>打断正常的线程，可以根据打断状态来标记是否退出线程</li></ul></li></ul><br><hr><h2 id="二-线程中的并发安全"><a href="#二-线程中的并发安全" class="headerlink" title="二. 线程中的并发安全"></a>二. 线程中的并发安全</h2><h3 id="1-synchronized关键字的底层原理"><a href="#1-synchronized关键字的底层原理" class="headerlink" title="1. synchronized关键字的底层原理"></a>1. synchronized关键字的底层原理</h3><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTicket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">if</span> (ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到一张票,剩余:&quot;</span> + ticketNum);<br>            <span class="hljs-comment">// 非原子性操作</span><br>            ticketNum--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TicketDemo</span> <span class="hljs-variable">ticketDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                ticketDemo.getTicket();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>Monitor</strong></p><p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009112831.png" style="zoom:67%;"><ul><li>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</li><li>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</li><li>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</li></ul><br><p><strong>总结</strong></p><ul><li>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li><li>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</li><li>在monitor内部有三个属性，分别是owner、entrylist、waitset</li><li>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</li></ul><br><hr><h3 id="2-Java内存模型-JMV"><a href="#2-Java内存模型-JMV" class="headerlink" title="2. Java内存模型(JMV)"></a>2. Java内存模型(JMV)</h3><p>JMM(Java Memory Model)Java内存模型，定义了<font color="red">共享内存</font>中<font color="red">多线程程序读写操作</font>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009113241.png" style="zoom:67%;"></p><br><p><strong>总结</strong></p><ul><li>JMM(Java Memory Model)Java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li><li>JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</li><li>线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存</li></ul><br><hr><h3 id="3-CAS"><a href="#3-CAS" class="headerlink" title="3. CAS"></a>3. CAS</h3><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性<br>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p><br><p><strong>CAS</strong></p><ul><li>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</li><li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li><li>在操作共享变量的时候使用的自旋锁，效率上更高一些</li><li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li></ul><br><p><strong>乐观锁和悲观锁的区别</strong></p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li></ul><br><hr><h3 id="4-对volatile的理解"><a href="#4-对volatile的理解" class="headerlink" title="4. 对volatile的理解"></a>4. 对volatile的理解</h3><p>volatile是Java提供的一种轻量级的同步机制。Java语言包含两种内在的同步机制：同步块（方法）和volatile变量，相比于synchronized,volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile变量的同步性较差，而且其使用也更容易出错</p><ul><li>保证线程间的可见性<br>用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li><li>禁止进行指令重排序<br>指令重排：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li></ul><br><hr><h3 id="5-什么是AQS"><a href="#5-什么是AQS" class="headerlink" title="5. 什么是AQS"></a>5. 什么是AQS</h3><p>全称是 AbstractQueuedSynchronizer，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架</p><p>AQS与Synchronized的区别</p><table><thead><tr><th><strong>synchronized</strong></th><th><strong>AQS</strong></th></tr></thead><tbody><tr><td>关键字，c++ 语言实现</td><td>java  语言实现</td></tr><tr><td>悲观锁，自动释放锁</td><td>悲观锁，手动开启和关闭</td></tr><tr><td>锁竞争激烈都是重量级锁，性能差</td><td>锁竞争激烈的情况下，提供了多种解决方案</td></tr></tbody></table><br><p>AQS常见的实现类：</p><ul><li>ReentrantLock      阻塞式锁</li><li>Semaphore        信号量</li><li>CountDownLatch   倒计时锁</li></ul><br><p><strong>AQS是公平锁还是非公平锁</strong></p><ul><li>新的线程与队列中的线程共同来抢资源，是非公平锁</li><li>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</li></ul><br><p><strong>什么是AQS</strong></p><ul><li>是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li><li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li><li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li><li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li></ul><br><hr><h3 id="6-ReentrantLock的实现原理"><a href="#6-ReentrantLock的实现原理" class="headerlink" title="6. ReentrantLock的实现原理"></a>6. ReentrantLock的实现原理</h3><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置公平锁</li><li>支持多个条件变量</li><li>与synchronized一样，都支持重入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建锁对象</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    lock.lock();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><br><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似<br>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量</p><p>查看ReentrantLock源码中的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009133842.png" style="zoom:67%;"><ul><li>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</li><li>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</li><li>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</li><li>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</li></ul><br><p><strong>总结</strong></p><ul><li>ReentrantLock表示支持重新进入的锁，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞</li><li>ReentrantLock主要利用CAS+AQS队列来实现</li><li>支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁</li></ul><br><hr><h3 id="7-synchronized和Lock有什么区别"><a href="#7-synchronized和Lock有什么区别" class="headerlink" title="7. synchronized和Lock有什么区别"></a>7. synchronized和Lock有什么区别</h3><ul><li><p>语法层面</p><p>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现<br>Lock 是接口，源码由 jdk 提供，用 java 语言实现<br>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</p></li><li><p>功能层面</p><p>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能<br>Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变<br>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁)</p></li><li><p>性能层面</p><p>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖<br>在竞争激烈时，Lock 的实现通常会提供更好的性能</p></li></ul><br><hr><h3 id="8-死锁产生的条件"><a href="#8-死锁产生的条件" class="headerlink" title="8. 死锁产生的条件"></a>8. 死锁产生的条件</h3><p>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁</p><p><strong>如何进行死锁诊断</strong></p><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p><ul><li>jps：输出JVM中运行的进程状态信息</li><li>jstack：查看java进程内线程的堆栈信息</li></ul><p>可视化工具</p><ul><li><p>jconsole</p><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具<br>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p></li><li><p>VisuaIVM</p><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈<br>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p></li></ul><br><p><strong>总结</strong></p><ol><li><p>死锁产生的条件是什么？</p><p>一个线程需要同时获取多把锁，这时就容易发生死锁</p></li><li><p>如何进行死锁诊断？</p><ul><li>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</li><li>jps：输出JVM中运行的进程状态信息</li><li>jstack：查看java进程内线程的堆栈信息，查看日志，检查是否有死锁如果有死锁现象，需要查看具体代码分析后，可修复</li><li>可视化工具jconsole、VisualVM也可以检查死锁问题</li></ul></li></ol><br><hr><h3 id="9-ConcurrentHashMap"><a href="#9-ConcurrentHashMap" class="headerlink" title="9. ConcurrentHashMap"></a>9. ConcurrentHashMap</h3><p>ConcurrentHashMap 是一种线程安全的高效Map集合<br>底层数据结构：</p><ul><li>JDK1.7底层采用分段的数组+链表实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li></ul><br><p><strong>JDK1.7中的ConcurrentHashMap</strong></p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009140109.png" style="zoom:67%;"><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009140127.png" style="zoom: 67%;"><br><p><strong>JDK1.8中的ConcurrentHashMap</strong></p><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表<br>采用 CAS + Synchronized来保证并发安全进行实现</p><ul><li>CAS控制数组节点的添加</li><li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</li></ul><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009140142.png" style="zoom:67%;"><br><p><strong>总结</strong></p><p>聊一下ConcurrentHashMap</p><ol><li>底层数据结构<ul><li>JDK1.7底层采用分段的数组+链表实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</li></ul></li><li>加锁的方式<ul><li>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock</li><li>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</li></ul></li></ol><br><hr><h3 id="10-导致并发程序出现问题的根本原因是什么"><a href="#10-导致并发程序出现问题的根本原因是什么" class="headerlink" title="10. 导致并发程序出现问题的根本原因是什么"></a>10. 导致并发程序出现问题的根本原因是什么</h3><p>Java并发编程三大特性</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><br><p><strong>原子性：</strong>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p><p>不是原子操作，怎么保证原子操作？</p><ol><li>synchronized: 同步锁</li><li>JUC里面的lock: 加锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTicket</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到一张票,剩余:&quot;</span>+ticketNum);<br>    <span class="hljs-comment">// 非原子性操作</span><br>    ticketNum--;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">TicketDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketDemo</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(demo::getTicket).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>内存可见性：</strong>让一个线程对共享变量的修改对另一个线程可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(!flag)&#123;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第一个线程执行完毕...&quot;</span>);<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>           System.out.println(<span class="hljs-string">&quot;第二线程执行完毕...&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方案：</p><ul><li>synchronized</li><li>volatile</li><li>LOCK</li></ul><br><p><strong>有序性</strong></p><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p><p>解决方案：volatile</p><br><hr><h2 id="三-线程池"><a href="#三-线程池" class="headerlink" title="三. 线程池"></a>三. 线程池</h2><h3 id="1-线程池的核心参数"><a href="#1-线程池的核心参数" class="headerlink" title="1. 线程池的核心参数"></a>1. 线程池的核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目</li><li>maximumPoolSize 最大线程数目 &#x3D; (核心线程+救急线程的最大数目)</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</li></ul><br><hr><h3 id="2-线程池的执行原理"><a href="#2-线程池的执行原理" class="headerlink" title="2. 线程池的执行原理"></a>2. 线程池的执行原理</h3><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009142041.png" style="zoom:80%;"><ol><li>AbortPolicy：直接抛出异常，默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ol><p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p><br><hr><h3 id="3-线程池中有哪些常见的阻塞队列"><a href="#3-线程池中有哪些常见的阻塞队列" class="headerlink" title="3. 线程池中有哪些常见的阻塞队列"></a>3. 线程池中有哪些常见的阻塞队列</h3><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p><ol><li><font color="red">ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO</font></li><li><font color="red">LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO</font></li><li>DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</li><li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li></ol><br><p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p><table><thead><tr><th><strong>LinkedBlockingQueue</strong></th><th><strong>ArrayBlockingQueue</strong></th></tr></thead><tbody><tr><td>默认无界，支持有界</td><td>强制有界</td></tr><tr><td>底层是链表</td><td>底层是数组</td></tr><tr><td>是懒惰的，创建节点的时候添加数据</td><td>提前初始化 Node  数组</td></tr><tr><td>入队会生成新 Node</td><td>Node需要是提前创建好的</td></tr><tr><td>两把锁（头尾）</td><td>一把锁</td></tr></tbody></table><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009142425.png" style="zoom: 67%;"><br><hr><h3 id="4-如何确定核心线程数"><a href="#4-如何确定核心线程数" class="headerlink" title="4. 如何确定核心线程数"></a>4. 如何确定核心线程数</h3><ul><li><p>IO密集型任务</p><p>一般来说：文件读写、DB读写、网络请求等<font color="red">核心线程数大小设置为2N+1</font>.</p></li><li><p>CPU密集型任务</p><p>一般来说：计算型代码、Bitmap转换、Gson转换等<font color="red">核心线程数大小设置为N+1</font></p></li></ul><p>查看机器的CPU核心数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//查看机器的CPU核数</span><br>    System.out.println(Runtime.getRuntime().availableProcessors());<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>参考回答</strong></p><ol><li>高并发、任务执行时间短 à（ CPU核数+1 ），减少线程上下文的切换</li><li>并发不高、任务执行时间长<ul><li>IO密集型的任务 à (CPU核数 * 2 + 1)</li><li>计算密集型任务 à（ CPU核数+1 ）</li></ul></li><li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步</li></ol><br><hr><h3 id="5-线程池的种类有哪些"><a href="#5-线程池的种类有哪些" class="headerlink" title="5. 线程池的种类有哪些"></a>5. 线程池的种类有哪些</h3><p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p><ol><li><p>创建使用固定线程数的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数与最大线程数一样，没有救急线程</li><li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li></ul><p><font color="red">适用于任务量已知，相对耗时的任务</font></p><br></li><li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数和最大线程数都是1</li><li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li></ul><p><font color="red">适用于按照顺序执行的任务</font></p><br></li><li><p>可缓存线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数为0</li><li>最大线程数是Integer.MAX_VALUE</li><li>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li></ul><p><font color="red">适合任务数比较密集，但每个任务执行时间较短的情况</font></p><br></li><li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                     RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><br></li></ol><p><strong>总结</strong></p><ol><li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li><li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</li><li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li><li>newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行</li></ol><br><hr><h3 id="6-为什么不建议使用Executors创建线程池"><a href="#6-为什么不建议使用Executors创建线程池" class="headerlink" title="6. 为什么不建议使用Executors创建线程池"></a>6. 为什么不建议使用Executors创建线程池</h3><p>参考阿里开发手册《Java开发手册-嵩山版》<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009145736.png" style="zoom:67%;"></p><br><hr><h2 id="四-使用场景"><a href="#四-使用场景" class="headerlink" title="四. 使用场景"></a>四. 使用场景</h2><h3 id="1-哪些地方用到了多线程"><a href="#1-哪些地方用到了多线程" class="headerlink" title="1. 哪些地方用到了多线程"></a>1. 哪些地方用到了多线程</h3><p><strong>CountDownLatch</strong></p><p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p><ul><li>其中构造参数用来初始化等待计数值</li><li>await() 用来等待计数归零</li><li>countDown() 用来让计数减一</li></ul><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009150909.png" style="zoom:67%;"><br><p><strong>多线程使用场景一（es数据批量导入）</strong></p><p>在项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151024.png" style="zoom:67%;"><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151042.png" style="zoom:67%;"><br><p><strong>多线程使用场景二 （数据汇总）</strong></p><p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151105.png" style="zoom:67%;"><br><ul><li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</li><li>报表汇总<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151124.png" style="zoom: 67%;"></li></ul><br><p><strong>多线程使用场景三（异步调用）</strong></p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151146.png" style="zoom:67%;"><br><p><strong>总结</strong></p><ul><li><font color="red">批量导入</font>：使用了线程池+CountDownLatch批量把数据库中的数据导入到了ES(任意)中，避免OOM</li><li><font color="red">数据汇总</font>：调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</li><li><font color="red">异步线程（线程池）</font>：为了避免下一级方法影响上一级方法（性能考虑），可使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间</li></ul><br><hr><h3 id="2-如何控制某个方法允许并发访问线程的数量"><a href="#2-如何控制某个方法允许并发访问线程的数量" class="headerlink" title="2. 如何控制某个方法允许并发访问线程的数量"></a>2. 如何控制某个方法允许并发访问线程的数量</h3><p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量<br>使用场景：<br>通常用于那些资源有明确访问数量限制的场景，常用于限流 。</p><p><strong>使用步骤</strong></p><ul><li>创建Semaphore对象，可以给一个容量</li><li>semaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</li><li>semaphore.release()：释放一个信号量，此时信号量个数+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 semaphore 对象</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 10个线程同时运行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 3. 获取许可</span><br>        semaphore.acquire();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 4. 释放许可</span><br>        semaphore.release();<br>    &#125;<br>&#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>总结</strong></p><p>在多线程中提供了一个工具类Semaphore，信号量。在并发的情况下，可以控制方法的访问量</p><ol><li>创建Semaphore对象，可以给一个容量</li><li>acquire()可以请求一个信号量，这时候的信号量个数-1</li><li>release()释放一个信号量，此时信号量个数+1</li></ol><br><hr><h3 id="3-对ThreadLocal的理解"><a href="#3-对ThreadLocal的理解" class="headerlink" title="3. 对ThreadLocal的理解"></a>3. 对ThreadLocal的理解</h3><p><strong>ThreadLocal的概述</strong></p><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p><p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009152025.png" style="zoom: 67%;"></p><br><p><strong>ThreadLocal的基本使用</strong></p><ul><li>set(value) 设置值</li><li>get() 获取值</li><li>remove() 清除值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        threadLocal.set(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        print(name);<br>        System.out.println(name + <span class="hljs-string">&quot;-after remove : &quot;</span> + threadLocal.get());<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        threadLocal.set(<span class="hljs-string">&quot;itheima&quot;</span>);<br>        print(name);<br>        System.out.println(name + <span class="hljs-string">&quot;-after remove : &quot;</span> + threadLocal.get());<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>    System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + threadLocal.get());<br>    <span class="hljs-comment">//清除本地内存中的本地变量</span><br>    threadLocal.remove();<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>ThreadLocal的实现原理和源码分析</strong></p><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009152048.png" style="zoom:80%;"></p><br><p><strong>set方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//根据当前线程对象，获取ThreadLocal中的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//如果map存在</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//执行map中的set方法，进行数据存储</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//否则创建ThreadLocalMap，并存值</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-comment">//位运算，结果与取模相同，计算出需要存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>get方法&#x2F;remove方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//根据线程对象，获取对应的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//获取ThreadLocalMap中对应的Entry对象</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">//获取Entry中的value</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">//确定数组下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//得到该位置上的Entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>ThreadLocal内存泄漏问题</strong></p><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p><ul><li><p>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure></li><li><p>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(user);<br></code></pre></td></tr></table></figure></li></ul><br><p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009152817.png" style="zoom: 67%;"></p><br><p><strong>总结</strong></p><ol><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li><li>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象<ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul></li><li>ThreadLocal内存泄漏问题</li></ol><p>ThreadLocalMap 中的 key 是弱引用，值为强引用； key 会被GC 释放内存，关联 value 的内存并不会释放。建议主动 remove 释放 key，value</p>]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息中间件面试题</title>
    <link href="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="消息中间件面试题"><a href="#消息中间件面试题" class="headerlink" title="消息中间件面试题"></a>消息中间件面试题</h2><p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png" style="zoom:80%;"><br><hr><h2 id="一-RabbitMQ"><a href="#一-RabbitMQ" class="headerlink" title="一. RabbitMQ"></a>一. RabbitMQ</h2><h3 id="1-RabbitMQ如何保证消息不丢失"><a href="#1-RabbitMQ如何保证消息不丢失" class="headerlink" title="1. RabbitMQ如何保证消息不丢失"></a>1. RabbitMQ如何保证消息不丢失</h3><ul><li>异步发送（验证码、短信、邮件…）</li><li>MYSQL和Redis , ES之间的数据同步</li><li>分布式事务</li><li>削峰填谷</li><li>…</li></ul><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png" style="zoom:80%;"><br><p><strong>生产者确认机制</strong></p><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png" style="zoom:80%;"><p>消息失败之后的处理方法</p><ul><li>回调日志及时重新发送</li><li>记录日志</li><li>保存到数据库然后定时重新发送，成功发送后即刻删除表中的数据</li></ul><br><p><strong>消息持久化</strong></p><p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p><ol><li><p>交换机持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>队列持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 使用QueueBuilder构建队列，durable就是持久化的</span><br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>).build();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消息持久化，SpringAMQP中的消息默认是成就的，可以通过MessageProperties中的DeliveryMode来指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化 </span><br>    .build();<br></code></pre></td></tr></table></figure></li></ol><br><p><strong>消费者确认</strong></p><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：</p><ul><li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li><li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li><li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li></ul><p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png" style="zoom: 67%;"><br><p><strong>RabbitMQ如何保证消息不丢失？</strong></p><ul><li>开启生产者确认机制，确保生产者的消息能到达队列</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li><li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png"><br><hr><h3 id="2-RabbitMQ消息的重复消费问题"><a href="#2-RabbitMQ消息的重复消费问题" class="headerlink" title="2. RabbitMQ消息的重复消费问题"></a>2. RabbitMQ消息的重复消费问题</h3><ul><li>网络抖动</li><li>消费者挂了</li></ul><p>都可能出现出现消费问题</p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png" style="zoom:67%;"><p>解决方案：</p><ul><li>每条消息设置一个唯一的标识id</li><li>幂等方案：分布式锁、数据库锁（乐观锁、悲观锁）</li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png"><br><hr><h3 id="3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列"><a href="#3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列" class="headerlink" title="3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)"></a>3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)</h3><ul><li>延迟队列：进入队列的消息会被延迟消费的队列</li><li>场景：超时订单、限时优惠、定时发布</li></ul><p><font color="red">延迟队列 &#x3D; 死信交换机 + TTL</font></p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png" style="zoom:67%;"><br><p><strong>死信交换机</strong></p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul><p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">ttlQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>) <span class="hljs-comment">// 指定队列名称，并持久化</span><br>        .ttl(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置队列的超时时间，10秒</span><br>        .deadLetterExchange(<span class="hljs-string">&quot;dl.direct&quot;</span>) <span class="hljs-comment">// 指定死信交换机</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png" style="zoom:67%;"><br><p><strong>TTL</strong></p><p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况:</p><ul><li>消息所在的队列设置了存活时间</li><li>消息本身设置了存活时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello, ttl message&quot;</span>).getBytes(StandardCharsets.UTF_8)<br>    .setExpiration(<span class="hljs-string">&quot;500&quot;</span>)<br>    .build();<br><span class="hljs-comment">// 消息Id，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png" style="zoom:67%;"><br><p><strong>延迟队列插件</strong></p><p>DelayExchange插件，需要安装在RabbitMQ中</p><p>RabbitMQ有一个官方的插件社区，地址为：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> </p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png" style="zoom:50%;"><p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindinds = @QueueBinding(</span><br><span class="hljs-meta">value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">    key = &quot;delay&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayedQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>log.info(<span class="hljs-string">&quot;接收到 delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello,delayed message&quot;</span>.getBytes(StandardCharsets.UTF_8))<br>    .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">10000</span>)<br>    .build();<br><span class="hljs-comment">// 消息ID，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure><br><p><strong>RabbitMQ中死信交换机？（RabbitMQ延迟队列有了解过吗？）</strong></p><ul><li><p>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布…）</p></li><li><p>其中延迟队列就用到了死信交换机和TTL（消息存活时间）实现的</p></li><li><p>消息超时未消费就会变成死信（死信的其他情况：拒绝被消费，队列满了）</p><p> 延迟队列插件实现延迟队列DelayExchange</p></li><li><p>声明一个交换机，添加delayed属性为true</p></li><li><p>发送消息时，添加x-delay头，值为超时时间</p></li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png" style="zoom:80%;"><br><hr><h3 id="4-消息堆积怎么解决"><a href="#4-消息堆积怎么解决" class="headerlink" title="4. 消息堆积怎么解决"></a>4. 消息堆积怎么解决</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p><p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png"></p><p>解决消费堆积问题有三种思路：</p><ul><li>增加更多的消费者，提高消费速度</li><li>在消费者内开启线程，也加快消费者的处理速度</li><li>扩大队列容积，提高堆积上限</li></ul><br><p><strong>惰性队列</strong></p><p>惰性队列的特征：</p><ul><li>接收到消息之后直接存入磁盘而非内存中</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">lazyQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(lazy.queue)<br>        .lazy()<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(</span><br><span class="hljs-meta">    name = &quot;lzay.queue&quot;,</span><br><span class="hljs-meta">    durable = &quot;true&quot;,</span><br><span class="hljs-meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenLazyQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>log.info(<span class="hljs-string">&quot;接收到 lazy.queue的消息:&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决）</strong></p><p>解决消息堆积有三种种思路：</p><ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限，采用惰性队列<ul><li>在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列</li><li>基于磁盘存储，消息上限高</li><li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li></ul></li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png" style="zoom:80%;"><br><hr><h3 id="5-RabbitMQ的高可用机制"><a href="#5-RabbitMQ的高可用机制" class="headerlink" title="5. RabbitMQ的高可用机制"></a>5. RabbitMQ的高可用机制</h3><ul><li>在生产环境下，使用集群来保证高可用性</li><li>普通集群、镜像集群、仲裁集群</li></ul><br><p><strong>普通集群</strong></p><p>普通集群，或者叫标准集群，具备下列特征：</p><ul><li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li><li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li><li>队列所在节点宕机，队列中的消息就会丢失</li></ul><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png" style="zoom: 67%;"><br><p><strong>镜像集群</strong></p><p>镜像集群：本质是主从模式，具备下面的特征：</p><ul><li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li><li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li><li>一个队列的主节点可能是另一个队列的镜像节点</li><li>所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主</li></ul><p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png"></p><br><p><strong>仲裁集群</strong></p><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p><ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">quorumQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(<span class="hljs-string">&quot;quorumqueue&quot;</span>) <span class="hljs-comment">// 持久化</span><br>        .quorum() <span class="hljs-comment">// 仲裁队列</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>RabbitMQ的高可用机制有了解过吗？</strong></p><ul><li>在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点</li><li>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li></ul><br><p><strong>那么出现丢数据怎么解决？</strong></p><p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。<br>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png" style="zoom:80%;"><br><hr><h2 id="二-Kafka"><a href="#二-Kafka" class="headerlink" title="二. Kafka"></a>二. Kafka</h2><h3 id="1-Kafka是如何保证消息不丢失"><a href="#1-Kafka是如何保证消息不丢失" class="headerlink" title="1. Kafka是如何保证消息不丢失"></a>1. Kafka是如何保证消息不丢失</h3><p>使用Kafka在消息的收发过程都会出现消息丢失 , Kafka分别给出了解决方案</p><ul><li>生产者发送消息到Brocker丢失</li><li>消息在Brocker中存储丢失</li><li>消费者从Brocker接收消息丢失</li></ul><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png" style="zoom:67%;"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步发送</span><br><span class="hljs-type">RecordMetadata</span> <span class="hljs-variable">recordMetadata</span> <span class="hljs-operator">=</span> kafkaProducer.send(record).get();<br><span class="hljs-comment">//异步发送</span><br>kafkaProducer.send(record, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息发送失败 | 记录日志&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> recordMetadata.offset();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> recordMetadata.partition();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> recordMetadata.topic();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置重试次数</span><br>prop.put(ProducerConfig.RETRIES_CONFIG,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png" style="zoom: 80%;"><br><table><thead><tr><th><strong>确认机制</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>acks&#x3D;0</td><td>生产者在成功写入消息之前不会等待任何来自服务器的响应,消息有丢失的风险，但是速度最快</td></tr><tr><td>acks&#x3D;1（默认值）</td><td>只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应</td></tr><tr><td>acks&#x3D;all</td><td>只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应</td></tr></tbody></table><br><p><strong>消费者从Brocker接受消息丢失</strong></p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png" style="zoom:67%;"><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png" style="zoom:67%;"><p>禁用自动提交偏移量，改为手动</p><ul><li>同步提交</li><li>异步提交</li><li>同步+异步组合提交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>        <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>            System.outprintln(record.value());<br>            System.outprintln(record.key());<br>        &#125;<br>        consumer.commitAsync();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;记录错误消息: &quot;</span> + e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        consumer.commitSync();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        consumer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>Kafka是如何保证消息不丢失?</strong></p><p>需要从三个层面去解决这个问题：</p><ul><li><p>生产者发送消息到Brocker丢失</p><ul><li>设置异步发送，发送失败使用回调进行记录或重发</li><li>失败重试，参数配置，可以设置重试次数</li></ul></li><li><p>消息在Brocker中存储丢失</p><p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p></li><li><p>消费者从Brocker接收消息丢失</p><ul><li>关闭自动提交偏移量，开启手动提交偏移量</li><li>提交方式，最好是同步+异步提交</li></ul></li></ul><br><p><strong>Kafka中消息的重复消费问题如何解决的</strong></p><ul><li>关闭自动提交偏移量，开启手动提交偏移量</li><li>提交方式，最好是同步+异步提交</li><li>幂等方案</li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png" style="zoom:80%;"><br><hr><h3 id="2-Kafka是如何保证消费的顺序性"><a href="#2-Kafka是如何保证消费的顺序性" class="headerlink" title="2. Kafka是如何保证消费的顺序性"></a>2. Kafka是如何保证消费的顺序性</h3><p>应用场景</p><ul><li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li><li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序</li></ul><br><p><strong>消费者从Brocker接收消息丢失</strong></p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png" style="zoom: 80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定分区</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br><span class="hljs-comment">// 相同的业务key</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br></code></pre></td></tr></table></figure><p>topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p><br><p><strong>Kafka是如何保证消费的顺序性？</strong></p><p>问题原因：<br>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p><p>解决方案：</p><ul><li>发送消息时指定分区号</li><li>发送消息时按照相同的业务设置相同的key</li></ul><br><p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png"></p><br><hr><h3 id="3-Kafka的高可用机制"><a href="#3-Kafka的高可用机制" class="headerlink" title="3. Kafka的高可用机制"></a>3. Kafka的高可用机制</h3><ul><li>集群模式</li><li>分区备份机制</li></ul><br><p><strong>集群模式</strong></p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png" style="zoom:67%;"><ul><li>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成</li><li>这样如果集群中某一台机器宕机，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一</li></ul><br><p><strong>分区备份机制</strong></p><p>某个topic中有三个分区P0、P1、P2</p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png" style="zoom:67%;"><ul><li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的broker中</li><li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader</li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png" style="zoom:67%;"><p>ISR（in-sync replica）需要同步复制保存的follower</p><p>如果leader失效后，需要选出新的leader，选举的原则如下：</p><ol><li>选举时优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</li><li>如果ISR列表中的follower都不行了，就只能从其他follower中选取</li></ol><br><p><strong>Kafka的高可用机制有了解过吗？</strong></p><p>可以从两个层面回答，第一个是集群，第二个是复制机制<br><strong>集群：</strong><br>一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务<br><strong>复制机制：</strong></p><ul><li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li><li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li></ul><br><p><strong>解释一下复制机制中的ISR</strong></p><p>ISR（in-sync replica）需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png" style="zoom:80%;"><br><hr><h3 id="4-Kafka数据清理机制"><a href="#4-Kafka数据清理机制" class="headerlink" title="4. Kafka数据清理机制"></a>4. Kafka数据清理机制</h3><ul><li>Kafka文件存储机制</li><li>数据清理机制</li></ul><br><p><strong>Kafka文件存储机制</strong></p><p>存储结构</p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png" style="zoom:67%;"><p>为什么要分段？</p><ul><li>删除无用文件方便，提高磁盘利用率</li><li>查找数据便捷</li></ul><br><p><strong>数据清理机制</strong></p><p>日志的清理策略有两</p><ol><li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程</li><li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。需手动开启</li></ol><br><p><strong>Kafka存储结构</strong></p><ul><li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li><li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储</li><li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li></ul><p><strong>日志的清理策略有两个</strong>：</p><ul><li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</li><li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png" style="zoom: 80%;"><br><hr><h3 id="5-Kafka中实现高性能的设计"><a href="#5-Kafka中实现高性能的设计" class="headerlink" title="5. Kafka中实现高性能的设计"></a>5. Kafka中实现高性能的设计</h3><ul><li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li><li>顺序读写：磁盘顺序读写，提升读写效率</li><li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访</li><li>l零拷贝：减少上下文切换及数据拷贝</li><li>消息压缩：减少磁盘IO和网络IO</li><li>分批发送：将消息打包批量发送，减少网络开销</li></ul><br><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合面试题</title>
    <link href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005170605.png" style="zoom:80%;"><br><hr><h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一. 数组"></a>一. 数组</h2><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005173522.png" style="zoom: 80%;"><br><hr><h3 id="1-算法复杂度分析"><a href="#1-算法复杂度分析" class="headerlink" title="1. 算法复杂度分析"></a>1. 算法复杂度分析</h3><p><strong>时间复杂度：</strong> 用来评估代码的执行耗时</p><ul><li>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong></li><li>T(n)与代码的执行次数成正比(<strong>代码行数越多，执行时间越长</strong>)</li><li>当n很大时，公式中的低阶，常量，系数三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</li></ul><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005171736.png" style="zoom:67%;"><br><p><strong>常见复杂度</strong></p><p>只要代码的执行时间不随着n的变化而变化，这样的代码时间复杂度就是O(1)，下面的两个例子的时间复杂度都是O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> i+j;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>        sum = sum+i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure><br><p>时间复杂度为O(n)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sum = sum + i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>时间复杂度为O(n^2):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            sum = sum +  i * j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>时间复杂度为O(log n):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        i = i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>时间复杂度为O(n * log n):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test05</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;i&lt;=n;i++)&#123;<br>       test04(n);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        i = i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>空间复杂度</strong></p><p>空间复杂度全称是<font color="red">渐进空间复杂度</font>，表示算法占用的额外<font color="red">存储空间</font>与<font color="red">数据规模之间</font>的增长关系<br>我们常见的空间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p><br><hr><h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h3><p>数组（Array）是一种用<font color="red">连续的内存空间</font>存储<font color="red">相同数据类型</font>数据的线性数据结构</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005173852.png" style="zoom:80%;"><br><p><strong>数组如何获得其它元素的地址？</strong></p><p>寻址公式：a[i] &#x3D; baseAddress + i * dataTypeSize</p><ul><li>baseAddress： 数组的首地址</li><li>dataTypeSize：代表数组中元素类型的大小，int型的数据，dataTypeSize&#x3D;4个字节</li></ul><br><p><strong>为什么数组的索引从0开始而不是从1开始？</strong></p><ul><li>索引从0开始的寻址公式：a[i] &#x3D; baseAddress + i * dataTypeSize</li><li>索引从1开始的寻址公式：a[i] &#x3D; baseAddress +（ i  - 1 ）* dataTypeSize</li><li>在根据数组索引获取元素的时候，会用索引和寻址公式来计算内存所对应的元素数据，寻址公式是：数组的首地址+索引乘以存储数据的类型大小</li><li>如果数组的索引从1开始，寻址公式中，就需要增加一次减法操作，对于CPU来说就多了一次指令，性能不高。</li></ul><br><hr><h3 id="3-操作数组的时间复杂度"><a href="#3-操作数组的时间复杂度" class="headerlink" title="3. 操作数组的时间复杂度"></a>3. 操作数组的时间复杂度</h3><ul><li><p><strong>随机查询（根据索引查询）</strong></p><p>数组元素的访问是通过下标来访问的，计算机通过数组的首地址和寻址公式能够很快速的找到想要访问的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> a[i];<br>    <span class="hljs-comment">// a[i] = baseAddress + i * dataSize</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>未知索引查询</strong></p><ul><li><p>情况一：查找数组内的元素，查找55号数据</p><p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005221650.png"></p></li><li><p>情况二：查找<font color="red">排序后</font>数组内的元素，查找55号数据</p><p>​<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005221904.png" style="zoom:80%;"></p></li></ul></li><li><p><strong>插入、删除</strong></p><p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。<font color="red">最好情况下是O(1)的，最坏情况下是O(n)的，平均情况下的时间复杂度是O(n)</font></p></li></ul><br><hr><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li><p>数组（Array）是一种用连续的内存空间存储相同数据类型数据的线性数据结构</p></li><li><p>数组下标为什么从0开始</p><p>寻址公式是：baseAddress+ i * dataTypeSize，计算下标的内存地址效率较高</p></li><li><p>查找的时间复杂度</p><ul><li><p>随机(通过下标)查询的时间复杂度是O(1)</p></li><li><p>查找元素（未知下标）的时间复杂度是O(n)</p></li><li><p>查找元素（未知下标但排序）通过二分查找的时间复杂度是O(log n)</p></li></ul></li><li><p>插入和删除时间复杂度</p><p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均时间复杂度为O(n)</p></li></ol><br><hr><h2 id="二-List"><a href="#二-List" class="headerlink" title="二. List"></a>二. List</h2><p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005222728.png"></p><br><hr><h3 id="1-ArrayList源码分析"><a href="#1-ArrayList源码分析" class="headerlink" title="1. ArrayList源码分析"></a>1. ArrayList源码分析</h3><p><font face="仿宋">以下源码都来自jdk1.8</font></p><p><strong>成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 默认初始的容量(CAPACITY)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于空实例的共享空数组实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于默认大小的空实例的共享空数组实例。</span><br><span class="hljs-comment">* 我们将其与 EMPTY_ELEMENTDATA 区分开来，以了解添加第一个元素时要膨胀多少</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 存储 ArrayList 元素的数组缓冲区。 ArrayList 的容量就是这个数组缓冲区的长度。</span><br><span class="hljs-comment">* 当添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList</span><br><span class="hljs-comment">* 都将扩展为 DEFAULT_CAPACITY</span><br><span class="hljs-comment"> * 当前对象不参与序列化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ArrayList 的大小（它包含的元素数量）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><br><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = a.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c.getClass() == ArrayList.class) &#123;<br>            elementData = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            elementData = Arrays.copyOf(a, size, Object[].class);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>添加和扩容操作</strong></p><p>第1次添加数据</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006151913.png"><br><p>第2-10次添加数据</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006152257.png" style="zoom:80%;"><br><p>第11次添加数据</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006152352.png" style="zoom:80%;"><br><hr><h3 id="2-ArrayList底层的实现原理"><a href="#2-ArrayList底层的实现原理" class="headerlink" title="2. ArrayList底层的实现原理"></a>2. ArrayList底层的实现原理</h3><ul><li><p>底层数据结构</p><p>ArrayList底层是用动态数组来实现的</p></li><li><p>初始容量</p><p>ArrayList初始容量为0，当第一次添加数据时才会初始化容量为10</p></li><li><p>扩容逻辑</p><p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p></li><li><p>添加逻辑</p><ul><li>确保数组已使用长度（size）加1之后足够存下下一个数据 </li><li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</li><li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</li><li>返回添加成功布尔值。</li></ul></li></ul><br><p><strong>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构造一个具有指定初始容量的空列表。</span><br><span class="hljs-comment">* 参数：initialCapacity - 列表的初始容量</span><br><span class="hljs-comment">* 抛出：IllegalArgumentException – 如果指定的初始容量为负</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容 </p><br><hr><h3 id="3-如何实现数组和List之间的转换"><a href="#3-如何实现数组和List之间的转换" class="headerlink" title="3. 如何实现数组和List之间的转换"></a>3. 如何实现数组和List之间的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组转List</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testArray2List</span><span class="hljs-params">()</span>&#123;<br>    String[] strs = &#123;<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-string">&quot;ccc&quot;</span>&#125;;<br>    List&lt;String&gt; list = Arrays.asList(strs);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//List转数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList2Array</span><span class="hljs-params">()</span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>    String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[list.size()]);<br>    <span class="hljs-keyword">for</span> (String s : array) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组转List ，使用JDK中java.util.Arrays工具类的asList()方法</li><li>List转数组，使用List的toArray()方法。无参toArray()方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</li></ul><br><p><strong>用Arrays.asList转List后，如果修改了数组内容，list受影响吗?</strong></p><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p><br><p><strong>List用toArray转数组后，如果修改了List内容，数组受影响吗？</strong></p><p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><br><hr><h3 id="4-单向链表"><a href="#4-单向链表" class="headerlink" title="4. 单向链表"></a>4. 单向链表</h3><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154119.png" style="zoom:80%;"><ul><li>链表中的每一个元素称之为<font color="red">结点</font></li><li>物理<font color="red">存储单元上、非连接、非连续</font>的存储结构</li><li>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作<font color="red">后继指针next</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node(E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>单向链表时间复杂度分析</strong></p><ul><li><p>查询操作</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154635.png" style="zoom:80%;"><ul><li>只有在查询头节点的时候不需要遍历链表，时间复杂度是O(1)</li><li>查询其他结点需要遍历链表，时间复杂度是O(n)</li></ul></li><li><p>增删操作</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154756.png" style="zoom:80%;"><ul><li>只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是O(1)</li><li>添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是O(n)</li></ul></li></ul><br><hr><h3 id="5-双向链表"><a href="#5-双向链表" class="headerlink" title="5. 双向链表"></a>5. 双向链表</h3><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154953.png" style="zoom:80%;"><p>双向链表，顾名思义它支持两个方向：</p><ul><li>每个结点不止有一个后继指针next指向后面的结点</li><li>有一个前驱指针prev指向前面的结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相对于单向链表</p><ul><li>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</li><li>支持双向遍历，这样也带来了双向链表操作的灵活性</li></ul><bt><p><strong>双向链表的时间复杂度分析</strong></p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006155521.png" style="zoom:80%;"><p>查询操作：</p><ul><li>查询头尾结点的时间复杂度是O(1)</li><li>平均的查询时间复杂度是O(n)</li><li>给定节点找前驱节点的时间复杂度为O(1)</li></ul><p>增删操作：</p><ul><li>头尾结点增删的时间复杂度为O(1)</li><li>其他部分结点增删的时间复杂度是 O(n)</li><li>给定节点增删的时间复杂度为O(1)</li></ul><br><hr><h3 id="6-链表总结"><a href="#6-链表总结" class="headerlink" title="6. 链表总结"></a>6. 链表总结</h3><ol><li><p>单向链表和双向链表的区别是什么</p><ul><li><p>单向链表只有一个方向，结点只有一个后继指针 next。</p></li><li><p>双向链表它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点</p></li></ul></li><li><p>链表操作数据的时间复杂度是多少</p><table><thead><tr><th></th><th><strong>查询</strong>  、增删</th></tr></thead><tbody><tr><td>单向链表</td><td>头O(1),其他O(n)</td></tr><tr><td>双向链表</td><td>头尾O(1),其他O(n),给定节点O(1)</td></tr></tbody></table></li></ol><br><hr><h3 id="7-ArrayList和LinkedList的区别"><a href="#7-ArrayList和LinkedList的区别" class="headerlink" title="7. ArrayList和LinkedList的区别"></a>7. ArrayList和LinkedList的区别</h3><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006160257.png"><ol><li>底层数据结构<ul><li>ArrayList 是动态数组的数据结构实现</li><li>LinkedList 是双向链表的数据结构实现</li></ul></li><li>操作数据效率<ul><li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li><li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li><li>新增和删除<ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul></li></ul></li><li>内存空间占用<ul><li>ArrayList底层是数组，内存连续，节省内存</li><li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li></ul></li><li>线程安全<ul><li>ArrayList和LinkedList都不是线程安全的</li><li>如果需要保证线程安全，有两种方案：<ul><li>在方法内使用，局部变量则是线程安全的</li><li>使用线程安全的ArrayList和LinkedList</li></ul></li></ul></li></ol><br><hr><h2 id="三-HashMap"><a href="#三-HashMap" class="headerlink" title="三. HashMap"></a>三. HashMap</h2><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007113838.png" style="zoom:80%;"><br><hr><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h3><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<font color="red">左子节点</font>和<font color="red">右子节点</font>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p><p>二叉树每个节点的<font color="red">左子树和右子树也分别满足二叉树的定义</font></p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007114127.png" style="zoom:67%;"><br><p>Java中有两种方式实现二叉树：数组存储和链式存储</p><p>链式存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br>    TreeNode() &#123;&#125;<br>    TreeNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007114657.png" style="zoom: 80%;"><br><p><strong>常见的二叉树有：</strong></p><ul><li>满二叉树</li><li>完全二叉树</li><li>二叉搜索树</li><li>红黑树</li></ul><br><p><strong>二叉搜索树</strong></p><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p><p>二叉查找树要求，在树中的<font color="red">任意一个节点</font>，其<font color="red">左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</font></p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007115721.png" style="zoom:60%;"><br><p><strong>二叉搜索树—时间复杂度</strong></p><p>由于二叉搜索树的形状各异，不同形状的二叉搜索树时间复杂度不同</p><ul><li><p>最好的情况时间复杂度为 O(log n)</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007115738.png" style="zoom:60%;"></li><li><p>最差的情况时间复杂度为 O(n)</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007115800.png" style="zoom:60%;"></li></ul><br><p><strong>总结</strong></p><ol><li>什么是二叉树<ul><li>每个节点最多有两个“叉”，分别是左子节点和右子节点。</li><li>不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</li><li>二叉树每个节点的左子树和右子树也分别满足二叉树的定义</li></ul></li><li>什么是二叉搜索树<ul><li>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树</li><li>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值而右子树节点的值都大于这个节点的值</li><li>没有键值相等的节点</li><li>通常情况下二叉树搜索的时间复杂度为O(log n)</li></ul></li></ol><br><hr><h3 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2. 红黑树"></a>2. 红黑树</h3><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007120809.png" style="zoom:80%;"><br><p><strong>红黑树的特质：</strong></p><ul><li>节点要么是红色，要么是黑色</li><li>根节点的黑色</li><li>叶子节点都是黑色的空节点</li><li>红黑树中红色节点的子节点都是黑色</li><li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li></ul><p>在添加或者删除节点的时候，如果不符合这些性质会发生旋转，以达到所有性质</p><br><p><strong>红黑树的时间复杂度</strong></p><ul><li><p>查找：</p><p>黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</p></li><li><p>添加：</p><p>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)添加完成后涉及到复杂度为O(1)的旋转调整操作</p></li><li><p>删除：</p><p>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)删除完成后涉及到复杂度为O(1)的旋转调整操作故整体复杂度为：O(log n)</p></li></ul><br><hr><h3 id="3-散列表"><a href="#3-散列表" class="headerlink" title="3. 散列表"></a>3. 散列表</h3><p>在HashMap中最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007121821.png" style="zoom:60%;"><br><p>散列表(Hash Table)又名<font color="red">哈希表</font>，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是<font color="red">由数组演化而来</font>的，利用了数组支持按照下标进行随机访问数据的特性</p><p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p><br><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007121922.png" style="zoom: 67%;"><p><font color="red">将键(key)映射为数组下标的函数叫做散列函数。</font>可以表示为：<font color="red">hashValue &#x3D; hash(key)</font></p><p>散列表的基本要求：</p><ul><li>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</li><li>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2）</li><li><strong>如果key1 !&#x3D; key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></li></ul><br><p><strong>散列冲突</strong></p><p>散列冲突（或者哈希碰撞、哈希冲突）就是指<font color="red">多个key映射到同一个数组下标位置</font></p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007121944.png" style="zoom: 67%;"><p>使用链表能有效的解决散列冲突</p><br><p><strong>散列冲突—链表法</strong></p><p>在散列表中，数组的每个下标位置我们可以称之为<font color="red">桶</font>或者<font color="red">槽</font>，每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007122937.png"><p><strong>链表法的时间复杂度</strong></p><ul><li><p>插入操作:</p><p>通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007123248.png" style="zoom: 67%;"></li><li><p>查找、删除操作:</p><p>当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p><ul><li><p>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</p></li><li><p>散列表可能会退化为链表,查询的时间复杂度就从 O(1) 退化为 O(n)</p></li><li><p>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O(log n)</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007123305.png" style="zoom: 67%;"></li></ul></li></ul><p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止<font color="red">DDos攻击</font></p><br><p><strong>总结</strong></p><ol><li>什么是散列表？<ul><li>散列表(Hash Table)又名哈希表&#x2F;Hash表</li><li>根据键（Key）直接访问在内存存储位置值（Value）的数据结构</li><li>由数组演化而来的，利用了数组支持按照下标进行随机访问数据</li></ul></li><li>散列冲突<ul><li>散列冲突又称哈希冲突，哈希碰撞</li><li>指多个key映射到同一个数组下标位置</li></ul></li><li>散列冲突—链表法<ul><li>数组的每个下标位置称之为桶（bucket）或者槽（slot）</li><li>每个桶(槽)会对应一条链表</li><li>hash冲突后的元素都放到相同槽位对应的链表中或红黑树中</li></ul></li></ol><br><hr><h3 id="4-HashMap的实现原理"><a href="#4-HashMap的实现原理" class="headerlink" title="4. HashMap的实现原理"></a>4. HashMap的实现原理</h3><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 </li><li>存储时，如果出现hash值相同的key，此时有两种情况。 <ul><li>如果key相同，则覆盖原始值</li><li>如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中</li></ul></li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007142138.png" style="zoom: 80%;"><br><p><strong>JDK1.7和JDK1.8中HashMap有什么区别？</strong></p><ul><li>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li><li>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</li></ul><br><p><strong>总结</strong></p><ol><li><p>HashMap的实现原理</p><ul><li>底层使用hash表数据结构，即数组+（链表 | 红黑树）</li><li>添加数据时，计算key的值确定元素在数组中的下标<ul><li>key相同则替换</li><li>不同则存入链表或红黑树中</li></ul></li></ul><p>获取数据通过key的hash计算数组下标获取元素</p></li><li><p>jdk1.7和jdk1.8中HashMap的区别</p><ul><li>JDK1.8之前采用的拉链法，数组+链表</li><li>JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树</li></ul></li></ol><br><hr><h3 id="5-HashMap中put方法的具体流程"><a href="#5-HashMap中put方法的具体流程" class="headerlink" title="5. HashMap中put方法的具体流程"></a>5. HashMap中put方法的具体流程</h3><p><strong>HashMap源码分析—常见属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><span class="hljs-keyword">transient</span> HashMap.Node&lt;K,V&gt;[] table;<br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    HashMap.Node&lt;K, V&gt; next;<br>    Node(<span class="hljs-type">int</span> hash, K key, V value, HashMap.Node&lt;K, V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DEFAULT_INITIAL_CAPACITY  默认的初始容量</li><li>DEFAULT_LOAD_FACTOR    默认的加载因子</li></ul><p><strong>扩容阈值 &#x3D;&#x3D; 数组容量  *  加载因子</strong></p><br><p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007143119.png"></p><ul><li>HashMap是懒惰加载，在创建对象时并没有初始化数组</li><li>在无参的构造函数中，设置了默认的加载因子是0.75</li><li></li></ul><br><p><strong>HashMap源码分析—添加数据</strong></p><p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007143158.png"></p><br><p><strong>HashMap的put方法的具体流程</strong></p><ol><li>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</li><li>根据键值key计算hash值得到数组索引</li><li>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</li><li>如果table[i]&#x3D;&#x3D;null ,不成立<ol><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</li><li>遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</li></ol></li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li></ol><br><hr><h3 id="6-HashMap的扩容机制"><a href="#6-HashMap的扩容机制" class="headerlink" title="6. HashMap的扩容机制"></a>6. HashMap的扩容机制</h3><p><strong>扩容流程</strong></p><p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007143613.png"></p><br><p><strong>扩容机制</strong></p><ul><li>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li><li>每次扩容的时候，都是扩容之前容量的2倍； </li><li>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中<ul><li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul></li></ul><br><p><strong>HashMap的寻址算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><p>扰动算法，使hash值更加均匀，减少hash冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好。数组长度必须是2的n次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span> &#123;<br>……<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>……<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>为什么HashMap的数组长度一定是2的次幂？</strong></p><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ol><br><p><strong>总结</strong></p><ol><li>HashMap的寻址算法<ul><li>计算对象的 hashCode()</li><li>再进行调用 hash() 方法进行二次哈希， hashcode值右移16位再异或运算，让哈希分布更为均匀</li><li>最后 (capacity – 1) &amp; hash 得到索引</li></ul></li><li>为什么HashMap的数组长度一定是2的次幂<ul><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ul></li></ol><br><hr><h3 id="7-HashMap在jdk1-7的情况下的多线程死循环问题"><a href="#7-HashMap在jdk1-7的情况下的多线程死循环问题" class="headerlink" title="7. HashMap在jdk1.7的情况下的多线程死循环问题"></a>7. HashMap在jdk1.7的情况下的多线程死循环问题</h3><p>jdk7的的数据结构是：数组+链表</p><p>在数组进行扩容的时候，因为链表是<font color="red">头插法</font>，在进行数据迁移的过程中，有可能导致死循环</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007145334.png" style="zoom:80%;"><p>线程1和线程2的变量e和next都引用了这个两个节点</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007145401.png" style="zoom:80%;"><p>线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点</p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007145418.png" style="zoom:80%;"><br><p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环<br>比如说，现在有两个线程<br>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入<br>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。<br>线程一：继续执行的时候就会出现死循环的问题。<br>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。<br>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p></bt>]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架面试题</title>
    <link href="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928092648.png" style="zoom:80%;"><br><hr><h3 id="1-单例bean是线程安全的吗？"><a href="#1-单例bean是线程安全的吗？" class="headerlink" title="1. 单例bean是线程安全的吗？"></a>1. 单例bean是线程安全的吗？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>范围</strong></th><th align="left"><strong>范围</strong></th></tr></thead><tbody><tr><td align="left">singleton</td><td align="left">（默认）将每个Spring IoC容器的单个 bean 定义范围限定为单个对象实例。</td></tr><tr><td align="left">prototype</td><td align="left">将单个 bean 定义的作用域限定为任意数量的对象实例。</td></tr><tr><td align="left">request</td><td align="left">将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个自己的 bean 实例，它是在单个 bean 定义的后面创建的。仅在可感知网络的 Spring 上下文中有效 <code>ApplicationContext</code>。</td></tr><tr><td align="left">session</td><td align="left">将单个 bean 定义的范围限定为 HTTP 的生命周期 <code>Session</code>。仅在可感知网络的 Spring 上下文中有效 <code>ApplicationContext</code>。</td></tr><tr><td align="left">application</td><td align="left">将单个 bean 定义的作用域限定为的生命周期 <code>ServletContext</code>。仅在可感知网络的Spring上下文中有效 <code>ApplicationContext</code>。</td></tr><tr><td align="left">websocket</td><td align="left">将单个 bean 定义的作用域限定为的生命周期 <code>WebSocket</code>。仅在可感知网络的Spring上下文中有效 <code>ApplicationContext</code>。</td></tr></tbody></table><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093702.png" style="zoom: 80%;"><br><p><strong>Spring框架中的单例bean是线程安全的吗？</strong></p><p>不是线程安全的</p><p>Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。</p><p>因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决</p><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093917.png" style="zoom:80%;"><br><hr><h3 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h3><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p>常见的AOP使用场景：</p><ul><li>记录操作日志</li><li>缓存处理</li><li>Spring中内置的事务处理</li></ul><br><p>Spring支持编程式事务管理和声明式事务管理两种方式。</p><ul><li>编程式事务控制：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li><li>声明式事务管理：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><br><p><strong>什么是AOP？</strong></p><p>面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</p><br><p><strong>项目中有没有使用到AOP？</strong></p><p>记录操作日志，缓存，spring实现的事务<br>核心是：使用AOP中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取到这些参数以后，保存到数据库</p><br><p><strong>Spring中的事务是如何实现的？</strong></p><p>其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142446.png" style="zoom:80%;"><br><hr><h3 id="3-Spring中事务失效的场景有哪些？"><a href="#3-Spring中事务失效的场景有哪些？" class="headerlink" title="3. Spring中事务失效的场景有哪些？"></a>3. Spring中事务失效的场景有哪些？</h3><ul><li>异常捕获处理</li><li>抛出检查异常</li><li>非public方法</li></ul><br><p><strong>情况一：异常捕获处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer from, Integer to, Double money)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//转账的用户不能为空</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(from);<br>        <span class="hljs-comment">//判断用户的钱是否够转账</span><br>        <span class="hljs-keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="hljs-number">0</span>) &#123;<br>            fromAccount.setMoney(fromAccount.getMoney() - money);<br>            accountDao.updateById(fromAccount);<br>            <span class="hljs-comment">//异常</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//被转账的用户</span><br>            <span class="hljs-type">Account</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(to);<br>            toAccount.setMoney(toAccount.getMoney() + money);<br>            accountDao.updateById(toAccount);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p><p>解决：在catch块添加throw new RuntimeException(e)抛出</p><br><p><strong>情况二：抛出检查异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer from, Integer to, Double money)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-comment">//转账的用户不能为空</span><br>    <span class="hljs-type">Account</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(from);<br>    <span class="hljs-comment">//判断用户的钱是否够转账</span><br>    <span class="hljs-keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="hljs-number">0</span>) &#123;<br>        fromAccount.setMoney(fromAccount.getMoney() - money);<br>        accountDao.updateById(fromAccount);<br>        <span class="hljs-comment">//读取文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;dddd&quot;</span>);<br>        <span class="hljs-comment">//被转账的用户</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(to);<br>        toAccount.setMoney(toAccount.getMoney() + money);<br>        accountDao.updateById(toAccount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：Spring默认只会回滚会异常检查</p><p>解决：配置rollbackFor属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor=Exception.class)</span><br></code></pre></td></tr></table></figure><br><p><strong>情况三：非public方法导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer from, Integer to, Double money)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-comment">//转账的用户不能为空</span><br>    <span class="hljs-type">Account</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(from);<br>    <span class="hljs-comment">//判断用户的钱是否够转账</span><br>    <span class="hljs-keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="hljs-number">0</span>) &#123;<br>        fromAccount.setMoney(fromAccount.getMoney() - money);<br>        accountDao.updateById(fromAccount);<br>        <span class="hljs-comment">//读取文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;dddd&quot;</span>);<br>        <span class="hljs-comment">//被转账的用户</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(to);<br>        toAccount.setMoney(toAccount.getMoney() + money);<br>        accountDao.updateById(toAccount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</p><p>解决：改为public方法</p><br><p><strong>Spring中事务失效的场景有哪些？</strong></p><ol><li>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出</li><li>抛出检查异常，配置rollbackFor属性为Exception</li><li>非public方法导致的事务失效，改为public</li></ol><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142522.png" style="zoom:80%;"><br><h3 id="4-bean的生命周期"><a href="#4-bean的生命周期" class="headerlink" title="4. bean的生命周期"></a>4. bean的生命周期</h3><p>Spring容器在进行实例化时，会将xml配置的bean的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;userDao&quot;</span> class=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> lazy-init=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> class=<span class="hljs-string">&quot;com.itheima.service.UserServiceImpl&quot;</span> scope=<span class="hljs-string">&quot;singleton&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;userDao&quot;</span> ref=<span class="hljs-string">&quot;userDao&quot;</span>&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><ul><li>beanClassName：bean 的类名</li><li>initMethodName：初始化方法名称</li><li>properryValues：bean 的属性值</li><li>scope：作用域</li><li>lazyInit：延迟初始化</li></ul><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143021.png" style="zoom:67%;"><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143044.png" style="zoom:67%;"><br><ol><li>通过BeanDefinition获取bean的定义信息：Spring首先通过BeanDefinition获取Bean的定义信息，包括类名、作用域、构造函数参数、属性值等</li><li>调用构造函数实例化bean：Spring通过反射机制调用Bean的构造函数或工厂方法来创建Bean的实例</li><li>bean的依赖注入：Spring将Bean的依赖注入到Bean的实例中</li><li>处理Aware接口：如果Bean实现了Aware接口（如BeanNameAware、BeanFactoryAware、ApplicationContextAware），Spring会调用相应的方法，让Bean获取到相关的资源<ul><li>BeanNameAware：实现该接口的Bean可以获取到Bean的名称</li><li>BeanFactoryAware：实现该接口的Bean可以获取到BeanFactory组件对象</li><li>ApplicationContextAware：实现该接口的Bean可以获取到ApplicationContext组件对象</li></ul></li><li>Bean的后置处理器BeanPostProcessor-前置：在Bean初始化之前，Spring会调用BeanPostProcessor的postProcessBeforeInitialization方法</li><li>初始化方法(InitializingBean、init-method)：Spring会调用Bean的初始化方法，这可能是InitializingBean接口的afterPropertiesSet方法，或者是在XML中通过init-method属性指定的方法</li><li>Bean的后置处理器BeanPostProcessor-后置：在Bean初始化之后，Spring会调用BeanPostProcessor的postProcessAfterInitialization方法</li><li>销毁bean</li></ol><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143901.png" style="zoom:80%;"><br><hr><h3 id="5-Spring的循环依赖"><a href="#5-Spring的循环依赖" class="headerlink" title="5. Spring的循环依赖"></a>5. Spring的循环依赖</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144904.png" style="zoom:67%;"><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144925.png" style="zoom:67%;"><br><p><strong>三级缓存解决循环依赖</strong></p><p>Spring解决循环依赖是通过三级缓存，对应的三级缓存如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单实例对象注册器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSingletonBeanRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleAliasRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SingletonBeanRegistry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>(<span class="hljs-number">256</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>(<span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>缓存名称</strong></th><th><strong>源码名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>一级缓存</td><td>singletonObjects</td><td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td></tr><tr><td>二级缓存</td><td>earlySingletonObjects</td><td>缓存早期的bean对象（生命周期还没走完）</td></tr><tr><td>三级缓存</td><td>singletonFactories</td><td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td></tr></tbody></table><br><p>一级缓存作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145429.png" style="zoom:67%;"><br><p>如果要想打破循环依赖, 就需要一个中间人的参与, 这个中间人就是二级缓存</p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145602.png" style="zoom:67%;"><br><p>三级缓存：</p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145817.png" style="zoom:67%;"><br><p><strong>构造方法中出现了循环依赖怎么解决？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// B成员变量</span><br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(B b)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A的构造方法执行了...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.b = b ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">// A成员变量</span><br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(A a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B的构造方法执行了...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.a = a ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IS there an unresolvable circular reference?<br></code></pre></td></tr></table></figure><p>解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> B b)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A的构造方法执行了...&quot;</span>);<br>    <span class="hljs-built_in">this</span>.b = b ;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>解释一下Spring中的循环引用？</strong></p><ul><li>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</li><li>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖<ol><li>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</li><li>二级缓存：缓存早期的bean对象（生命周期还没走完）</li><li>三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</li></ol></li></ul><p><strong>如果构造方法中出现了循环引用怎么解决？</strong></p><p>A依赖于B，B依赖于A，注入的方式是构造函数<br>原因：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br>解决方案：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930150448.png" style="zoom:80%;"><br><hr><h3 id="6-SpringMVC的执行流程"><a href="#6-SpringMVC的执行流程" class="headerlink" title="6. SpringMVC的执行流程"></a>6. SpringMVC的执行流程</h3><ul><li>视图阶段（老旧JSP等）</li><li>前后端分离阶段（接口开发，异步）</li></ul><br><p><strong>视图阶段（JSP）</strong></p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930151957.png" style="zoom:80%;"><ol><li>用户发送出请求到前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li><li>Controller执行完成返回ModelAndView对象</li><li>HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）</li><li>ViewReslover解析后返回具体View（视图）</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet响应用户</li></ol><br><p><strong>前后端分离阶段（接口开发，异步请求）</strong></p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152105.png" style="zoom:80%;"><ol><li>用户发送出请求到前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li><li>方法上添加了@ResponseBody</li><li>通过HttpMessageConverter来返回结果转换为JSON并响应</li></ol><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152520.png" style="zoom:67%;"><br><hr><h3 id="7-SpringBoot自动装配原理"><a href="#7-SpringBoot自动装配原理" class="headerlink" title="7. SpringBoot自动装配原理"></a>7. SpringBoot自动装配原理</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152852.png" style="zoom:67%;"><ul><li>@SpringBootConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。</li><li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包。</li><li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解。</li></ul><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155116.png" style="zoom: 67%;"><p><strong>SpringBoot自动配置原理</strong></p><ol><li>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：<ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul></li><li>其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。<br>内部就是读取了该项目和该项目引用的Jar包的的classpath路径下META-INF&#x2F;spring.factories文件中的所配置的类的全类名。 在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。</li><li>条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</li></ol><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155653.png" style="zoom:67%;"><br><hr><h3 id="8-Spring框架常见注解"><a href="#8-Spring框架常见注解" class="headerlink" title="8. Spring框架常见注解"></a>8. Spring框架常见注解</h3><p><strong><font color="red">Spring 的常见注解</font></strong></p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Component、@Controller、@Service、@Repository</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@Configuration</td><td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring  在初始化容器时要扫描的包</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr><tr><td>@Import</td><td>使用@Import导入的类会被Spring加载到IOC容器中</td></tr><tr><td>@Aspect、@Before、@After、@Around、@Pointcut</td><td>用于切面编程（AOP）</td></tr></tbody></table><br><p><strong><font color="red">SpringMVC 的常见注解</font></strong></p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@RequestMapping</td><td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td></tr><tr><td>@RequestBody</td><td>注解实现接收http请求的json数据，将json转换为java对象</td></tr><tr><td>@RequestParam</td><td>指定请求参数的名称</td></tr><tr><td>@PathViriable</td><td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数</td></tr><tr><td>@ResponseBody</td><td>注解实现将controller方法返回对象转化为json对象响应给客户端</td></tr><tr><td>@RequestHeader</td><td>获取指定的请求头数据</td></tr><tr><td>@RestController</td><td>@Controller + @ResponseBody</td></tr></tbody></table><br><p><strong><font color="red">SpringBoot的常见注解</font></strong></p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@SpringBootConfiguration</td><td>组合了- @Configuration注解，实现配置文件的功能</td></tr><tr><td>@EnableAutoConfiguration</td><td>打开自动配置的功能，也可以关闭某个自动配置的选</td></tr><tr><td>@ComponentScan</td><td>Spring组件扫描</td></tr></tbody></table><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Component、@Controller、@Service、@Repository</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@Configuration</td><td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring  在初始化容器时要扫描的包</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr><tr><td>@Import</td><td>使用@Import导入的类会被Spring加载到IOC容器中</td></tr><tr><td>@Aspect、@Before、@After、@Around、@Pointcut</td><td>用于切面编程（AOP）</td></tr></tbody></table><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@RequestMapping</td><td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td></tr><tr><td>@RequestBody</td><td>注解实现接收http请求的json数据，将json转换为java对象</td></tr><tr><td>@RequestParam</td><td>指定请求参数的名称</td></tr><tr><td>@PathViriable</td><td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数</td></tr><tr><td>@ResponseBody</td><td>注解实现将controller方法返回对象转化为json对象响应给客户端</td></tr><tr><td>@RequestHeader</td><td>获取指定的请求头数据</td></tr><tr><td>@RestController</td><td>@Controller + @ResponseBody</td></tr></tbody></table><br><hr><h3 id="9-MyBatis的执行流程"><a href="#9-MyBatis的执行流程" class="headerlink" title="9. MyBatis的执行流程"></a>9. MyBatis的执行流程</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161252.png" style="zoom:67%;"><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161332.png" style="zoom:67%;"><p><strong>Mybatis执行流程：</strong></p><ol><li>读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</li><li>构造会话工厂SqlSessionFactory</li><li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li><li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li><li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li><li>输入参数映射</li><li>输出结果映射</li></ol><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161555.png" style="zoom:67%;"><br><hr><h3 id="10-Mybatis是否支持延迟加载"><a href="#10-Mybatis是否支持延迟加载" class="headerlink" title="10. Mybatis是否支持延迟加载"></a>10. Mybatis是否支持延迟加载</h3><p>Mybatis支持延迟记载，但默认没有开启</p><p><strong>什么叫做延迟加载？</strong></p><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161751.png" style="zoom:67%;"><p>查询用户的时候，把用户所属的订单数据也查询出来，这个是立即加载<br>查询用户的时候，暂时不查询订单数据，当需要订单的时候，再查询订单，这个就是延迟加载</p><br><p><strong>延迟加载原理</strong></p><ol><li>使用CGLIB创建目标对象的代理对象</li><li>当调用目标方法user.getOrderList()时，进入拦截器invoke方法，发现user.getOrderList()是null值，执行sql查询order列表</li><li>把order查询上来，然后调用user.setOrderList(List<Order> orderList) ，接着完成user.getOrderList()方法的调用</Order></li></ol><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161915.png" style="zoom:67%;"><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162014.png" style="zoom:67%;"><br><hr><h3 id="11-Mybatis的一级、二级缓存"><a href="#11-Mybatis的一级、二级缓存" class="headerlink" title="11. Mybatis的一级、二级缓存"></a>11. Mybatis的一级、二级缓存</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162117.png" style="zoom:67%;"><ul><li>本地缓存，基于PerpetualCache，本质是一个HashMap</li><li>一级缓存：作用域是session级别</li><li>二级缓存：作用域是namespace和mapper的作用域，不依赖于session</li></ul><br><p><font color="red"><strong>一级缓存</strong></font>: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><span class="hljs-comment">//3. 执行sql</span><br><span class="hljs-comment">//3.1 获取UserMapper接口的代理对象</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper1</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper2</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper1.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user);<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> userMapper2.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user1);<br></code></pre></td></tr></table></figure><br><p><font color="red"><strong>二级缓存</strong></font>:是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession1</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><span class="hljs-comment">//3. 执行sql</span><br><span class="hljs-comment">//3.1 获取UserMapper接口的代理对象UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> userMapper1.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user1);<br>sqlSession1.close();<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper2</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> userMapper2.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user2);<br><span class="hljs-comment">//4.关闭资源</span><br>sqlSession2.close();<br></code></pre></td></tr></table></figure><p>二级缓存默认是关闭的<br>开启方式，两步：</p><ol><li>全局配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;settings&gt;<br>    &lt;setting name=<span class="hljs-string">&quot;cacheEnabled&quot;</span> value=<span class="hljs-string">&quot;true</span><br><span class="hljs-string">&lt;/settings&gt;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><ol start="2"><li>映射文件<br>使用<cache>标签让当前mapper生效二级缓存</cache></li></ol><p><font color="red">注意事项：</font></p><ol><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li><li>二级缓存需要缓存的数据实现Serializable接口</li><li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li></ol><br><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162915.png" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL面试题</title>
    <link href="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230917212620.png"></p><br><hr><h3 id="1-定位慢查询"><a href="#1-定位慢查询" class="headerlink" title="1. 定位慢查询"></a>1. 定位慢查询</h3><p><strong>在MySQL中如何定位慢查询？</strong></p><p>表象：页面加载慢、接口压测响应时间过长（超过1s）</p><ul><li>聚合查询</li><li>多表查询</li><li>表数据量过大查询</li><li>深度分页查询</li></ul><p>定位慢查询可以通过开源工具或者MySQL慢日志</p><p><strong>方案一：</strong></p><ul><li>调试工具： Arthas</li><li>运维工具：Prometheus、Skywalking</li></ul><br><p><strong>方案二：</strong></p><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志,如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启MySQL慢日志查询开关</span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span><br><span class="hljs-comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p> &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230918121511.png"></p><p>Query_time ：执行时间<br>select * from tb_sku: 执行的语句</p><br><p><strong>如何定位慢查询？</strong></p><ol><li><p>介绍一下当时产生问题的场景（我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟）</p></li><li><p>我们系统中当时采用了运维工具（ Skywalking ），可以监测出哪个接口，最终因为是sql的问题</p></li><li><p>在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中（调试阶段）</p></li></ol><br><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230918121741.png"></p><br><p><strong>一个SQL语句执行很慢，如何分析？</strong></p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919180453.png"></p><p>可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息</p><p>语法：</p><p>直接在select语句之前加上关键字 explain&#x2F;desc</p><p>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919180848.png"></p><p><strong>type</strong> 这条sql的连接的类型，性能由好到差为NULL、system、const、eq_ref、ref、range、 index、all </p><ul><li><p>system：查询系统中的表</p></li><li><p>const：根据主键查询</p></li><li><p>eq_ref：主键索引查询或唯一索引查询</p></li><li><p>ref：索引查询</p></li><li><p>range：范围查询</p></li><li><p>index：索引树扫描</p></li><li><p>all：全盘扫描</p></li></ul><br><p><strong>那这个SQL语句执行很慢，如何分析？</strong></p><p>可以采用MySQL自带的分析工具 EXPLAIN</p><ul><li>通过key和key_len检查是否命中了索引（索引本身存在是否失效的情况）</li><li>通过type字段查看sql是否有进一步优化的空间，是否存在全索引扫描或全盘扫描</li><li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li></ul><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919181545.png"></p><br><hr><h3 id="2-索引概念及索引底层数据结构"><a href="#2-索引概念及索引底层数据结构" class="headerlink" title="2. 索引概念及索引底层数据结构"></a>2. 索引概念及索引底层数据结构</h3><p><strong>什么是索引？</strong></p><p><strong>索引</strong>（index）是帮助MySQL<font color="red">高效获取数据</font>的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><br><strong>B-Tree</strong>，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919201320.png" style="zoom:80%;"><p>B-Tree有如下特点:</p><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol><br><p><strong>B+Tree</strong>是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919210535.png" style="zoom:80%;"><p>B树与B+树对比:</p><p>①：磁盘读写代价B+树更低；②：查询效率B+树更加稳定；③：B+树便于扫库和区间查询</p><br><p><strong>了解过索引吗？（什么是索引）</strong></p><ul><li><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)</p></li><li><p>提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</p></li><li><p>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</p></li></ul><br><p><strong>索引的底层数据结构了解过吗？</strong></p><p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p><ul><li>阶数更多，路径更短</li><li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li><li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li></ul><br><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919211608.png" style="zoom:80%;"><br><hr><h3 id="3-聚蔟索引和非聚蔟索引"><a href="#3-聚蔟索引和非聚蔟索引" class="headerlink" title="3. 聚蔟索引和非聚蔟索引"></a>3. 聚蔟索引和非聚蔟索引</h3><p>什么是聚集索引（聚蔟）？，什么是二级索引（非聚蔟索引）？，什么是回表？</p><ul><li><p>聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个</p></li><li><p>非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个</p></li></ul><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919214724.png" style="zoom:80%;"><br><p><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919214814.png" style="zoom:80%;"><br><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919215043.png"><br><hr><h3 id="4-覆盖索引和超大分页优化"><a href="#4-覆盖索引和超大分页优化" class="headerlink" title="4. 覆盖索引和超大分页优化"></a>4. 覆盖索引和超大分页优化</h3><p><strong>什么是覆盖索引？</strong></p><p><strong>覆盖索引</strong>是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922162045.png"></p><br><p><strong>MySQL超大分页处理</strong></p><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。我们一起来看看执行limit分页查询耗时对比：</p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922162946.png"></p><p>因为，当在进行分页查询时，如果执行 limit 9000000,10 ，此时需要MySQL排序前9000010 记录，仅仅返回 9000000 - 9000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *<br>from tb_sku t,<br>(select id from tb_sku order by id limit 9000000,10) a<br>where t.id = a.id;<br></code></pre></td></tr></table></figure><br><p><strong>知道什么叫覆盖索引吗？</strong></p><p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p><ul><li>使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</li><li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *</li></ul><br><p><strong>MySQL超大分页怎么处理？</strong></p><p>问题：在数据量比较大时，limit分页查询，需要对数据进行排序，效率低</p><p>解决方案：覆盖索引+子查询</p><br><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922163725.png"></p><br><hr><h3 id="5-索引创建原则"><a href="#5-索引创建原则" class="headerlink" title="5. 索引创建原则"></a>5. 索引创建原则</h3><p><strong>索引创建原则有哪些？</strong></p><ul><li>主键索引</li><li>唯一索引</li><li>根据业务创建的索引(复合索引)</li></ul><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><br><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922193945.png"></p><br><hr><h3 id="6-索引失效"><a href="#6-索引失效" class="headerlink" title="6. 索引失效"></a>6. 索引失效</h3><p>执行计划explain可以判断索引是否失效</p><p><strong>什么情况下索引会失效？</strong></p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123714.png"></p><br><ol><li><p>违反最左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引。如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123754.png" style="zoom:80%;"><br></p></li><li><p>范围查询右边的列，不能使用索引 <img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123830.png" style="zoom:80%;"><br></p></li><li><p>不要在索引列上进行运算操作， 索引将失效</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123923.png" style="zoom:80%;"><br></li><li><p>字符串不加单引号，造成索引失效。由于，在查询时没有对字符串加单引号， MySQL的查询优化器，会自动的进行类型转换，造成索引失效</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123954.png" style="zoom:80%;"><br></li><li><p>以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924124018.png" style="zoom:80%;"></li></ol><br><p><strong>索引什么情况下会失效？</strong></p><ol><li>违反最左前缀法则</li><li>范围查询右边的列，不能使用索引</li><li>不要在索引列上进行运算操作， 索引将失效</li><li>字符串不加单引号，造成索引失效。(类型转换)</li><li>以%开头的Like模糊查询，索引失效</li></ol><br><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924124846.png" style="zoom:80%;"><br><hr><h3 id="7-SQL的优化"><a href="#7-SQL的优化" class="headerlink" title="7. SQL的优化"></a>7. SQL的优化</h3><ul><li>表的设计优化</li><li>索引优化</li><li>SQL语句优化</li><li>主从复制、读写分离</li><li>分库分表</li></ul><p><strong>表的设计优化</strong></p><ol><li>比如设置合适的数值（tinyint  int  bigint），要根据实际情况选择</li><li>比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低</li></ol><br><p><strong>SQL语句优化</strong></p><ol><li><p>SELECT语句务必指明字段名称（避免直接使用select * ）</p></li><li><p>SQL语句要避免造成索引失效的写法</p></li><li><p>尽量用union all代替union  union会多一次过滤，效率低</p><p><strong>Union</strong>：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序</p><p><strong>Union All</strong>：对两个结果集进行并集操作，包括重复行，不进行排序</p></li><li><p>避免在where子句中对字段进行表达式操作</p></li><li><p>Join优化 能用inner join 就不用left join 和 right join，如必须使用 一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。left join 或 right join，不会重新调整顺序</p></li></ol><br><p><strong>主从复制，读写分离</strong></p><p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。读写分离解决的是，数据库的写入，影响了查询的效率。</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924131834.png" style="zoom:80%;"><br><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924131943.png"><br><hr><h3 id="8-事务"><a href="#8-事务" class="headerlink" title="8. 事务"></a>8. 事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>事务的特性（ACID）是什么？可以详细说一下嘛？</strong></p><ul><li>原子性（<strong>A</strong>tomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（<strong>C</strong>onsistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（<strong>I</strong>solation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（<strong>D</strong>urability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><br><p><strong>并发事务带来哪些问题？怎么解决这些问题呢？MySQL的默认隔离级别是？</strong></p><ul><li>并发事务问题：脏读、不可重复读、幻读</li><li>隔离级别：读未提交、读已提交、可重复读、串行化</li></ul><br><p><strong>并发事务问题</strong></p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140143.png" style="zoom:80%;"><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140202.png" style="zoom:95%;"><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140454.png" style="zoom:80%;"><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140526.png" style="zoom: 80%;"><br><p><strong>解决方案：</strong>对事务进行隔离</p><p>√ 表示存在该问题× 表示不存在该问题</p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140839.png" style="zoom:80%;"><p><strong>注意</strong>：<font face="仿宋">事务隔离级别越高，数据越安全，但是性能越低</font></p><br><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924141542.png"></p><br><hr><h3 id="9-undo-log-和redo-log-的区别"><a href="#9-undo-log-和redo-log-的区别" class="headerlink" title="9. undo log 和redo log 的区别"></a>9. undo log 和redo log 的区别</h3><ul><li><strong>缓冲池（buffer pool）</strong>:主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li><li><strong>数据页（page）</strong>:是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li></ul><br><p><strong>redo log</strong></p><p><strong>重做日志</strong>，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong>。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><br><p><strong>undo log</strong></p><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : <font color="red">提供回滚 </font>和 <font color="red">MVCC</font>(多版本并发控制) 。undo log和redo log记录物理日志不一样，它是<font color="red">逻辑日志</font>。</p><ul><li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，</li><li>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</li></ul><p><font face="仿宋">undo log可以实现事务的一致性和原子性</font></p><br><p><strong>undo log  和 redo log 的区别</strong></p><ul><li>redo log: 记录的是数据页的物理变化，服务宕机可用来同步数据</li><li>undo log ：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据</li><li>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</li></ul><br><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924153143.png" style="zoom:80%;"><br><hr><h3 id="10-MVCC"><a href="#10-MVCC" class="headerlink" title="10. MVCC"></a>10. MVCC</h3><p>事务中的隔离性是如何保证的？</p><p>排他锁（如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）mvcc : 多版本并发控制</p><p><strong>MVCC-实现原理</strong></p><ul><li><p><strong>记录中的隐藏字段</strong></p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230926140006.png"></p></li><li><p><strong>undo log</strong></p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</p></li></ul><br><p><strong>事务中的隔离性是如何保证的(MVCC)？</strong></p><p>MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p><ul><li><p><strong>隐藏字段</strong>：</p><ol><li>trx_id(事务id)，记录每一次操作的事务id，是自增的</li><li>roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</li></ol></li><li><p><strong>undo log</strong>：</p><ol><li>回滚日志，存储老版本数据</li><li>版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</li></ol></li><li><p><strong>ReadView</strong>解决的是一个事务查询选择版本的问题</p><ol><li><p>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据</p></li><li><p>不同的隔离级别快照读是不一样的，最终的访问的结果不一样</p><p>RC ：每一次执行快照读时生成ReadView</p><p>RR：仅在事务中第一次执行快照读时生成ReadView，后续复用</p></li></ol></li></ul><br><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928082723.png"><br><hr><h3 id="11-MySQL主从同步原理"><a href="#11-MySQL主从同步原理" class="headerlink" title="11. MySQL主从同步原理"></a>11. MySQL主从同步原理</h3><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928082927.png" style="zoom: 80%;"><p><strong>MySQL主从复制的核心就是二进制日志</strong></p><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句</p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083110.png"></p><p>复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><br><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083241.png"></p><br><hr><h3 id="12-分库分表"><a href="#12-分库分表" class="headerlink" title="12. 分库分表"></a>12. 分库分表</h3><p>分库分表的时机：</p><ol><li><strong>前提</strong>，项目业务数据逐渐增多，或业务发展比较迅速</li><li>优化已解决不了性能问题（主从读写分离、查询索引…）</li><li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询、连接数太多）</li></ol><br><p><strong>拆分策略</strong></p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083629.png" style="zoom:80%;"><ul><li><p><strong>垂直分库</strong></p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083745.png" style="zoom:80%;"><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ol><li>按业务对数据分级管理、维护、监控、扩展</li><li>在高并发下，提高磁盘IO和数据量连接数</li></ol><br></li><li><p><strong>垂直分表</strong></p><p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928090520.png"></p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ol><li>冷热数据分离</li><li>减少IO过渡争抢，两表互不影响</li></ol><p>拆分规则：</p><ul><li>把不常用的字段单独放在一张表</li><li>把text，blob等大字段拆分出来放在附表中</li></ul></li></ul><br><ul><li><p><strong>水平分库</strong></p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928090036.png" style="zoom:80%;"><p>水平分库：将一个库的数据拆分到多个库中。</p><p>特点：</p><ol><li><p>解决了单库大数量，高并发的性能瓶颈问题</p></li><li><p>提高了系统的稳定性和可用性</p></li></ol><p>路由规则:</p><ul><li>根据id节点取模</li><li>按id也就是范围路由，节点1(1-100万 ),节点2(100万-200万)</li><li>…</li></ul><br></li><li><p><strong>水平分表</strong></p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928090306.png" style="zoom:80%;"><p>水平分表：将一个表的数据拆分到多个表中(可以在同一个库内)。</p><p>特点：</p><ol><li>优化单一表数据量过大而产生的性能问题;</li><li>避免IO争抢并减少锁表的几率;</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis面试题</title>
    <link href="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="redis面试题"><a href="#redis面试题" class="headerlink" title="redis面试题"></a>redis面试题</h2><p>该笔记基于b站<a href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p><p>redis的作用： </p><ul><li>缓存</li><li>分布式锁</li><li>消息队列、延迟队列</li><li>… …</li></ul><br><hr><h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>查询一个不存在的数据，MySQL查询不到数据，也不会把数据写入到缓存中，这样就会导致每次请求直接查询数据库</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910162308.png"></p><p>解决问题：</p><ol><li><p><strong>缓存空数据</strong>，查询返回数据为空时，也把这个空结果写入到缓存中</p><p>​<strong>优点：</strong> 简单</p><p>​<strong>缺点：</strong> 消耗内存，肯能会发生不一致问题（缓存空数据后，数据库又添加了这个数据，导致数据库存在该数据而缓存中又为空）</p></li><li><p><strong>布隆过滤器</strong></p></li></ol><p>​<strong>bitmap（位图）:</strong> 相当于是一个以位（bit）为单位的数组，数组中每个单元只能存储二进制0或1</p><p>​<strong>布隆过滤器的作用：</strong> 布隆过滤器可以用于检索一个元素是否在一个集合中</p><p>​<strong>误判率：</strong> 数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗</p><p>​<strong>优点：</strong> 内存占用较少，没有多余key</p><p>​<strong>缺点：</strong> 存在误判，实现复杂</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910162955.png"></p><p>  <img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910163354.png"></p> <img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912102927.png"><br><hr><h3 id="2-缓存刺穿"><a href="#2-缓存刺穿" class="headerlink" title="2. 缓存刺穿"></a>2. 缓存刺穿</h3><p>给某一个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求发送过来，这些请求可能会瞬间把数据库压垮</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910164857.png"></p><p><strong>解决方案一：</strong> 互斥锁，强一致，性能差</p><p><strong>解决方案二：</strong> 逻辑过期，高可用，性能优，不能保证数据绝对一致</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912102445.png"></p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912102834.png" style="zoom:80%;"><br><hr><h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h3><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，给数据库带来压力</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912103407.png"></p><p><strong>解决方案：</strong></p><ul><li>给不同的key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性   哨兵模式 、集群模式</li><li>给缓存业务添加降级限流策略    Nginx或者spring cloud gateway     降级可做为系统的保底策略，适用于穿透、击穿、雪崩</li><li>给业务添加多级缓存  Guava、Caffeine</li></ul><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912103925.png"></p><br><p><strong>“缓存三兄弟”</strong></p><p>穿透无中生有key，布隆过滤null隔离</p><p>缓存击穿过期key，锁与非期解难题</p><p>缓存大量过期key，过期时间要随机</p><p>面试必考三兄弟，可用限流来兜底</p><br><hr><h3 id="4-双写一致性"><a href="#4-双写一致性" class="headerlink" title="4. 双写一致性"></a>4. 双写一致性</h3><p>面试官问：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</p><p><font color="red"><strong>一定</strong></font>要先设置前提，先介绍自己的业务背景，然后根据自己的业务背景进行回答，根据业务背景可划分两大类</p><ul><li>一致性要求高</li><li>允许延迟一致</li></ul><br><ol><li>介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以，我们当时采用的是异步的方案同步的数据（允许延迟一致）</li></ol><p><strong>解决方案： 采用异步通知</strong></p><ul><li>使用MQ中间件，更新数据之后，通知缓存删除</li><li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li></ul><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912205428.png"></p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912205541.png"></p><br><ol start="2"><li>我们当时是把抢券的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致，我们当时采用的是redisson提供的读写锁来保证数据的同步（一致性要求高）</li></ol><p><strong>解决方案： 采用Redisson提供的读写锁</strong></p><ul><li>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</li><li>排他锁：也叫独占锁writeLock，加锁之后，阻塞其他线程读写操作</li></ul><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912210739.png"></p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230914223534.png"></p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230914223616.png"></p><br><p><strong>双写一致性：</strong> 当修改了数据库中的数据后要更新缓存中的数据，即数据库的数据和缓存保存一致</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912105518.png"></p><p><strong>读操作：</strong> 缓存命中，直接返回；缓存未命中，查询数据库，写入缓存，设定TTL</p><p><strong>写操作：</strong> <font color="red">延迟双删</font></p><p>​删除缓存  &rarr;  修改数据库 &rarr; （延时）删除缓存</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230914224134.png" style="zoom:80%;"><br><hr><h3 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5. 持久化"></a>5. 持久化</h3><p>在Redis中提供了两种持久化方式 RDB和AOF</p><br><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915091601.png"></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到格式如下：</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915092105.png"><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li></ul><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915092855.png"></p><br><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 是否开启AOF功能，默认是no<br>appendonly yes<br># AOF文件的名称<br>appendfilename &quot;appendonly.aof&quot;<br></code></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 表示每执行一次写命令，立即记录到AOF文件<br>appendfsync always <br># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案<br>appendfsync everysec <br># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘<br>appendfsync no<br><br></code></pre></td></tr></table></figure><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915094412.png"></p><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915094513.png" style="zoom:80%;"><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs linux"># AOF文件比上次文件 增长超过多少百分比则触发重写<br>auto-aof-rewrite-percentage 100<br># AOF文件体积最小多大以上才触发重写 <br>auto-aof-rewrite-min-size 64mb <br><br></code></pre></td></tr></table></figure><br><p><strong>RDB与AOF对比</strong></p><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中可以结合两者一起使用</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915094852.png" style="zoom: 80%;"><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915095003.png" style="zoom: 67%;"><br><hr><h3 id="6-数据过期策略"><a href="#6-数据过期策略" class="headerlink" title="6. 数据过期策略"></a>6. 数据过期策略</h3><p>Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）</p><br><p><strong>惰性删除：</strong> 设置该key过期时间后，我们不去管它，当需要该时key时，我们再检查是否过期，如果过期，我们就删除掉它，反之返回该key</p><p><strong>优点</strong> ：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p><p><strong>缺点</strong> ：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p><br><p><strong>定期删除：</strong>每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</p><p>定期清理有两种模式：</p><ul><li><p>lSLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的hz 选项来调整这个次数</p></li><li><p>lFAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p></li></ul><p><strong>优点</strong>：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p><strong>缺点</strong>：难以确定删除操作执行的时长和频率。</p><p><strong>Redis的过期删除策略：</strong><font color="red">惰性删除 + 定期删除</font> 两种策略进行配合使用</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915102704.png" style="zoom:80%;"><br><hr><h3 id="7-数据淘汰策略"><a href="#7-数据淘汰策略" class="headerlink" title="7. 数据淘汰策略"></a>7. 数据淘汰策略</h3><p><strong>数据的淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>Redis支持8种不同策略来选择要删除的key：</p><ul><li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p></li><li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p></li><li><p>allkeys-random：对全体key ，随机进行淘汰。</p></li><li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。</p></li><li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p></li><li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p></li><li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p></li><li><p>volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰</p></li></ul><p><font face="仿宋"><strong>LRU</strong>（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</font></p><p><font face="仿宋"><strong>LFU</strong>（<strong>L</strong>east <strong>F</strong>requently <strong>U</strong>sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</font></p><br><p><strong>使用建议</strong></p><ol><li><p>优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</p></li><li><p>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。</p></li><li><p>如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。</p></li><li><p>如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。</p></li></ol><br><p>关于数据淘汰策略的其他问题</p><ol><li>数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?</li></ol><p>​使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据</p><ol start="2"><li>Redis的内存用完了会发生什么</li></ol><p>​主要看数据淘汰策略是什么？如果是默认的配置（ noeviction ），会直接报错</p><br><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915104239.png" style="zoom:80%;"><br><hr><h3 id="8-分布式锁"><a href="#8-分布式锁" class="headerlink" title="8. 分布式锁"></a>8. 分布式锁</h3><p>Redis实现分布式锁主要利用Redis的setnx命令。setnx是SET if not exists（如果不存在，则SET）的简写</p><ul><li><p>获取锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 添加锁，NX是互斥、EX是设置超时时间<br>SET lock value NX EX 10<br></code></pre></td></tr></table></figure></li><li><p>释放锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 释放锁，删除即可<br>DEL key<br></code></pre></td></tr></table></figure><p>如果不给锁设置过期时间，获取锁的服务器宕机后，无法释放锁，会导致死锁问题</p><br></li></ul><p>Redis实现分布式锁如何合理地控制锁的有效时长？</p><ul><li>根据业务作息时间预估</li><li>给锁续期</li></ul><br><p>redisson实现分布式锁——执行流程</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915162207.png"></p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915162258.png" style="zoom:150%;"><p><font face="仿宋" color="red">加锁、设置过期时间等操作都是基于lua脚本完成的</font></p><br><p>redisson实现分布式锁——可重入</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915165128.png"></p><br>redis分布式锁，是如何实现的？<ul><li>先按照自己简历上的业务进行描述分布式锁使用的场景</li><li>我们当使用的redisson实现的分布式锁，底层是<font color="red">setnx</font>f和<font color="red">lua脚本</font>（保证原子性）</li></ul><br><p>Redisson实现分布式锁如何合理的控制锁的有效时长？</p><p>在redisson的分布式锁中，提供了一个<font color="red">WatchDog</font>(看门狗），一个线程获取锁成功以后， WatchDog会给持有锁的线程<font color="red">续期（默认是每隔10秒续期一次）</font></p><br><p>Redisson的这个锁，可以重入吗？</p><p>可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的<font color="red">hash结构，来存储线程信息和重入的次数</font></p><br><p>Redisson锁能解决主从数据一致的问题吗？</p><p>不能解决，但是可以使用redisson提供的<font color="red">红锁</font>来解决，但是这样的话，<font color="red">性能就太低了</font>，如果业务中非要<font color="red">保证数据的强一致性</font>，建议采用<font color="red">zookeeper</font>实现的分布式锁</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915170401.png" style="zoom:80%;"><br><hr><h3 id="9-主从同步"><a href="#9-主从同步" class="headerlink" title="9. 主从同步"></a>9. 主从同步</h3><p>单节点Redis的并发能力是有上限的，要进一步提升Redis的能力，就需要搭建主从集群，实现读写分离</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917132857.png" style="zoom: 80%;"><br><p>主从全量同步</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917133346.png" style="zoom: 80%;"><p><font color="red">Replication id</font>: 简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p><p><font color="red">offset</font>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p><br><p>主从增量同步(slave重启或后期数据变化)</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917134053.png" style="zoom: 80%;"><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917134215.png" style="zoom:80%;"><br><p><strong>介绍一下redis的主从同步</strong></p><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p><br><p><strong>能说一下，主从同步数据的流程</strong></p><p><strong>全量同步</strong></p><ol><li>从节点请求主节点同步数据（replication id、 offset ）</li><li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id和offset）</li><li>主节点执行bgsave，生成rdb文件后，发送给从节点去执行</li><li>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）</li><li>把生成之后的命令日志文件发送给从节点进行同步</li></ol><br><p><strong>增量同步</strong></p><ol><li>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</li><li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</li></ol><br><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917135453.png" style="zoom:80%;"><br><hr><h3 id="10-哨兵模式"><a href="#10-哨兵模式" class="headerlink" title="10. 哨兵模式"></a>10. 哨兵模式</h3><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917141134.png" style="zoom: 67%;"><ul><li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p></li><li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p></li></ul><br><p><strong>服务状态监控</strong></p><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li></ul><br><p><strong>哨兵选主规则</strong></p><ul><li><p>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</p></li><li><p>然后判断从节点的slave-priority值，越小优先级越高</p></li><li><p><font color="red">如果slave-prority一样，则判断slave节点的offset值，越大优先级越高</font></p></li><li><p>最后是判断slave节点的运行id大小，越小优先级越高。</p></li></ul><br><p><strong>怎么保证Redis的高并发高可用</strong></p><p>哨兵模式：实现主从集群的自动故障恢复（监控、故障自动恢复、通知）</p><br><p><strong>你们使用redis是单点还是集群，那种集群？</strong></p><p>主从（1主1从）+哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同</p><br><p>redis集群脑裂是什么？怎么解决</p><p><font color="red">集群脑裂</font>是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失</p><p><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p><br><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917152920.png" style="zoom:100%;"><br><hr><h3 id="11-分片集群结构"><a href="#11-分片集群结构" class="headerlink" title="11. 分片集群结构"></a>11. 分片集群结构</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发写的问题</p></li></ul><br><p>使用分片集群可以解决上述问题，分片集群特征：</p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><bt><p><strong>数据读写</strong></p><p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917154045.png" style="zoom:80%;"><br><p><strong>redis的分片集群有什么作用？</strong></p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><br><p><strong>reids分片集群中数据是怎样存储和读取的？</strong></p><ul><li><p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽</p></li><li><p>将16384个插槽分配到不同的实例</p></li><li><p>读写数据：根据key的有效部分计算哈希值，对16384取余（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）余数做为插槽，寻找插槽所在的实例</p></li></ul><br><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917154457.png"></p><br><hr><h3 id="12-线程模型"><a href="#12-线程模型" class="headerlink" title="12. 线程模型"></a>12. 线程模型</h3><p><strong>redis是单线程的，但是为什么还那么快？</strong></p><ul><li>reids是纯内存操作，执行速度非常快</li><li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li><li>使用I&#x2F;O多路复用模型，非阻塞IO</li></ul><p>Redis6引入了多线程机制，它有 “一个 worker线程+多个IO子线程”，其实就是在 IO 就绪之后使用多线程提升读写解析数据的效率，而在 操作内存数据的时候还是用单线程。<br>利用这种单线程+多线程共同运作的机制，将CPU的性能显著提升了。</p><p>目前所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，<strong>Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的</strong></p><br><p><strong>能解释一下I&#x2F;O多路复用模型吗？</strong></p><p>redis是存内存操作，执行速度非常快，它的性能瓶颈是<font color="red">网络延迟</font>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p><ul><li><p>用户空间和内核空间</p></li><li><p>常见的IO模型</p><p>阻塞IO（Blocking IO）</p><p>非阻塞IO（Nonblocking IO）</p><p>IO多路复用（IO Multiplexing）</p></li><li><p>Redis网络模型</p></li></ul><br><p>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong></p><ul><li><p><strong>用户空间</strong>只能执行受限的命令（Ring3），而且不能直接调用系统资源 必须通过内核提供的接口来访问</p></li><li><p><strong>内核空间</strong>可以执行特权命令（Ring0），调用一切系统资源</p></li></ul><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li><p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p></li><li><p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p></li></ul><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917161533.png" style="zoom:100%;"><br><p><strong>阻塞IO</strong></p><p>阻塞IO就是两个阶段都必须阻塞等待：</p><p>阶段一：</p><ol><li><p>用户进程尝试读取数据（比如网卡数据）</p></li><li><p>此时数据尚未到达，内核需要等待数据</p></li><li><p>此时用户进程也处于阻塞状态</p></li></ol><p>阶段二：</p><ol><li><p>数据到达并拷贝到内核缓冲区，代表已就绪</p></li><li><p>将内核数据拷贝到用户缓冲区</p></li><li><p>拷贝过程中，用户进程依然阻塞等待</p></li><li><p>拷贝完成，用户进程解除阻塞，处理数据</p></li></ol><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917162821.png" style="zoom: 80%;"><p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态</p><br><p><strong>非阻塞IO</strong></p><p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p>阶段一：</p><ol><li><p>用户进程尝试读取数据（比如网卡数据）</p></li><li><p>此时数据尚未到达，内核需要等待数据</p></li><li><p>返回异常给用户进程</p></li><li><p>用户进程拿到error后，再次尝试读取</p></li><li><p>循环往复，直到数据就绪</p></li></ol><p>阶段二：</p><ol><li><p>将内核数据拷贝到用户缓冲区</p></li><li><p>拷贝过程中，用户进程依然阻塞等待</p></li><li><p>拷贝完成，用户进程解除阻塞，处理数据</p></li></ol><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917163520.png" style="zoom:80%;"><br><p><strong>IO多路复用</strong></p><p>是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p><p>阶段一：</p><ol><li><p>用户进程调用select，指定要监听的Socket集合</p></li><li><p>内核监听对应的多个socket</p></li><li><p>任意一个或多个socket数据就绪则返回readable</p></li><li><p>此过程中用户进程阻塞</p></li></ol><p>阶段二：</p><ol><li><p>用户进程找到就绪的socket</p></li><li><p>依次调用recvfrom读取数据</p></li><li><p>内核将数据拷贝到用户空间</p></li><li><p>用户进程处理数据</p></li></ol><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917163917.png" style="zoom:80%;"><br><p>常见的监听Socket的方式、通知的方式：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p><strong>差异</strong></p><p>uselect和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket ，需要用户进程逐个遍历Socket来确认</p><p>uepoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间</p><br><p><strong>redis网络模型</strong></p><p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库</p><p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917164958.png"></p><br><p><strong>能解释一下I&#x2F;O多路复用模型吗？</strong></p><p>是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I&#x2F;O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p><br><p><strong>reids网络模型</strong></p><p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p><ul><li><p>连接应答处理器</p></li><li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p></li><li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p></li></ul><br><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917164508.png" style="zoom: 80%;"><p>&#96;&#96;</p></bt>]]></content>
    
    
    <categories>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2023/09/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2023/09/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>什么也没有！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
