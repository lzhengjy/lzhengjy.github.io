<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Zheng" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lzhengjy.github.io/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zheng">
<meta name="twitter:card" content="summary">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">



    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MybatisPlus/" rel="tag">MybatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot3/" rel="tag">SpringBoot3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel/" rel="tag">excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" rel="tag">权限管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-JVM-基础篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/" class="article-date">
      <time datetime="2023-10-17T06:05:53.000Z" itemprop="datePublished">2023-10-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/">JVM-基础篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="一-JVM"><a href="#一-JVM" class="headerlink" title="一. JVM"></a>一. JVM</h2><h3 id="1-初识JVM"><a href="#1-初识JVM" class="headerlink" title="1. 初识JVM"></a>1. 初识JVM</h3><p><strong>什么是JVM？</strong></p>
<p><font color="red">JVM</font> 全程 Java Virtual Machine，中文译名<font color="red">Java虚拟机</font><br>JVM本质上是一个运行在计算机上的程序，他的&lt;&#x2F;职责是运行<font color="red">Java字节码文件</font><br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017143311.png" style="zoom: 50%;"></p>
<br>

<h3 id="2-JVM的功能"><a href="#2-JVM的功能" class="headerlink" title="2. JVM的功能"></a>2. JVM的功能</h3><ul>
<li>解释和运行<ul>
<li>对字节码文件中的指令，实时的解释成机器码，让计算机执行</li>
</ul>
</li>
<li>内存管理<ul>
<li>自动为对象、方法等分配内存</li>
<li>自动的垃圾回收机制，回收不再利用的对象</li>
</ul>
</li>
<li>即时编译<ul>
<li>对热点代码进行优化，提升执行效率</li>
</ul>
</li>
</ul>
<br>

<p><strong>即时编译</strong></p>
<ul>
<li><p>Java语言如果不做任何优化，性能不如C、C++等语言</p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017144235.png" style="zoom: 50%;">
</li>
<li><p>Java需要实时解释，主要是为了支持跨平台特性</p>
</li>
<li><p>由于JVM需要实时解释虚拟机指令，不做任何优化性能不如直接运行机器码的C、C++等语言</p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017144309.png" style="zoom: 50%;"></li>
</ul>
<br>

<p><strong>常见的JVM</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">作者</th>
<th align="center">支持版本</th>
<th align="center">社区活跃度 （github star）</th>
<th align="center">特性</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HotSpot  (Oracle JDK版)</td>
<td align="center">Oracle</td>
<td align="center">所有版本</td>
<td align="center">高(闭源)</td>
<td align="center">使用最广泛，稳定可靠，社区活跃 JIT支持 Oracle JDK默认虚拟机</td>
<td align="center">默认</td>
</tr>
<tr>
<td align="center">otSpot  (Open JDK版)</td>
<td align="center">Oracle</td>
<td align="center">所有版本</td>
<td align="center">中(16.1k)</td>
<td align="center">同上 开源，Open JDK默认虚拟机</td>
<td align="center">默认 对JDK有二次开发需求</td>
</tr>
<tr>
<td align="center">GraalVM</td>
<td align="center">Oracle</td>
<td align="center">11, 17,19 企业版支持8</td>
<td align="center">高（18.7k）</td>
<td align="center">多语言支持 高性能、JIT、AOT支持</td>
<td align="center">微服务、云原生架构 需要多语言混合编程</td>
</tr>
<tr>
<td align="center">Dragonwell JDK 龙井</td>
<td align="center">Alibaba</td>
<td align="center">标准版 8,11,17 扩展版11,17</td>
<td align="center">低(3.9k)</td>
<td align="center">基于OpenJDK的增强 高性能、bug修复、安全性提升 JWarmup、ElasticHeap、Wisp特性支</td>
<td align="center">电商、物流、金融领域 对性能要求比较高</td>
</tr>
<tr>
<td align="center">Eclipse OpenJ9</td>
<td align="center">IBM</td>
<td align="center">8,11,17,19,20</td>
<td align="center">低(3.1k)</td>
<td align="center">高性能、可扩展 JIT、AOT特性支持</td>
<td align="center">微服务、云原生架构</td>
</tr>
</tbody></table>
<br>

<p><strong>HotSpot的发展历程</strong></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231017145327.png" style="zoom: 67%;">



<br>

<p><strong>总结</strong></p>
<ol>
<li><p>JVM到底是什么？</p>
<p>JVM 全称是 Java Virtual Machine，中文译名 Java虚拟机，是一个运行在计算 机上的程序，他的职责是运行Java字节码文件</p>
</li>
<li><p>JVM的三大核心功能是什么？</p>
<p>JVM 包含内存管理、解释执行虚拟机指令、即时编译三大功能。</p>
</li>
<li><p>常见的JVM虚拟机有哪些？</p>
<p>常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK也 提供了一款功能增强版的JVM。其中使用最广泛的是HotSpot虚拟机</p>
</li>
</ol>
<br>

<hr>
<h2 id="二-字节码文件详解"><a href="#二-字节码文件详解" class="headerlink" title="二. 字节码文件详解"></a>二. 字节码文件详解</h2><h3 id="1-Java虚拟机的组成"><a href="#1-Java虚拟机的组成" class="headerlink" title="1.  Java虚拟机的组成"></a>1.  Java虚拟机的组成</h3><p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231018133846.png"></p>
<br>



<hr>
<h3 id="2-字节码文件的组成"><a href="#2-字节码文件的组成" class="headerlink" title="2. 字节码文件的组成"></a>2. 字节码文件的组成</h3><p>字节码文件中保存了源代码编译之后的内容，以二进制的方式存储，无法直接用记事本打开阅读<br>推荐使用 jclasslib工具查看字节码文件,Github地址： <a target="_blank" rel="noopener" href="https://github.com/ingokegel/jclasslib">https://github.com/ingokegel/jclasslib</a></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026135449.png" style="zoom:80%;">

<br>

<p><strong>字节码文件一般包含5个部分</strong></p>
<ul>
<li><p>基础信息</p>
<p>魔数、字节码文件对应的Java版本号 访问标识(public final等等) 父类和接口</p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026135908.png"></p>
</li>
<li><p>常量池</p>
<p>保存了字符串常量、类或接口名、字段名 主要在字节码指令中使</p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026135928.png"></p>
</li>
<li><p>字段</p>
<p>当前类或接口声明的字段信息</p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026140014.png"></p>
</li>
<li><p>方法</p>
<p>当前类或接口声明的方法信息 字节码指令</p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026140032.png"></p>
</li>
<li><p>属性</p>
<p>类的属性，比如源码的文件名 内部类的列表等</p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026140135.png"></p>
</li>
</ul>
<br>

<hr>
<h3 id="3-基本信息"><a href="#3-基本信息" class="headerlink" title="3. 基本信息"></a>3. 基本信息</h3><p><strong>Magis魔数</strong></p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026150614.png"></p>
<ul>
<li>文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容</li>
<li>软件使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错</li>
<li>Java字节码文件中，将文件头称为magic魔数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">文件类型</th>
<th align="center">字节数</th>
<th align="center">文件头</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JPEG(jpg)</td>
<td align="center">3</td>
<td align="center">FFD8FF</td>
</tr>
<tr>
<td align="center">PNG(png)</td>
<td align="center">4</td>
<td align="center">89504E47(文件尾也有要求)</td>
</tr>
<tr>
<td align="center">bmp</td>
<td align="center">2</td>
<td align="center">424D</td>
</tr>
<tr>
<td align="center">XML(xml)</td>
<td align="center">5</td>
<td align="center">3C3F786D6C</td>
</tr>
<tr>
<td align="center">AVI(avi)</td>
<td align="center">4</td>
<td align="center">41564920</td>
</tr>
<tr>
<td align="center">Java字节码文件(.class)</td>
<td align="center">4</td>
<td align="center">CAFEBABE</td>
</tr>
</tbody></table>
<br>



<p><strong>主副版本号</strong></p>
<ul>
<li><font color="red">主副版本号指的是编译字节码文件的JDK版本号</font>，主版本号用来标识大版本号，JDK1.0-1.1使用了 45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同 版本的标识，一般只需要关心主版本号</li>
<li>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容</li>
</ul>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026161923.png" style="zoom: 67%;">

<p>1.2之后大版本号计算方法就是: 主版本号 – 44 比如主版本号52就是JDK1.8</p>
<br>

<p>主版本号不兼容导致的错误</p>
<p><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231026162108.png"></p>
<p>解决方案</p>
<ul>
<li>升级JDK版本 </li>
<li>将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求</li>
</ul>
<br>



<hr>
<h3 id="4-常量池"><a href="#4-常量池" class="headerlink" title="4. 常量池"></a>4. 常量池</h3><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027105433.png" style="zoom:67%;">

<ul>
<li>字节码文件中常量池的作用：避免相同的内容重复定义，节省空间</li>
<li>常量池中的数据都有一个编号，编号从1开始，在字段或字节码指令中可以通过编号快速找到对应的数据</li>
<li>字节码指令通过编号引用到常量池的过程称为<font color="red">符号引用</font></li>
</ul>
<br>



<hr>
<h3 id="5-方法"><a href="#5-方法" class="headerlink" title="5. 方法"></a>5. 方法</h3><ul>
<li>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中</li>
<li>操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置</li>
</ul>
<p><strong>解析	int i &#x3D; 0; int j &#x3D; i + 1;</strong></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027163754.png" style="zoom:67%;">

<ul>
<li>iconst_0: 把0放入操作上栈</li>
<li>istore_1: 从操作数栈取出放入 局部变量表1号位置</li>
<li>iload_1: 将局部变量表1中的数 据放入操作数栈</li>
<li>iconst_1: 将常量1放入操作数栈</li>
<li>iadd: 将操作数栈顶部的两个 数据进行累加,结果放入栈中</li>
<li>istore_2: 将相加后的结果取出放入局部变量表2号位置</li>
<li>return: 方法结束、返回</li>
</ul>
<br>

<p><strong>解析	i &#x3D; 0; i &#x3D; i++;</strong></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027164322.png" style="zoom:67%;">

<br>

<p><strong>解析	i &#x3D; 0; i &#x3D; ++i;</strong></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231027164338.png" style="zoom: 67%;">

<br>



<p><strong>int i &#x3D; 0; i &#x3D; i++;	最终i的值是多少?</strong></p>
<p>最终i的值是0，通过分析字节码文件发现，i++ 是先把0取出来放入操作数栈中，接下来在局部变量表中对i进行加1，i变成了1，最近再将之前操作数栈中的0取出来放入i，最后i就变成了0</p>
<br>



<hr>
<h3 id="6-字节码文件常用工具"><a href="#6-字节码文件常用工具" class="headerlink" title="6. 字节码文件常用工具"></a>6. 字节码文件常用工具</h3><ul>
<li>javap -v 命令</li>
<li>jclasslib插件</li>
<li>阿里arthas</li>
</ul>
<br>

<p><strong>javao -v命令</strong></p>
<ul>
<li>javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内 容</li>
<li>直接输入javap查看所有参数</li>
<li>输入javap -v 字节码文件名称 查看具体的字节码信息。（如果jar包需要先使用 jar –xvf 命令解压）</li>
</ul>
<br>

<p><strong>jclasslib	idea插件</strong></p>
<p>jclasslib也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码 文件内容</p>
<p>首先应该下载并安装插件<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028121044.png" style="zoom: 50%;"></p>
<br>

<p>编译完代码后即可打开字节码文件<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028121407.png"></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028121602.png" style="zoom:67%;">

<br>

<p><strong>阿里arthas</strong></p>
<ul>
<li>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修 改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率</li>
<li>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li>
<li>dump 类的全限定名：dump已加载类的字节码文件到特定目录</li>
<li>ad 类的全限定名： 反编译已加载类的源码</li>
</ul>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028122520.png" style="zoom:67%;">

<br>



<hr>
<h2 id="三-类的生命周期"><a href="#三-类的生命周期" class="headerlink" title="三. 类的生命周期"></a>三. 类的生命周期</h2><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133012.png" style="zoom:67%;">

<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133121.png" style="zoom: 50%;">

<br>

<h3 id="1-加载阶段"><a href="#1-加载阶段" class="headerlink" title="1.  加载阶段"></a>1.  加载阶段</h3><ol>
<li><p>加载(Loading)阶段第一步是<font color="red">类加载器</font>根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。 程序员可以使用Java代码拓展的不同的渠道<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133906.png" style="zoom:67%;"></p>
</li>
<li><p>类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133928.png" style="zoom:67%;"></p>
</li>
<li><p>类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。 生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028133958.png" style="zoom:67%;"></p>
</li>
<li><p>同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。 作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后)<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028134029.png" style="zoom:67%;"></p>
</li>
</ol>
<br>

<p>对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息,<font color="red">这样Java虚拟机就能很好地控制开发者访问数据的范围</font></p>
<img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028134100.png" style="zoom:67%;">

<br>



<hr>
<h3 id="2-连接阶段"><a href="#2-连接阶段" class="headerlink" title="2. 连接阶段"></a>2. 连接阶段</h3><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028141240.png" style="zoom:67%;">

<br>



<p><strong>验证</strong></p>
<p>连接的第一个环节是验证，验证的主要目的是检查Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与<br>主要包含4个部分</p>
<ol>
<li>文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求</li>
<li>元信息验证，例如类必须有父类（super不能为空）</li>
<li>验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去</li>
<li>符号引用验证，例如是否访问了其他类中private的方法等</li>
</ol>
<br>



<p><strong>准备</strong></p>
<p>准备阶段为静态变量（static）分配内存并设置初始值<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028142605.png" style="zoom:67%;"></p>
<p>准备阶段只会给静态变量赋初始值，而每一种基本数据类型和引用数据类型都有其初始值</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">o</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">引用数据类型</td>
<td align="center">null</td>
</tr>
</tbody></table>
<br>

<p>final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值<br><img src="/2023/10/17/JVM-%E5%9F%BA%E7%A1%80%E7%AF%87/20231028142623.png" style="zoom:67%;"></p>
<br>



<p><strong>解析</strong></p>
<ul>
<li>解析阶段主要是将常量池中的符号引用替换为直接引用</li>
<li>直接引用不在使用编号，而是使用内存中地址进行访问具体的数据</li>
</ul>
<br>



<hr>
<h3 id="3-初始化阶段"><a href="#3-初始化阶段" class="headerlink" title="3. 初始化阶段"></a>3. 初始化阶段</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JVM%E7%AF%87/">JVM篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-微服务面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-10-13T06:53:38.000Z" itemprop="datePublished">2023-10-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/">微服务</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231013145620.png" style="zoom:80%;">



<br>

<hr>
<h2 id="一-Spring-Cloud"><a href="#一-Spring-Cloud" class="headerlink" title="一. Spring Cloud"></a>一. Spring Cloud</h2><h3 id="1-Spring-Cloud的5大组件有哪些？"><a href="#1-Spring-Cloud的5大组件有哪些？" class="headerlink" title="1. Spring Cloud的5大组件有哪些？"></a>1. Spring Cloud的5大组件有哪些？</h3><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231013145753.png" style="zoom:67%;">

<ul>
<li>Eureka：注册中心</li>
<li>Ribbon：负载均衡</li>
<li>Feign：远程调用</li>
<li>Hystrix：服务熔断</li>
<li>Zuul&#x2F;Gateway：网关</li>
</ul>
<br>

<p>随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件</p>
<ul>
<li>注册中心：Nacos</li>
<li>负载均衡：Ribbon</li>
<li>服务调用：Feign</li>
<li>服务保护：sentinel</li>
<li>服务网关：Gateway</li>
</ul>
<br>



<hr>
<h3 id="2-Spring-Cloud是如何实现服务注册发现"><a href="#2-Spring-Cloud是如何实现服务注册发现" class="headerlink" title="2. Spring Cloud是如何实现服务注册发现"></a>2. Spring Cloud是如何实现服务注册发现</h3><ul>
<li>注册中心的核心作用是：服务注册和发现</li>
<li>常见的注册中心：eureka、nacos、zookeeper</li>
</ul>
<br>

<p><strong>Eureka的作用</strong></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014195203.png" style="zoom:67%;">



<br>

<p><strong>Nacos的作用</strong></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014195259.png" style="zoom:67%;">



<br>

<p><strong>服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</strong></p>
<ul>
<li>我们当时学习的时候采用的eureka作为注册中心，这个也是spring cloud体系中的一个核心组件</li>
<li><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等</li>
<li><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li>
<li><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除</li>
</ul>
<br>

<p><strong>Nacos和Eureka的区别</strong></p>
<ul>
<li>Nacos与eureka的共同点（注册中心）<ol>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ol>
</li>
<li>Nacos与Eureka的区别（注册中心）<ol>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ol>
</li>
<li>Nacos还支持了配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因</li>
</ul>
<br>

<hr>
<h3 id="3-负载均衡如何实现的"><a href="#3-负载均衡如何实现的" class="headerlink" title="3. 负载均衡如何实现的"></a>3. 负载均衡如何实现的</h3><ul>
<li>负载均衡 Ribbon，发起远程调用feign就会使用Ribbon</li>
<li>Ribbon负载均衡策略有哪些 ?</li>
<li>如果想自定义负载均衡策略如何实现 ?</li>
</ul>
<br>

<p><strong>Ribbon负载均衡流程</strong></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014195930.png" style="zoom:67%;">



<br>

<p><strong>Ribbon负载均衡策略</strong></p>
<ul>
<li><font color="red">RoundRobinRule：简单轮询服务列表来选择服务器</font></li>
<li><font color="red">WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</font></li>
<li><font color="red">RandomRule：随机选择一个可用的服务器</font></li>
<li>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li>
<li>RetryRule：重试机制的选择逻辑</li>
<li>AvailabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li>
<li><font color="red">ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</font></li>
</ul>
<br>

<p><strong>自定义负载均衡的实现</strong></p>
<p>可以自己创建类实现IRule接口 , 然后再通过配置类或者配置文件配置即可 ，通过定义IRule实现可以修改负载均衡规则，有两种方式：<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014200850.png" style="zoom:67%;"></p>
<br>

<p><strong>负载均衡如何实现的？</strong></p>
<p>微服务的负载均衡主要使用了一个组件Ribbon，比如，我们在使用feign远程调用的过程中，底层的负载均衡就是使用了ribbon</p>
<br>

<p><strong>Ribbon负载均衡策略有哪些？</strong></p>
<ul>
<li>RoundRobinRule：简单轮询服务列表来选择服务器</li>
<li>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</li>
<li>RandomRule：随机选择一个可用的服务器</li>
<li>ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询(默认)</li>
</ul>
<br>

<p><strong>如果想自定义负载均衡策略如何实现？</strong></p>
<p>提供了两种方式：</p>
<ol>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）</li>
</ol>
<br>

<hr>
<h3 id="4-什么是服务雪崩"><a href="#4-什么是服务雪崩" class="headerlink" title="4. 什么是服务雪崩"></a>4. 什么是服务雪崩</h3><p>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形<br>解决方法: 熔断降级</p>
<p><strong>服务降级</strong></p>
<p>服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014202100.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;leadnews-article&quot;, fallback = IArticleClientFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IArticleClient</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/api/v1/article/save&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">saveArticle</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ArticleDto dto)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IArticleClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IArticleClient</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">saveArticle</span><span class="hljs-params">(ArticleDto dto)</span> &#123;<br>        <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR, <span class="hljs-string">&quot;获取数据失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>服务熔断</strong></p>
<p>Hystrix 熔断机制，用于监控微服务调用情况， 默认是关闭的，如果需要开启需要在引导类上添加注解：@EnableCircuitBreaker<br>如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014202129.png" style="zoom:67%;">



<br>

<p><strong>什么是服务雪崩，怎么解决这个问题？</strong></p>
<ul>
<li>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</li>
<li>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑</li>
<li>服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</li>
</ul>
<br>

<hr>
<h3 id="5-微服务是怎么监控的"><a href="#5-微服务是怎么监控的" class="headerlink" title="5. 微服务是怎么监控的"></a>5. 微服务是怎么监控的</h3><p><strong>skywalking</strong></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231014203502.png" style="zoom:67%;">

<ul>
<li>服务（service）：业务资源应用系统（微服务）</li>
<li>端点（endpoint）：应用系统对外暴露的功能接口（接口）</li>
<li>实例（instance）：物理机</li>
</ul>
<br>

<p><strong>微服务是怎么监控的？</strong></p>
<p>我在学习的时候采用的skywalking进行监控的</p>
<ol>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li>
<li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li>
</ol>
<br>

<hr>
<h2 id="二-业务相关"><a href="#二-业务相关" class="headerlink" title="二. 业务相关"></a>二. 业务相关</h2><h3 id="1-限流的实现"><a href="#1-限流的实现" class="headerlink" title="1. 限流的实现"></a>1. 限流的实现</h3><p>为什么要限流？<br>并发量大（突发流量）、防止用户恶意刷接口</p>
<p>限流的实现方式：</p>
<ul>
<li>Tomcat：可以设置最大连接数</li>
<li>Nginx，漏桶算法</li>
<li>网关，令牌桶算法</li>
<li>自定义拦截器</li>
</ul>
<br>

<p><strong>Nginx限流</strong></p>
<p>控制速率（突发流量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">http &#123;<br>    limit_req_zone $binary_remote_addr zone=servicelRateLimit:10m rate=10r/s<br>    server &#123;<br>        listen	<span class="hljs-number">80</span>;<br>        server_name localhost;<br>        location / &#123;<br>            limit_req_zone = servicelRateLimit burst=<span class="hljs-number">20</span> nodelay;<br>            proxy_pass http:<span class="hljs-comment">//targetserver;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>语法: limit_req_zone key zone rate</li>
<li>key:定义限流对象，binary_remote_addr就是一种key，基于客户端ip限流</li>
<li>Zone：定义共享存储区来存储访问信息，10m可以存储16wip地址访问信息</li>
<li>Rate：最大访问速率，rate&#x3D;10r&#x2F;s 表示每秒最多请求10个请求</li>
<li>burst&#x3D;20：相当于桶的大小</li>
<li>Nodelay：快速处理</li>
</ul>
<br>

<p>控制并发连接数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">http &#123;<br>    limit_conn_zone $binary_remote_addr zone=perip:10m;<br>    limit_conn_zone $server_name zone=perserver:10m;<br>    server &#123;<br>        listen 	<span class="hljs-number">80</span>;<br>        server_name localhost;<br>        location / &#123;<br>            ...<br>            limit_conn perip <span class="hljs-number">20</span>;<br>            limit_conn perserver <span class="hljs-number">100</span>;<br>            proxy_pass http:<span class="hljs-comment">//targetserver;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>limit_conn perip 20：对应的key是 $binary_remote_addr，表示限制单个IP同时最多能持有20个连接。</li>
<li>limit_conn perserver 100：对应的key是 $server_name，表示虚拟主机(server) 同时能处理并发连接的总数</li>
</ul>
<br>

<p><strong>网关限流</strong></p>
<p>yml配置文件中，微服务路由设置添加局部过滤器RequestRateLimiter</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">id:</span> <span class="hljs-string">gateway-consumer</span><br><span class="hljs-attr">uri:</span> <span class="hljs-string">lb://GATEWAY-CONSUMER</span><br><span class="hljs-attr">predicates:</span><br>	<span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span><br><span class="hljs-attr">filters:</span><br>	<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span><br>	  <span class="hljs-attr">args:</span><br>	  	<span class="hljs-comment"># 使用SpEL从容器中获取对象</span><br>	  	<span class="hljs-attr">key-resolver:</span> <span class="hljs-string">&#x27;#&#123;@pathKeyResolver&#125;&#x27;</span><br>	  	<span class="hljs-comment"># 命令桶每秒填充平均速率</span><br>	  	<span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">1</span><br>	  	<span class="hljs-comment"># 命令桶的上限</span><br>	  	<span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>key-resolver ：定义限流对象（ ip 、路径、参数），需代码实现，使用spel表达式获取</li>
<li>replenishRate ：令牌桶每秒填充平均速率。</li>
<li>urstCapacity ：令牌桶总容量。</li>
</ul>
<br>



<hr>
<h3 id="2-CAP和BASE"><a href="#2-CAP和BASE" class="headerlink" title="2. CAP和BASE"></a>2. CAP和BASE</h3><p><strong>CAP定理</strong></p>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance （分区容错性）</li>
</ul>
<p>Eric Brewer 说，分布式系统无法同时满足这三个指标<br>这个结论就叫做 CAP 定理。</p>
<br>

<p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017212903.png" style="zoom:67%;"></p>
<br>

<p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017212937.png" style="zoom:60%;"></p>
<br>

<p>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。<br>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017213002.png" style="zoom:67%;"></p>
<br>

<ul>
<li>分布式系统节点之间肯定是需要网络连接的，分区（P）是必然存在的</li>
<li>如果保证访问的高可用性（A）,可以持续对外提供服务，但不能保证数据的强一致性–&gt; AP</li>
<li>如果保证访问的数据强一致性（C）,就要放弃高可用性  –&gt; CP</li>
</ul>
<br>

<p><strong>BASE理论</strong></p>
<p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>BasicallyAvailable （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li>
<li>Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li>
</ul>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017213036.png" style="zoom:67%;">

<br>

<p><strong>解释一下CAP和BASE</strong></p>
<ul>
<li>CAP 定理(一致性、可用性、分区容错性)<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题（P）</li>
<li>当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足</li>
</ol>
</li>
<li>BASE理论<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
</li>
<li>解决分布式事务的思想和模型<ol>
<li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li>
<li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）</li>
</ol>
</li>
</ul>
<br>



<hr>
<h3 id="3-分布式事务解决方案"><a href="#3-分布式事务解决方案" class="headerlink" title="3. 分布式事务解决方案"></a>3. 分布式事务解决方案</h3><p>你采用哪种分布式事务解决方法？</p>
<ul>
<li>Seata框架（XA、AT、TCC）</li>
<li>MQ</li>
</ul>
<br>

<p><strong>Seata框架</strong></p>
<p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li>
<li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214433.png" style="zoom: 80%;">



<br>

<p><strong>Seata的XA模式</strong></p>
<p>RM一阶段的工作：</p>
<ol>
<li>注册分支事务到TC</li>
<li>执行分支业务SQL但不提交</li>
<li>报告执行状态到TC</li>
</ol>
<p>TC二阶段的工作：</p>
<ul>
<li>TC检测各分支事务执行状态<ul>
<li>如果都成功，通知所有RM提交事务</li>
<li>如果有失败，通知所有RM回滚事务</li>
</ul>
</li>
</ul>
<p>RM二阶段的工作：</p>
<ul>
<li>接受TC指令，提交或回滚事务</li>
</ul>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214725.png" style="zoom: 80%;">



<br>

<p><strong>AT模式原理</strong></p>
<p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷</p>
<p>阶段一RM的工作：</p>
<ul>
<li>注册分支事务</li>
<li>记录undo-log（数据快照）</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ul>
<p>阶段二提交时RM的工作：</p>
<ul>
<li>删除undo-log即可</li>
</ul>
<p>阶段二回滚时RM的工作：</p>
<ul>
<li>根据undo-log恢复数据到更新前</li>
</ul>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214744.png" style="zoom: 80%;">



<br>

<p><strong>TCC模式原理</strong></p>
<ol>
<li>Try：资源的检测和预留； </li>
<li>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</li>
<li>Cancel：预留资源释放，可以理解为try的反向操作。</li>
</ol>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214807.png" style="zoom:80%;">



<br>

<p><strong>MQ分布式事务</strong></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017214832.png" style="zoom:80%;">

<p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好</p>
<br>



<hr>
<h3 id="4-分布式服务的接口幂等性设计"><a href="#4-分布式服务的接口幂等性设计" class="headerlink" title="4. 分布式服务的接口幂等性设计"></a>4. 分布式服务的接口幂等性设计</h3><p>幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</p>
<p>需要幂等场景</p>
<ul>
<li>用户重复点击(网络波动)</li>
<li>MQ消息重复</li>
<li>应用使用失败或超时重试机制</li>
</ul>
<br>

<p><strong>接口幂等</strong></p>
<p>基于RESTful API的角度对部分常见类型请求的幂等性特点进行分析</p>
<table>
<thead>
<tr>
<th><strong>请求方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>查询操作，天然幂等</td>
</tr>
<tr>
<td>POST</td>
<td>新增操作，请求一次与请求多次造成的结果不同，不是幂等的</td>
</tr>
<tr>
<td>PUT</td>
<td>更新操作，如果是以绝对值更新，则是幂等的。如果是通过增量的方式更新，则不是幂等的</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除操作，根据唯一值删除，是幂等的</td>
</tr>
</tbody></table>
<br>

<p><strong>token+redis</strong></p>
<p>创建商品、提交订单、转账、支付等操作</p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017220614.png" style="zoom:67%;">



<br>

<p><strong>分布式锁</strong></p>
<ul>
<li>快速失败（抢不到锁的线程）</li>
<li>控制锁的力度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrder</span><span class="hljs-params">(Item item)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//获取锁（重入锁），执行锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;heimalock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//判断是否获取成功</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            log.info(<span class="hljs-string">&quot;下单操作获取锁失败,order:&#123;&#125;&quot;</span>,item);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;新增或修改失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//下单操作</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>分布式服务的接口幂等性如何设计？</strong></p>
<ul>
<li>幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</li>
<li>如果是新增数据，可以使用数据库的唯一索引</li>
<li>如果是新增或修改数据<ul>
<li>分布式锁，性能较低</li>
<li>使用token+redis来实现，性能较好<ul>
<li>第一次请求，生成一个唯一token存入redis，返回给前端</li>
<li>第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token；如果不存在，则直接返回，不处理业务</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>



<hr>
<h3 id="5-分布式任务调度"><a href="#5-分布式任务调度" class="headerlink" title="5. 分布式任务调度"></a>5. 分布式任务调度</h3><p><strong>XXL-JOB解决的问题</strong></p>
<ul>
<li>解决集群任务的重复执行问题</li>
<li>cron表达式定义灵活</li>
<li>定时任务失败了，重试和统计</li>
<li>任务量大，分片执行</li>
</ul>
<br>



<p><strong>XXL-JOB路由策略有哪些？</strong></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017224713.png" style="zoom: 80%;">

<ol>
<li>FIRST（第一个）：固定选择第一个机器；</li>
<li>LAST（最后一个）：固定选择最后一个机器；</li>
<li>ROUND（轮询）</li>
<li>RANDOM（随机）：随机选择在线的机器；</li>
<li>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</li>
<li>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</li>
<li>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</li>
<li>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</li>
<li>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</li>
<li>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</li>
</ol>
<br>

<p><strong>XXL-JOB任务执行失败怎么解决？</strong></p>
<p>故障转移+失败重试，查看日志分析—-&gt; 邮件告警<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017225001.png" style="zoom:67%;"></p>
<img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017225020.png" style="zoom:80%;">



<br>

<p><strong>如果有大数据量的任务同时都需要执行，怎么解决？</strong></p>
<p>执行器集群部署时，任务路由策略选择分片广播情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务<br><img src="/2023/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/20231017225039.png" style="zoom:67%;"></p>
<p>分片参数</p>
<ul>
<li>index：当前分片序号(从0开始)，执行器集群列表中当前执行器的序号；</li>
<li>total：总分片数，执行器集群的总机器数量；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@XxlJob(&quot;shadingSample&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shardingJobHandler</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 分片参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">shardIndex</span> <span class="hljs-operator">=</span> XxlJobHelper.getShardIndex();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">shardTotal</span> <span class="hljs-operator">=</span> XxlJobHelper.getShardTotal();<br>    XxlJobHelper.log(<span class="hljs-string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);<br>    <span class="hljs-comment">// 业务逻辑</span><br>    List&lt;Integer&gt; list = getList();<br>    <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>        <span class="hljs-keyword">if</span>(integer % shardTotal == shardIndex)&#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span>+shardIndex+<span class="hljs-string">&quot;分片执行，执行数据为：&quot;</span>+integer);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>xxl-job路由策略有哪些？</strong><br>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</p>
<p><strong>xxl-job任务执行失败怎么解决？</strong></p>
<ul>
<li>路由策略选择故障转移，使用健康的实例来执行任务</li>
<li>设置重试次数</li>
<li>查看日志+邮件告警来通知相关负责人解决</li>
</ul>
<p><strong>如果有大数据量的任务同时都需要执行，怎么解决？</strong></p>
<ul>
<li>让多个实例一块去执行（部署集群），路由策略分片广播</li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-多线程面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-10-09T01:18:36.000Z" itemprop="datePublished">2023-10-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/">多线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009092213.png"></p>
<br>

<hr>
<h2 id="一-线程的基础知识"><a href="#一-线程的基础知识" class="headerlink" title="一. 线程的基础知识"></a>一. 线程的基础知识</h2><h3 id="1-线程与进程的区别"><a href="#1-线程与进程的区别" class="headerlink" title="1. 线程与进程的区别"></a>1. 线程与进程的区别</h3><p>程序由<font color="red">指令</font>和<font color="red">数据</font>组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的<br><font color="red">当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</font></p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009092934.png" style="zoom: 50%;">

<br>

<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>一个进程之内可以分为一到多个线程。</p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009092953.png" style="zoom:67%;">

<br>

<p><strong>二者对比</strong></p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<br>



<hr>
<h3 id="2-并行与并发有什么区别"><a href="#2-并行与并发有什么区别" class="headerlink" title="2. 并行与并发有什么区别"></a>2. 并行与并发有什么区别</h3><p><strong>单核CPU</strong></p>
<ul>
<li>单核CPU下线程实际还是串行执行的</li>
<li>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</li>
<li>总结为一句话就是： 微观串行，宏观并行</li>
<li>一般会将这种线程轮流使用CPU的做法称为并发</li>
</ul>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009094008.png" style="zoom: 67%;">



<br>

<p><strong>多核CPU</strong></p>
<p>每个核都可以调度运行线程，这时候线程可以是并行的<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009094026.png" style="zoom: 80%;"></p>
<p>&lt;br&#x2F; &gt;</p>
<p><strong>两者区别</strong></p>
<p>并发（concurrent）是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）是同一时间动手做（doing）多件事情的能力</p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li>
<li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li>
<li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li>
</ul>
<br>

<p><strong>总结</strong></p>
<p>现在都是多核CPU，在多核CPU下</p>
<ul>
<li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li>
<li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li>
</ul>
<br>



<hr>
<h3 id="3-创建线程的方式"><a href="#3-创建线程的方式" class="headerlink" title="3. 创建线程的方式"></a>3. 创建线程的方式</h3><p>共有四种方式可以创建线程，分别是：</p>
<ul>
<li><p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread...run...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建MyThread对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;<br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>


</li>
<li><p>实现runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyRunnable...run...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建MyRunnable对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">// 创建Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);<br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>


</li>
<li><p>实现Callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建MyCallable对象</span><br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>() ;<br>        <span class="hljs-comment">// 创建FutureTask</span><br>        FutureTask&lt;String&gt; ft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(mc) ;<br>        <span class="hljs-comment">// 创建Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft) ;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft) ;<br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        <span class="hljs-comment">// 调用ft的get方法获取执行结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ft.get();<br>        <span class="hljs-comment">// 输出</span><br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>


</li>
<li><p>线程池创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExecutors</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyRunnable...run...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        threadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyExecutors</span>()) ;<br>        <span class="hljs-comment">// 关闭线程池</span><br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<br>

<p><strong>runnable和callable有什么区别</strong></p>
<ol>
<li>Runnable 接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ol>
<br>

<p><strong>线程的run()和start()有什么区别</strong></p>
<p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。<br>run(): 封装了要被线程执行的代码，可以被调用多次。</p>
<br>

<p><strong>总结</strong></p>
<ol>
<li><p>创建线程的方法</p>
<ul>
<li>继承Thread类</li>
<li>实现runnable接口</li>
<li>实现Callable接口</li>
<li>线程池创建线程(项目中使用方式)</li>
</ul>
</li>
<li><p>runnable和callable有什么区别</p>
<ul>
<li>Runnable 接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，需要FutureTask获取结果</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ul>
</li>
<li><p>run()和start()有什么区别</p>
<ul>
<li>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li>
<li>run(): 封装了要被线程执行的代码，可以被调用多次。</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="4-线程包括哪些状态，状态之间是如何变化的"><a href="#4-线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="4. 线程包括哪些状态，状态之间是如何变化的"></a>4. 线程包括哪些状态，状态之间是如何变化的</h3><p>线程的状态可以参考JDK中的Thread类中的枚举State</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">//尚未启动的线程的线程状态</span><br>    NEW,<br>    <span class="hljs-comment">//可运行线程的线程状态。</span><br>    RUNNABLE,<br>    <span class="hljs-comment">//线程阻塞等待监视器锁的线程状态。</span><br>    BLOCKED,     <br>    <span class="hljs-comment">//等待线程的线程状态</span><br>    WAITING,<br>    <span class="hljs-comment">//具有指定等待时间的等待线程的线程状态</span><br>    TIMED_WAITING,<br>    <span class="hljs-comment">//已终止线程的线程状态。线程已完成执行</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009111306.png"></p>
<br>

<p><strong>总结</strong></p>
<ol>
<li><p>线程包括哪些状态</p>
<p>新建（NEW）、可运行（RUNNABLE）、阻塞（BLOCKED）、等待（ WAITING ）、时间等待（TIMED_WALTING）、终止（TERMINATED）</p>
</li>
<li><p>线程状态之间是如何变化的</p>
<ul>
<li>创建线程对象是新建状态</li>
<li>调用了start()方法转变为可执行状态</li>
<li>线程获取到了CPU的执行权，执行结束是终止状态</li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul>
<li>如果没有获取锁（synchronized或lock）进入阻塞状态，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态</li>
<li>如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="5-新建三个线程，如何保证他们按顺序执行"><a href="#5-新建三个线程，如何保证他们按顺序执行" class="headerlink" title="5.  新建三个线程，如何保证他们按顺序执行"></a>5.  新建三个线程，如何保证他们按顺序执行</h3><p>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？<br>可以使用线程中的join方法解决<br><font face="仿宋">join() 	等待线程运行结束</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;t1&quot;</span>);<br>&#125;) ;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t1.join();                          <span class="hljs-comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;t2&quot;</span>);<br>&#125;) ;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t2.join();                              <span class="hljs-comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;t3&quot;</span>);<br>&#125;) ;<br><span class="hljs-comment">// 启动线程</span><br>t1.start();<br>t2.start();<br>t3.start();<br></code></pre></td></tr></table></figure>



<br>



<hr>
<h3 id="6-notify-和notifyAll-有什么区别"><a href="#6-notify-和notifyAll-有什么区别" class="headerlink" title="6. notify()和notifyAll()有什么区别"></a>6. notify()和notifyAll()有什么区别</h3><ul>
<li>notifyAll：唤醒所有wait的线程</li>
<li>notify：只随机唤醒一个 wait 线程</li>
</ul>
<br>



<hr>
<h3 id="7-Java中的wait和sleep方法的不同"><a href="#7-Java中的wait和sleep方法的不同" class="headerlink" title="7. Java中的wait和sleep方法的不同"></a>7. Java中的wait和sleep方法的不同</h3><p><strong>共同点</strong>：<br>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</p>
<p><strong>不同点：</strong></p>
<ol>
<li><p>方法的归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p>锁特性不同</p>
<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li>
<li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="8-如何停止一个正在运行的线程"><a href="#8-如何停止一个正在运行的线程" class="headerlink" title="8. 如何停止一个正在运行的线程"></a>8. 如何停止一个正在运行的线程</h3><p>有三种方式可以停止线程</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止（不推荐，方法已作废）</li>
<li>使用interrupt方法中断线程<ul>
<li>打断阻塞的线程（ sleep，wait，join ）的线程，线程会抛出InterruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<br>



<hr>
<h2 id="二-线程中的并发安全"><a href="#二-线程中的并发安全" class="headerlink" title="二. 线程中的并发安全"></a>二. 线程中的并发安全</h2><h3 id="1-synchronized关键字的底层原理"><a href="#1-synchronized关键字的底层原理" class="headerlink" title="1. synchronized关键字的底层原理"></a>1. synchronized关键字的底层原理</h3><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTicket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">if</span> (ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到一张票,剩余:&quot;</span> + ticketNum);<br>            <span class="hljs-comment">// 非原子性操作</span><br>            ticketNum--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TicketDemo</span> <span class="hljs-variable">ticketDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                ticketDemo.getTicket();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>Monitor</strong></p>
<p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009112831.png" style="zoom:67%;">

<ul>
<li>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</li>
<li>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</li>
<li>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</li>
</ul>
<br>

<p><strong>总结</strong></p>
<ul>
<li>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li>
<li>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</li>
<li>在monitor内部有三个属性，分别是owner、entrylist、waitset</li>
<li>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</li>
</ul>
<br>



<hr>
<h3 id="2-Java内存模型-JMV"><a href="#2-Java内存模型-JMV" class="headerlink" title="2. Java内存模型(JMV)"></a>2. Java内存模型(JMV)</h3><p>JMM(Java Memory Model)Java内存模型，定义了<font color="red">共享内存</font>中<font color="red">多线程程序读写操作</font>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009113241.png" style="zoom:67%;"></p>
<br>

<p><strong>总结</strong></p>
<ul>
<li>JMM(Java Memory Model)Java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</li>
<li>线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存</li>
</ul>
<br>



<hr>
<h3 id="3-CAS"><a href="#3-CAS" class="headerlink" title="3. CAS"></a>3. CAS</h3><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性<br>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p>
<br>

<p><strong>CAS</strong></p>
<ul>
<li>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</li>
<li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用的自旋锁，效率上更高一些</li>
<li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li>
</ul>
<br>

<p><strong>乐观锁和悲观锁的区别</strong></p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
</ul>
<br>



<hr>
<h3 id="4-对volatile的理解"><a href="#4-对volatile的理解" class="headerlink" title="4. 对volatile的理解"></a>4. 对volatile的理解</h3><p>volatile是Java提供的一种轻量级的同步机制。Java语言包含两种内在的同步机制：同步块（方法）和volatile变量，相比于synchronized,volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile变量的同步性较差，而且其使用也更容易出错</p>
<ul>
<li>保证线程间的可见性<br>用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li>
<li>禁止进行指令重排序<br>指令重排：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li>
</ul>
<br>



<hr>
<h3 id="5-什么是AQS"><a href="#5-什么是AQS" class="headerlink" title="5. 什么是AQS"></a>5. 什么是AQS</h3><p>全称是 AbstractQueuedSynchronizer，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架</p>
<p>AQS与Synchronized的区别</p>
<table>
<thead>
<tr>
<th><strong>synchronized</strong></th>
<th><strong>AQS</strong></th>
</tr>
</thead>
<tbody><tr>
<td>关键字，c++ 语言实现</td>
<td>java  语言实现</td>
</tr>
<tr>
<td>悲观锁，自动释放锁</td>
<td>悲观锁，手动开启和关闭</td>
</tr>
<tr>
<td>锁竞争激烈都是重量级锁，性能差</td>
<td>锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody></table>
<br>

<p>AQS常见的实现类：</p>
<ul>
<li>ReentrantLock      阻塞式锁</li>
<li>Semaphore        信号量</li>
<li>CountDownLatch   倒计时锁</li>
</ul>
<br>

<p><strong>AQS是公平锁还是非公平锁</strong></p>
<ul>
<li>新的线程与队列中的线程共同来抢资源，是非公平锁</li>
<li>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</li>
</ul>
<br>

<p><strong>什么是AQS</strong></p>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li>
<li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li>
</ul>
<br>



<hr>
<h3 id="6-ReentrantLock的实现原理"><a href="#6-ReentrantLock的实现原理" class="headerlink" title="6. ReentrantLock的实现原理"></a>6. ReentrantLock的实现原理</h3><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁</li>
<li>支持多个条件变量</li>
<li>与synchronized一样，都支持重入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建锁对象</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    lock.lock();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似<br>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量</p>
<p>查看ReentrantLock源码中的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009133842.png" style="zoom:67%;">

<ul>
<li>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</li>
<li>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</li>
<li>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</li>
<li>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</li>
</ul>
<br>

<p><strong>总结</strong></p>
<ul>
<li>ReentrantLock表示支持重新进入的锁，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞</li>
<li>ReentrantLock主要利用CAS+AQS队列来实现</li>
<li>支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁</li>
</ul>
<br>



<hr>
<h3 id="7-synchronized和Lock有什么区别"><a href="#7-synchronized和Lock有什么区别" class="headerlink" title="7. synchronized和Lock有什么区别"></a>7. synchronized和Lock有什么区别</h3><ul>
<li><p>语法层面</p>
<p>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现<br>Lock 是接口，源码由 jdk 提供，用 java 语言实现<br>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</p>
</li>
<li><p>功能层面</p>
<p>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能<br>Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变<br>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁)</p>
</li>
<li><p>性能层面</p>
<p>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖<br>在竞争激烈时，Lock 的实现通常会提供更好的性能</p>
</li>
</ul>
<br>



<hr>
<h3 id="8-死锁产生的条件"><a href="#8-死锁产生的条件" class="headerlink" title="8. 死锁产生的条件"></a>8. 死锁产生的条件</h3><p>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<p><strong>如何进行死锁诊断</strong></p>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p>
<ul>
<li>jps：输出JVM中运行的进程状态信息</li>
<li>jstack：查看java进程内线程的堆栈信息</li>
</ul>
<p>可视化工具</p>
<ul>
<li><p>jconsole</p>
<p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具<br>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p>
</li>
<li><p>VisuaIVM</p>
<p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈<br>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>
</li>
</ul>
<br>

<p><strong>总结</strong></p>
<ol>
<li><p>死锁产生的条件是什么？</p>
<p>一个线程需要同时获取多把锁，这时就容易发生死锁</p>
</li>
<li><p>如何进行死锁诊断？</p>
<ul>
<li>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</li>
<li>jps：输出JVM中运行的进程状态信息</li>
<li>jstack：查看java进程内线程的堆栈信息，查看日志，检查是否有死锁如果有死锁现象，需要查看具体代码分析后，可修复</li>
<li>可视化工具jconsole、VisualVM也可以检查死锁问题</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="9-ConcurrentHashMap"><a href="#9-ConcurrentHashMap" class="headerlink" title="9. ConcurrentHashMap"></a>9. ConcurrentHashMap</h3><p>ConcurrentHashMap 是一种线程安全的高效Map集合<br>底层数据结构：</p>
<ul>
<li>JDK1.7底层采用分段的数组+链表实现</li>
<li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li>
</ul>
<br>

<p><strong>JDK1.7中的ConcurrentHashMap</strong></p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009140109.png" style="zoom:67%;">

<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009140127.png" style="zoom: 67%;">



<br>



<p><strong>JDK1.8中的ConcurrentHashMap</strong></p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表<br>采用 CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li>CAS控制数组节点的添加</li>
<li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</li>
</ul>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009140142.png" style="zoom:67%;">

<br>

<p><strong>总结</strong></p>
<p>聊一下ConcurrentHashMap</p>
<ol>
<li>底层数据结构<ul>
<li>JDK1.7底层采用分段的数组+链表实现</li>
<li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</li>
</ul>
</li>
<li>加锁的方式<ul>
<li>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock</li>
<li>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="10-导致并发程序出现问题的根本原因是什么"><a href="#10-导致并发程序出现问题的根本原因是什么" class="headerlink" title="10. 导致并发程序出现问题的根本原因是什么"></a>10. 导致并发程序出现问题的根本原因是什么</h3><p>Java并发编程三大特性</p>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<br>



<p><strong>原子性：</strong>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p>
<p>不是原子操作，怎么保证原子操作？</p>
<ol>
<li>synchronized: 同步锁</li>
<li>JUC里面的lock: 加锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTicket</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到一张票,剩余:&quot;</span>+ticketNum);<br>    <span class="hljs-comment">// 非原子性操作</span><br>    ticketNum--;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">TicketDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketDemo</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(demo::getTicket).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<br>



<p><strong>内存可见性：</strong>让一个线程对共享变量的修改对另一个线程可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(!flag)&#123;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第一个线程执行完毕...&quot;</span>);<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>           System.out.println(<span class="hljs-string">&quot;第二线程执行完毕...&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决方案：</p>
<ul>
<li>synchronized</li>
<li>volatile</li>
<li>LOCK</li>
</ul>
<br>

<p><strong>有序性</strong></p>
<p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<p>解决方案：volatile</p>
<br>



<hr>
<h2 id="三-线程池"><a href="#三-线程池" class="headerlink" title="三. 线程池"></a>三. 线程池</h2><h3 id="1-线程池的核心参数"><a href="#1-线程池的核心参数" class="headerlink" title="1. 线程池的核心参数"></a>1. 线程池的核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数目</li>
<li>maximumPoolSize 最大线程数目 &#x3D; (核心线程+救急线程的最大数目)</li>
<li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li>
<li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</li>
</ul>
<br>



<hr>
<h3 id="2-线程池的执行原理"><a href="#2-线程池的执行原理" class="headerlink" title="2. 线程池的执行原理"></a>2. 线程池的执行原理</h3><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009142041.png" style="zoom:80%;">

<ol>
<li>AbortPolicy：直接抛出异常，默认策略；</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ol>
<p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p>
<br>



<hr>
<h3 id="3-线程池中有哪些常见的阻塞队列"><a href="#3-线程池中有哪些常见的阻塞队列" class="headerlink" title="3. 线程池中有哪些常见的阻塞队列"></a>3. 线程池中有哪些常见的阻塞队列</h3><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<ol>
<li><font color="red">ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO</font></li>
<li><font color="red">LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO</font></li>
<li>DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li>
</ol>
<br>

<p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p>
<table>
<thead>
<tr>
<th><strong>LinkedBlockingQueue</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认无界，支持有界</td>
<td>强制有界</td>
</tr>
<tr>
<td>底层是链表</td>
<td>底层是数组</td>
</tr>
<tr>
<td>是懒惰的，创建节点的时候添加数据</td>
<td>提前初始化 Node  数组</td>
</tr>
<tr>
<td>入队会生成新 Node</td>
<td>Node需要是提前创建好的</td>
</tr>
<tr>
<td>两把锁（头尾）</td>
<td>一把锁</td>
</tr>
</tbody></table>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009142425.png" style="zoom: 67%;">



<br>



<hr>
<h3 id="4-如何确定核心线程数"><a href="#4-如何确定核心线程数" class="headerlink" title="4. 如何确定核心线程数"></a>4. 如何确定核心线程数</h3><ul>
<li><p>IO密集型任务</p>
<p>一般来说：文件读写、DB读写、网络请求等		<font color="red">核心线程数大小设置为2N+1</font>.</p>
</li>
<li><p>CPU密集型任务</p>
<p>一般来说：计算型代码、Bitmap转换、Gson转换等		<font color="red">核心线程数大小设置为N+1</font></p>
</li>
</ul>
<p>查看机器的CPU核心数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//查看机器的CPU核数</span><br>    System.out.println(Runtime.getRuntime().availableProcessors());<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>参考回答</strong></p>
<ol>
<li>高并发、任务执行时间短 à（ CPU核数+1 ），减少线程上下文的切换</li>
<li>并发不高、任务执行时间长<ul>
<li>IO密集型的任务 à (CPU核数 * 2 + 1)</li>
<li>计算密集型任务 à（ CPU核数+1 ）</li>
</ul>
</li>
<li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步</li>
</ol>
<br>



<hr>
<h3 id="5-线程池的种类有哪些"><a href="#5-线程池的种类有哪些" class="headerlink" title="5. 线程池的种类有哪些"></a>5. 线程池的种类有哪些</h3><p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p>
<ol>
<li><p>创建使用固定线程数的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>核心线程数与最大线程数一样，没有救急线程</li>
<li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li>
</ul>
<p><font color="red">适用于任务量已知，相对耗时的任务</font></p>
<br>


</li>
<li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>核心线程数和最大线程数都是1</li>
<li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li>
</ul>
<p><font color="red">适用于按照顺序执行的任务</font></p>
<br>


</li>
<li><p>可缓存线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>核心线程数为0</li>
<li>最大线程数是Integer.MAX_VALUE</li>
<li>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li>
</ul>
<p><font color="red">适合任务数比较密集，但每个任务执行时间较短的情况</font></p>
<br>


</li>
<li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                     RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure>

<br></li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行</li>
</ol>
<br>



<hr>
<h3 id="6-为什么不建议使用Executors创建线程池"><a href="#6-为什么不建议使用Executors创建线程池" class="headerlink" title="6. 为什么不建议使用Executors创建线程池"></a>6. 为什么不建议使用Executors创建线程池</h3><p>参考阿里开发手册《Java开发手册-嵩山版》<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009145736.png" style="zoom:67%;"></p>
<br>



<hr>
<h2 id="四-使用场景"><a href="#四-使用场景" class="headerlink" title="四. 使用场景"></a>四. 使用场景</h2><h3 id="1-哪些地方用到了多线程"><a href="#1-哪些地方用到了多线程" class="headerlink" title="1. 哪些地方用到了多线程"></a>1. 哪些地方用到了多线程</h3><p><strong>CountDownLatch</strong></p>
<p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li>await() 用来等待计数归零</li>
<li>countDown() 用来让计数减一</li>
</ul>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009150909.png" style="zoom:67%;">

<br>

<p><strong>多线程使用场景一（es数据批量导入）</strong></p>
<p>在项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151024.png" style="zoom:67%;">

<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151042.png" style="zoom:67%;">



<br>

<p><strong>多线程使用场景二 （数据汇总）</strong></p>
<p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151105.png" style="zoom:67%;">



<br>

<ul>
<li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</li>
<li>报表汇总<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151124.png" style="zoom: 67%;"></li>
</ul>
<br>

<p><strong>多线程使用场景三（异步调用）</strong></p>
<img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009151146.png" style="zoom:67%;">



<br>

<p><strong>总结</strong></p>
<ul>
<li><font color="red">批量导入</font>：使用了线程池+CountDownLatch批量把数据库中的数据导入到了ES(任意)中，避免OOM</li>
<li><font color="red">数据汇总</font>：调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</li>
<li><font color="red">异步线程（线程池）</font>：为了避免下一级方法影响上一级方法（性能考虑），可使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间</li>
</ul>
<br>



<hr>
<h3 id="2-如何控制某个方法允许并发访问线程的数量"><a href="#2-如何控制某个方法允许并发访问线程的数量" class="headerlink" title="2. 如何控制某个方法允许并发访问线程的数量"></a>2. 如何控制某个方法允许并发访问线程的数量</h3><p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量<br>使用场景：<br>通常用于那些资源有明确访问数量限制的场景，常用于限流 。</p>
<p><strong>使用步骤</strong></p>
<ul>
<li>创建Semaphore对象，可以给一个容量</li>
<li>semaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</li>
<li>semaphore.release()：释放一个信号量，此时信号量个数+1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 semaphore 对象</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 10个线程同时运行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 3. 获取许可</span><br>        semaphore.acquire();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 4. 释放许可</span><br>        semaphore.release();<br>    &#125;<br>&#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>总结</strong></p>
<p>在多线程中提供了一个工具类Semaphore，信号量。在并发的情况下，可以控制方法的访问量</p>
<ol>
<li>创建Semaphore对象，可以给一个容量</li>
<li>acquire()可以请求一个信号量，这时候的信号量个数-1</li>
<li>release()释放一个信号量，此时信号量个数+1</li>
</ol>
<br>



<hr>
<h3 id="3-对ThreadLocal的理解"><a href="#3-对ThreadLocal的理解" class="headerlink" title="3. 对ThreadLocal的理解"></a>3. 对ThreadLocal的理解</h3><p><strong>ThreadLocal的概述</strong></p>
<p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009152025.png" style="zoom: 67%;"></p>
<br>

<p><strong>ThreadLocal的基本使用</strong></p>
<ul>
<li>set(value) 设置值</li>
<li>get() 获取值</li>
<li>remove() 清除值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        threadLocal.set(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        print(name);<br>        System.out.println(name + <span class="hljs-string">&quot;-after remove : &quot;</span> + threadLocal.get());<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        threadLocal.set(<span class="hljs-string">&quot;itheima&quot;</span>);<br>        print(name);<br>        System.out.println(name + <span class="hljs-string">&quot;-after remove : &quot;</span> + threadLocal.get());<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>    System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + threadLocal.get());<br>    <span class="hljs-comment">//清除本地内存中的本地变量</span><br>    threadLocal.remove();<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>ThreadLocal的实现原理和源码分析</strong></p>
<p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009152048.png" style="zoom:80%;"></p>
<br>

<p><strong>set方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//根据当前线程对象，获取ThreadLocal中的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//如果map存在</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//执行map中的set方法，进行数据存储</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//否则创建ThreadLocalMap，并存值</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-comment">//位运算，结果与取模相同，计算出需要存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>get方法&#x2F;remove方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//根据线程对象，获取对应的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//获取ThreadLocalMap中对应的Entry对象</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">//获取Entry中的value</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">//确定数组下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//得到该位置上的Entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<p><strong>ThreadLocal内存泄漏问题</strong></p>
<p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p>
<ul>
<li><p>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure>


</li>
<li><p>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(user);<br></code></pre></td></tr></table></figure></li>
</ul>
<br>

<p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本<br><img src="/2023/10/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/20231009152817.png" style="zoom: 67%;"></p>
<br>

<p><strong>总结</strong></p>
<ol>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
<li>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li>ThreadLocal内存泄漏问题</li>
</ol>
<p>ThreadLocalMap 中的 key 是弱引用，值为强引用； key 会被GC 释放内存，关联 value 的内存并不会释放。建议主动 remove 释放 key，value</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-消息中间件面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-10-08T06:16:59.000Z" itemprop="datePublished">2023-10-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/">消息中间件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="消息中间件面试题"><a href="#消息中间件面试题" class="headerlink" title="消息中间件面试题"></a>消息中间件面试题</h2><p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142613.png" style="zoom:80%;">

<br>

<hr>
<h2 id="一-RabbitMQ"><a href="#一-RabbitMQ" class="headerlink" title="一. RabbitMQ"></a>一. RabbitMQ</h2><h3 id="1-RabbitMQ如何保证消息不丢失"><a href="#1-RabbitMQ如何保证消息不丢失" class="headerlink" title="1. RabbitMQ如何保证消息不丢失"></a>1. RabbitMQ如何保证消息不丢失</h3><ul>
<li>异步发送（验证码、短信、邮件…）</li>
<li>MYSQL和Redis , ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
<li>…</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142842.png" style="zoom:80%;">

<br>



<p><strong>生产者确认机制</strong></p>
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142859.png" style="zoom:80%;">

<p>消息失败之后的处理方法</p>
<ul>
<li>回调日志及时重新发送</li>
<li>记录日志</li>
<li>保存到数据库然后定时重新发送，成功发送后即刻删除表中的数据</li>
</ul>
<br>



<p><strong>消息持久化</strong></p>
<p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p>
<ol>
<li><p>交换机持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>队列持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 使用QueueBuilder构建队列，durable就是持久化的</span><br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>).build();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>消息持久化，SpringAMQP中的消息默认是成就的，可以通过MessageProperties中的DeliveryMode来指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化 </span><br>    .build();<br></code></pre></td></tr></table></figure></li>
</ol>
<br>



<p><strong>消费者确认</strong></p>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142929.png" style="zoom: 67%;">

<br>



<p><strong>RabbitMQ如何保证消息不丢失？</strong></p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008142955.png">

<br>



<hr>
<h3 id="2-RabbitMQ消息的重复消费问题"><a href="#2-RabbitMQ消息的重复消费问题" class="headerlink" title="2. RabbitMQ消息的重复消费问题"></a>2. RabbitMQ消息的重复消费问题</h3><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>都可能出现出现消费问题</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144204.png" style="zoom:67%;">

<p>解决方案：</p>
<ul>
<li>每条消息设置一个唯一的标识id</li>
<li>幂等方案：分布式锁、数据库锁（乐观锁、悲观锁）</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144223.png">



<br>



<hr>
<h3 id="3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列"><a href="#3-RabbitMQ中的死信交换机-RabbitMQ-延迟队列" class="headerlink" title="3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)"></a>3. RabbitMQ中的死信交换机(RabbitMQ 延迟队列)</h3><ul>
<li>延迟队列：进入队列的消息会被延迟消费的队列</li>
<li>场景：超时订单、限时优惠、定时发布</li>
</ul>
<p><font color="red">延迟队列 &#x3D; 死信交换机 + TTL</font></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144741.png" style="zoom:67%;">



<br>



<p><strong>死信交换机</strong></p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">ttlQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>) <span class="hljs-comment">// 指定队列名称，并持久化</span><br>        .ttl(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置队列的超时时间，10秒</span><br>        .deadLetterExchange(<span class="hljs-string">&quot;dl.direct&quot;</span>) <span class="hljs-comment">// 指定死信交换机</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144757.png" style="zoom:67%;">



<br>



<p><strong>TTL</strong></p>
<p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况:</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello, ttl message&quot;</span>).getBytes(StandardCharsets.UTF_8)<br>    .setExpiration(<span class="hljs-string">&quot;500&quot;</span>)<br>    .build();<br><span class="hljs-comment">// 消息Id，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008150212.png" style="zoom:67%;">



<br>



<p><strong>延迟队列插件</strong></p>
<p>DelayExchange插件，需要安装在RabbitMQ中</p>
<p>RabbitMQ有一个官方的插件社区，地址为：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> </p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008144916.png" style="zoom:50%;">

<p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindinds = @QueueBinding(</span><br><span class="hljs-meta">	value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">    key = &quot;delay&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayedQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>	log.info(<span class="hljs-string">&quot;接收到 delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder<br>    .withBody(<span class="hljs-string">&quot;hello,delayed message&quot;</span>.getBytes(StandardCharsets.UTF_8))<br>    .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">10000</span>)<br>    .build();<br><span class="hljs-comment">// 消息ID，需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, message, correlationData);<br></code></pre></td></tr></table></figure>



<br>



<p><strong>RabbitMQ中死信交换机？（RabbitMQ延迟队列有了解过吗？）</strong></p>
<ul>
<li><p>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布…）</p>
</li>
<li><p>其中延迟队列就用到了死信交换机和TTL（消息存活时间）实现的</p>
</li>
<li><p>消息超时未消费就会变成死信（死信的其他情况：拒绝被消费，队列满了）</p>
<p> 延迟队列插件实现延迟队列DelayExchange</p>
</li>
<li><p>声明一个交换机，添加delayed属性为true</p>
</li>
<li><p>发送消息时，添加x-delay头，值为超时时间</p>
</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008145005.png" style="zoom:80%;">



<br>



<hr>
<h3 id="4-消息堆积怎么解决"><a href="#4-消息堆积怎么解决" class="headerlink" title="4. 消息堆积怎么解决"></a>4. 消息堆积怎么解决</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008171008.png"></p>
<p>解决消费堆积问题有三种思路：</p>
<ul>
<li>增加更多的消费者，提高消费速度</li>
<li>在消费者内开启线程，也加快消费者的处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<br>

<p><strong>惰性队列</strong></p>
<p>惰性队列的特征：</p>
<ul>
<li>接收到消息之后直接存入磁盘而非内存中</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">lazyQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(lazy.queue)<br>        .lazy()<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(</span><br><span class="hljs-meta">    name = &quot;lzay.queue&quot;,</span><br><span class="hljs-meta">    durable = &quot;true&quot;,</span><br><span class="hljs-meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenLazyQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>	log.info(<span class="hljs-string">&quot;接收到 lazy.queue的消息:&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决）</strong></p>
<p>解决消息堆积有三种种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限，采用惰性队列<ul>
<li>在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
<br>



<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008170935.png" style="zoom:80%;">



<br>



<hr>
<h3 id="5-RabbitMQ的高可用机制"><a href="#5-RabbitMQ的高可用机制" class="headerlink" title="5. RabbitMQ的高可用机制"></a>5. RabbitMQ的高可用机制</h3><ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、镜像集群、仲裁集群</li>
</ul>
<br>

<p><strong>普通集群</strong></p>
<p>普通集群，或者叫标准集群，具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172034.png" style="zoom: 67%;">



<br>



<p><strong>镜像集群</strong></p>
<p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172121.png"></p>
<br>



<p><strong>仲裁集群</strong></p>
<p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">quorumQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(<span class="hljs-string">&quot;quorumqueue&quot;</span>) <span class="hljs-comment">// 持久化</span><br>        .quorum() <span class="hljs-comment">// 仲裁队列</span><br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<br>



<p><strong>RabbitMQ的高可用机制有了解过吗？</strong></p>
<ul>
<li>在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点</li>
<li>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li>
</ul>
<br>

<p><strong>那么出现丢数据怎么解决？</strong></p>
<p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。<br>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008172338.png" style="zoom:80%;">



<br>



<hr>
<h2 id="二-Kafka"><a href="#二-Kafka" class="headerlink" title="二. Kafka"></a>二. Kafka</h2><h3 id="1-Kafka是如何保证消息不丢失"><a href="#1-Kafka是如何保证消息不丢失" class="headerlink" title="1. Kafka是如何保证消息不丢失"></a>1. Kafka是如何保证消息不丢失</h3><p>使用Kafka在消息的收发过程都会出现消息丢失 , Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174022.png" style="zoom:67%;">



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步发送</span><br><span class="hljs-type">RecordMetadata</span> <span class="hljs-variable">recordMetadata</span> <span class="hljs-operator">=</span> kafkaProducer.send(record).get();<br><span class="hljs-comment">//异步发送</span><br>kafkaProducer.send(record, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息发送失败 | 记录日志&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> recordMetadata.offset();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> recordMetadata.partition();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> recordMetadata.topic();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置重试次数</span><br>prop.put(ProducerConfig.RETRIES_CONFIG,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174148.png" style="zoom: 80%;">

<br>

<table>
<thead>
<tr>
<th><strong>确认机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>acks&#x3D;0</td>
<td>生产者在成功写入消息之前不会等待任何来自服务器的响应,消息有丢失的风险，但是速度最快</td>
</tr>
<tr>
<td>acks&#x3D;1（默认值）</td>
<td>只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应</td>
</tr>
<tr>
<td>acks&#x3D;all</td>
<td>只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应</td>
</tr>
</tbody></table>
<br>

<p><strong>消费者从Brocker接受消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174218.png" style="zoom:67%;">

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174254.png" style="zoom:67%;">

<p>禁用自动提交偏移量，改为手动</p>
<ul>
<li>同步提交</li>
<li>异步提交</li>
<li>同步+异步组合提交</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>        <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>            System.outprintln(record.value());<br>            System.outprintln(record.key());<br>        &#125;<br>        consumer.commitAsync();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;记录错误消息: &quot;</span> + e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        consumer.commitSync();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        consumer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>Kafka是如何保证消息不丢失?</strong></p>
<p>需要从三个层面去解决这个问题：</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数</li>
</ul>
</li>
<li><p>消息在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
</ul>
</li>
</ul>
<br>

<p><strong>Kafka中消息的重复消费问题如何解决的</strong></p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步提交</li>
<li>幂等方案</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008174320.png" style="zoom:80%;">



<br>



<hr>
<h3 id="2-Kafka是如何保证消费的顺序性"><a href="#2-Kafka是如何保证消费的顺序性" class="headerlink" title="2. Kafka是如何保证消费的顺序性"></a>2. Kafka是如何保证消费的顺序性</h3><p>应用场景</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序</li>
</ul>
<br>

<p><strong>消费者从Brocker接收消息丢失</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191159.png" style="zoom: 80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定分区</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br><span class="hljs-comment">// 相同的业务key</span><br>kafkaTemplate.send(<span class="hljs-string">&quot;springboot-kafka-topic&quot;</span>, <span class="hljs-string">&quot;key-001&quot;</span>, <span class="hljs-string">&quot;value-0001&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<br>

<p><strong>Kafka是如何保证消费的顺序性？</strong></p>
<p>问题原因：<br>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>解决方案：</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
<br>



<p><img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191216.png"></p>
<br>



<hr>
<h3 id="3-Kafka的高可用机制"><a href="#3-Kafka的高可用机制" class="headerlink" title="3. Kafka的高可用机制"></a>3. Kafka的高可用机制</h3><ul>
<li>集群模式</li>
<li>分区备份机制</li>
</ul>
<br>



<p><strong>集群模式</strong></p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191749.png" style="zoom:67%;">

<ul>
<li>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成</li>
<li>这样如果集群中某一台机器宕机，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一</li>
</ul>
<br>

<p><strong>分区备份机制</strong></p>
<p>某个topic中有三个分区P0、P1、P2</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191830.png" style="zoom:67%;">

<ul>
<li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008191941.png" style="zoom:67%;">

<p>ISR（in-sync replica）需要同步复制保存的follower</p>
<p>如果leader失效后，需要选出新的leader，选举的原则如下：</p>
<ol>
<li>选举时优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</li>
<li>如果ISR列表中的follower都不行了，就只能从其他follower中选取</li>
</ol>
<br>

<p><strong>Kafka的高可用机制有了解过吗？</strong></p>
<p>可以从两个层面回答，第一个是集群，第二个是复制机制<br><strong>集群：</strong><br>一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务<br><strong>复制机制：</strong></p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
<br>

<p><strong>解释一下复制机制中的ISR</strong></p>
<p>ISR（in-sync replica）需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008192006.png" style="zoom:80%;">



<br>



<hr>
<h3 id="4-Kafka数据清理机制"><a href="#4-Kafka数据清理机制" class="headerlink" title="4. Kafka数据清理机制"></a>4. Kafka数据清理机制</h3><ul>
<li>Kafka文件存储机制</li>
<li>数据清理机制</li>
</ul>
<br>

<p><strong>Kafka文件存储机制</strong></p>
<p>存储结构</p>
<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193013.png" style="zoom:67%;">

<p>为什么要分段？</p>
<ul>
<li>删除无用文件方便，提高磁盘利用率</li>
<li>查找数据便捷</li>
</ul>
<br>

<p><strong>数据清理机制</strong></p>
<p>日志的清理策略有两</p>
<ol>
<li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。需手动开启</li>
</ol>
<br>

<p><strong>Kafka存储结构</strong></p>
<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li>
</ul>
<p><strong>日志的清理策略有两个</strong>：</p>
<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193052.png" style="zoom: 80%;">

<br>



<hr>
<h3 id="5-Kafka中实现高性能的设计"><a href="#5-Kafka中实现高性能的设计" class="headerlink" title="5. Kafka中实现高性能的设计"></a>5. Kafka中实现高性能的设计</h3><ul>
<li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li>
<li>顺序读写：磁盘顺序读写，提升读写效率</li>
<li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访</li>
<li>l零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
<br>

<img src="/2023/10/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20231008193617.png" style="zoom:80%;">

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-集合面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-10-05T08:50:53.000Z" itemprop="datePublished">2023-10-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/">集合</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005170605.png" style="zoom:80%;">

<br>

<hr>
<h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一. 数组"></a>一. 数组</h2><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005173522.png" style="zoom: 80%;">

<br>



<hr>
<h3 id="1-算法复杂度分析"><a href="#1-算法复杂度分析" class="headerlink" title="1. 算法复杂度分析"></a>1. 算法复杂度分析</h3><p><strong>时间复杂度：</strong> 用来评估代码的执行耗时</p>
<ul>
<li>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong></li>
<li>T(n)与代码的执行次数成正比(<strong>代码行数越多，执行时间越长</strong>)</li>
<li>当n很大时，公式中的低阶，常量，系数三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</li>
</ul>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005171736.png" style="zoom:67%;">

<br>



<p><strong>常见复杂度</strong></p>
<p>只要代码的执行时间不随着n的变化而变化，这样的代码时间复杂度就是O(1)，下面的两个例子的时间复杂度都是O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> i+j;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>        sum = sum+i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>时间复杂度为O(n)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sum = sum + i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>时间复杂度为O(n^2):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            sum = sum +  i * j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>时间复杂度为O(log n):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        i = i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>时间复杂度为O(n * log n):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test05</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;i&lt;=n;i++)&#123;<br>       test04(n);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        i = i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>



<p><strong>空间复杂度</strong></p>
<p>空间复杂度全称是<font color="red">渐进空间复杂度</font>，表示算法占用的额外<font color="red">存储空间</font>与<font color="red">数据规模之间</font>的增长关系<br>我们常见的空间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p>
<br>

<hr>
<h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h3><p>数组（Array）是一种用<font color="red">连续的内存空间</font>存储<font color="red">相同数据类型</font>数据的线性数据结构</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005173852.png" style="zoom:80%;">

<br>



<p><strong>数组如何获得其它元素的地址？</strong></p>
<p>寻址公式：a[i] &#x3D; baseAddress + i * dataTypeSize</p>
<ul>
<li>baseAddress： 数组的首地址</li>
<li>dataTypeSize：代表数组中元素类型的大小，int型的数据，dataTypeSize&#x3D;4个字节</li>
</ul>
<br>

<p><strong>为什么数组的索引从0开始而不是从1开始？</strong></p>
<ul>
<li>索引从0开始的寻址公式：a[i] &#x3D; baseAddress + i * dataTypeSize</li>
<li>索引从1开始的寻址公式：a[i] &#x3D; baseAddress +（ i  - 1 ）* dataTypeSize</li>
<li>在根据数组索引获取元素的时候，会用索引和寻址公式来计算内存所对应的元素数据，寻址公式是：数组的首地址+索引乘以存储数据的类型大小</li>
<li>如果数组的索引从1开始，寻址公式中，就需要增加一次减法操作，对于CPU来说就多了一次指令，性能不高。</li>
</ul>
<br>

<hr>
<h3 id="3-操作数组的时间复杂度"><a href="#3-操作数组的时间复杂度" class="headerlink" title="3. 操作数组的时间复杂度"></a>3. 操作数组的时间复杂度</h3><ul>
<li><p><strong>随机查询（根据索引查询）</strong></p>
<p>数组元素的访问是通过下标来访问的，计算机通过数组的首地址和寻址公式能够很快速的找到想要访问的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> a[i];<br>    <span class="hljs-comment">// a[i] = baseAddress + i * dataSize</span><br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>未知索引查询</strong></p>
<ul>
<li><p>情况一：查找数组内的元素，查找55号数据</p>
<p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005221650.png"></p>
</li>
<li><p>情况二：查找<font color="red">排序后</font>数组内的元素，查找55号数据</p>
<p>​	<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005221904.png" style="zoom:80%;"></p>
</li>
</ul>
</li>
<li><p><strong>插入、删除</strong></p>
<p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。<font color="red">最好情况下是O(1)的，最坏情况下是O(n)的，平均情况下的时间复杂度是O(n)</font></p>
</li>
</ul>
<br>

<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol>
<li><p>数组（Array）是一种用连续的内存空间存储相同数据类型数据的线性数据结构</p>
</li>
<li><p>数组下标为什么从0开始</p>
<p>寻址公式是：baseAddress+ i * dataTypeSize，计算下标的内存地址效率较高</p>
</li>
<li><p>查找的时间复杂度</p>
<ul>
<li><p>随机(通过下标)查询的时间复杂度是O(1)</p>
</li>
<li><p>查找元素（未知下标）的时间复杂度是O(n)</p>
</li>
<li><p>查找元素（未知下标但排序）通过二分查找的时间复杂度是O(log n)</p>
</li>
</ul>
</li>
<li><p>插入和删除时间复杂度</p>
<p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均时间复杂度为O(n)</p>
</li>
</ol>
<br>





<hr>
<h2 id="二-List"><a href="#二-List" class="headerlink" title="二. List"></a>二. List</h2><p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231005222728.png"></p>
<br>

<hr>
<h3 id="1-ArrayList源码分析"><a href="#1-ArrayList源码分析" class="headerlink" title="1. ArrayList源码分析"></a>1. ArrayList源码分析</h3><p><font face="仿宋">以下源码都来自jdk1.8</font></p>
<p><strong>成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 默认初始的容量(CAPACITY)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于空实例的共享空数组实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于默认大小的空实例的共享空数组实例。</span><br><span class="hljs-comment">* 我们将其与 EMPTY_ELEMENTDATA 区分开来，以了解添加第一个元素时要膨胀多少</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 存储 ArrayList 元素的数组缓冲区。 ArrayList 的容量就是这个数组缓冲区的长度。</span><br><span class="hljs-comment">* 当添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList</span><br><span class="hljs-comment">* 都将扩展为 DEFAULT_CAPACITY</span><br><span class="hljs-comment"> * 当前对象不参与序列化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ArrayList 的大小（它包含的元素数量）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = a.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c.getClass() == ArrayList.class) &#123;<br>            elementData = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            elementData = Arrays.copyOf(a, size, Object[].class);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>添加和扩容操作</strong></p>
<p>第1次添加数据</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006151913.png">

<br>

<p>第2-10次添加数据</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006152257.png" style="zoom:80%;">

<br>

<p>第11次添加数据</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006152352.png" style="zoom:80%;">

<br>



<hr>
<h3 id="2-ArrayList底层的实现原理"><a href="#2-ArrayList底层的实现原理" class="headerlink" title="2. ArrayList底层的实现原理"></a>2. ArrayList底层的实现原理</h3><ul>
<li><p>底层数据结构</p>
<p>ArrayList底层是用动态数组来实现的</p>
</li>
<li><p>初始容量</p>
<p>ArrayList初始容量为0，当第一次添加数据时才会初始化容量为10</p>
</li>
<li><p>扩容逻辑</p>
<p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p>
</li>
<li><p>添加逻辑</p>
<ul>
<li>确保数组已使用长度（size）加1之后足够存下下一个数据 </li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</li>
<li>返回添加成功布尔值。</li>
</ul>
</li>
</ul>
<br>

<p><strong>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构造一个具有指定初始容量的空列表。</span><br><span class="hljs-comment">* 参数：initialCapacity - 列表的初始容量</span><br><span class="hljs-comment">* 抛出：IllegalArgumentException – 如果指定的初始容量为负</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容 </p>
<br>



<hr>
<h3 id="3-如何实现数组和List之间的转换"><a href="#3-如何实现数组和List之间的转换" class="headerlink" title="3. 如何实现数组和List之间的转换"></a>3. 如何实现数组和List之间的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组转List</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testArray2List</span><span class="hljs-params">()</span>&#123;<br>    String[] strs = &#123;<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-string">&quot;ccc&quot;</span>&#125;;<br>    List&lt;String&gt; list = Arrays.asList(strs);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//List转数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList2Array</span><span class="hljs-params">()</span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>    String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[list.size()]);<br>    <span class="hljs-keyword">for</span> (String s : array) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>数组转List ，使用JDK中java.util.Arrays工具类的asList()方法</li>
<li>List转数组，使用List的toArray()方法。无参toArray()方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</li>
</ul>
<br>

<p><strong>用Arrays.asList转List后，如果修改了数组内容，list受影响吗?</strong></p>
<p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>
<br>

<p><strong>List用toArray转数组后，如果修改了List内容，数组受影响吗？</strong></p>
<p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p>
<br>



<hr>
<h3 id="4-单向链表"><a href="#4-单向链表" class="headerlink" title="4. 单向链表"></a>4. 单向链表</h3><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154119.png" style="zoom:80%;">

<ul>
<li>链表中的每一个元素称之为<font color="red">结点</font></li>
<li>物理<font color="red">存储单元上、非连接、非连续</font>的存储结构</li>
<li>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作<font color="red">后继指针next</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node(E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>单向链表时间复杂度分析</strong></p>
<ul>
<li><p>查询操作</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154635.png" style="zoom:80%;">

<ul>
<li>只有在查询头节点的时候不需要遍历链表，时间复杂度是O(1)</li>
<li>查询其他结点需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
<li><p>增删操作</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154756.png" style="zoom:80%;">

<ul>
<li>只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是O(1)</li>
<li>添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
<br>



<hr>
<h3 id="5-双向链表"><a href="#5-双向链表" class="headerlink" title="5. 双向链表"></a>5. 双向链表</h3><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006154953.png" style="zoom:80%;">

<p>双向链表，顾名思义它支持两个方向：</p>
<ul>
<li>每个结点不止有一个后继指针next指向后面的结点</li>
<li>有一个前驱指针prev指向前面的结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相对于单向链表</p>
<ul>
<li>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</li>
<li>支持双向遍历，这样也带来了双向链表操作的灵活性</li>
</ul>
<bt>



<p><strong>双向链表的时间复杂度分析</strong></p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006155521.png" style="zoom:80%;">

<p>查询操作：</p>
<ul>
<li>查询头尾结点的时间复杂度是O(1)</li>
<li>平均的查询时间复杂度是O(n)</li>
<li>给定节点找前驱节点的时间复杂度为O(1)</li>
</ul>
<p>增删操作：</p>
<ul>
<li>头尾结点增删的时间复杂度为O(1)</li>
<li>其他部分结点增删的时间复杂度是 O(n)</li>
<li>给定节点增删的时间复杂度为O(1)</li>
</ul>
<br>



<hr>
<h3 id="6-链表总结"><a href="#6-链表总结" class="headerlink" title="6. 链表总结"></a>6. 链表总结</h3><ol>
<li><p>单向链表和双向链表的区别是什么</p>
<ul>
<li><p>单向链表只有一个方向，结点只有一个后继指针 next。</p>
</li>
<li><p>双向链表它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点</p>
</li>
</ul>
</li>
<li><p>链表操作数据的时间复杂度是多少</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>查询</strong>  、增删</th>
</tr>
</thead>
<tbody><tr>
<td>单向链表</td>
<td>头O(1),其他O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>头尾O(1),其他O(n),给定节点O(1)</td>
</tr>
</tbody></table>
</li>
</ol>
<br>



<hr>
<h3 id="7-ArrayList和LinkedList的区别"><a href="#7-ArrayList和LinkedList的区别" class="headerlink" title="7. ArrayList和LinkedList的区别"></a>7. ArrayList和LinkedList的区别</h3><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231006160257.png">



<ol>
<li>底层数据结构<ul>
<li>ArrayList 是动态数组的数据结构实现</li>
<li>LinkedList 是双向链表的数据结构实现</li>
</ul>
</li>
<li>操作数据效率<ul>
<li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li>
<li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li>
<li>新增和删除<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li>内存空间占用<ul>
<li>ArrayList底层是数组，内存连续，节省内存</li>
<li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li>
</ul>
</li>
<li>线程安全<ul>
<li>ArrayList和LinkedList都不是线程安全的</li>
<li>如果需要保证线程安全，有两种方案：<ul>
<li>在方法内使用，局部变量则是线程安全的</li>
<li>使用线程安全的ArrayList和LinkedList</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>



<hr>
<h2 id="三-HashMap"><a href="#三-HashMap" class="headerlink" title="三. HashMap"></a>三. HashMap</h2><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007113838.png" style="zoom:80%;">

<br>

<hr>
<h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h3><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<font color="red">左子节点</font>和<font color="red">右子节点</font>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
<p>二叉树每个节点的<font color="red">左子树和右子树也分别满足二叉树的定义</font></p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007114127.png" style="zoom:67%;">

<br>



<p>Java中有两种方式实现二叉树：数组存储和链式存储</p>
<p>链式存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br>    TreeNode() &#123;&#125;<br>    TreeNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007114657.png" style="zoom: 80%;">

<br>



<p><strong>常见的二叉树有：</strong></p>
<ul>
<li>满二叉树</li>
<li>完全二叉树</li>
<li>二叉搜索树</li>
<li>红黑树</li>
</ul>
<br>



<p><strong>二叉搜索树</strong></p>
<p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p>
<p>二叉查找树要求，在树中的<font color="red">任意一个节点</font>，其<font color="red">左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</font></p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007115721.png" style="zoom:60%;">

<br>

<p><strong>二叉搜索树—时间复杂度</strong></p>
<p>由于二叉搜索树的形状各异，不同形状的二叉搜索树时间复杂度不同</p>
<ul>
<li><p>最好的情况时间复杂度为 O(log n)</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007115738.png" style="zoom:60%;">
</li>
<li><p>最差的情况时间复杂度为 O(n)</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007115800.png" style="zoom:60%;"></li>
</ul>
<br>

<p><strong>总结</strong></p>
<ol>
<li>什么是二叉树<ul>
<li>每个节点最多有两个“叉”，分别是左子节点和右子节点。</li>
<li>不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</li>
<li>二叉树每个节点的左子树和右子树也分别满足二叉树的定义</li>
</ul>
</li>
<li>什么是二叉搜索树<ul>
<li>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树</li>
<li>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值而右子树节点的值都大于这个节点的值</li>
<li>没有键值相等的节点</li>
<li>通常情况下二叉树搜索的时间复杂度为O(log n)</li>
</ul>
</li>
</ol>
<br>

<hr>
<h3 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2. 红黑树"></a>2. 红黑树</h3><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007120809.png" style="zoom:80%;">

<br>



<p><strong>红黑树的特质：</strong></p>
<ul>
<li>节点要么是红色，要么是黑色</li>
<li>根节点的黑色</li>
<li>叶子节点都是黑色的空节点</li>
<li>红黑树中红色节点的子节点都是黑色</li>
<li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li>
</ul>
<p>在添加或者删除节点的时候，如果不符合这些性质会发生旋转，以达到所有性质</p>
<br>



<p><strong>红黑树的时间复杂度</strong></p>
<ul>
<li><p>查找：</p>
<p>黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</p>
</li>
<li><p>添加：</p>
<p>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)添加完成后涉及到复杂度为O(1)的旋转调整操作</p>
</li>
<li><p>删除：</p>
<p>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)删除完成后涉及到复杂度为O(1)的旋转调整操作故整体复杂度为：O(log n)</p>
</li>
</ul>
<br>



<hr>
<h3 id="3-散列表"><a href="#3-散列表" class="headerlink" title="3. 散列表"></a>3. 散列表</h3><p>在HashMap中最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007121821.png" style="zoom:60%;">

<br>

<p>散列表(Hash Table)又名<font color="red">哈希表</font>，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是<font color="red">由数组演化而来</font>的，利用了数组支持按照下标进行随机访问数据的特性</p>
<p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p>
<br>



<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007121922.png" style="zoom: 67%;">

<p><font color="red">将键(key)映射为数组下标的函数叫做散列函数。</font>可以表示为：<font color="red">hashValue &#x3D; hash(key)</font></p>
<p>散列表的基本要求：</p>
<ul>
<li>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</li>
<li>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2）</li>
<li><strong>如果key1 !&#x3D; key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></li>
</ul>
<br>



<p><strong>散列冲突</strong></p>
<p>散列冲突（或者哈希碰撞、哈希冲突）就是指<font color="red">多个key映射到同一个数组下标位置</font></p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007121944.png" style="zoom: 67%;">

<p>使用链表能有效的解决散列冲突</p>
<br>



<p><strong>散列冲突—链表法</strong></p>
<p>在散列表中，数组的每个下标位置我们可以称之为<font color="red">桶</font>或者<font color="red">槽</font>，每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007122937.png">

<p><strong>链表法的时间复杂度</strong></p>
<ul>
<li><p>插入操作:</p>
<p>通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007123248.png" style="zoom: 67%;">
</li>
<li><p>查找、删除操作:</p>
<p>当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p>
<ul>
<li><p>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</p>
</li>
<li><p>散列表可能会退化为链表,查询的时间复杂度就从 O(1) 退化为 O(n)</p>
</li>
<li><p>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O(log n)</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007123305.png" style="zoom: 67%;"></li>
</ul>
</li>
</ul>
<p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止<font color="red">DDos攻击</font></p>
<br>

<p><strong>总结</strong></p>
<ol>
<li>什么是散列表？<ul>
<li>散列表(Hash Table)又名哈希表&#x2F;Hash表</li>
<li>根据键（Key）直接访问在内存存储位置值（Value）的数据结构</li>
<li>由数组演化而来的，利用了数组支持按照下标进行随机访问数据</li>
</ul>
</li>
<li>散列冲突<ul>
<li>散列冲突又称哈希冲突，哈希碰撞</li>
<li>指多个key映射到同一个数组下标位置</li>
</ul>
</li>
<li>散列冲突—链表法<ul>
<li>数组的每个下标位置称之为桶（bucket）或者槽（slot）</li>
<li>每个桶(槽)会对应一条链表</li>
<li>hash冲突后的元素都放到相同槽位对应的链表中或红黑树中</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="4-HashMap的实现原理"><a href="#4-HashMap的实现原理" class="headerlink" title="4. HashMap的实现原理"></a>4. HashMap的实现原理</h3><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p>
<ol>
<li>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 </li>
<li>存储时，如果出现hash值相同的key，此时有两种情况。 <ul>
<li>如果key相同，则覆盖原始值</li>
<li>如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中</li>
</ul>
</li>
<li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>
</ol>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007142138.png" style="zoom: 80%;">

<br>

<p><strong>JDK1.7和JDK1.8中HashMap有什么区别？</strong></p>
<ul>
<li>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>
<li>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</li>
</ul>
<br>



<p><strong>总结</strong></p>
<ol>
<li><p>HashMap的实现原理</p>
<ul>
<li>底层使用hash表数据结构，即数组+（链表 | 红黑树）</li>
<li>添加数据时，计算key的值确定元素在数组中的下标<ul>
<li>key相同则替换</li>
<li>不同则存入链表或红黑树中</li>
</ul>
</li>
</ul>
<p>获取数据通过key的hash计算数组下标获取元素</p>
</li>
<li><p>jdk1.7和jdk1.8中HashMap的区别</p>
<ul>
<li>JDK1.8之前采用的拉链法，数组+链表</li>
<li>JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="5-HashMap中put方法的具体流程"><a href="#5-HashMap中put方法的具体流程" class="headerlink" title="5. HashMap中put方法的具体流程"></a>5. HashMap中put方法的具体流程</h3><p><strong>HashMap源码分析—常见属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><span class="hljs-keyword">transient</span> HashMap.Node&lt;K,V&gt;[] table;<br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    HashMap.Node&lt;K, V&gt; next;<br>    Node(<span class="hljs-type">int</span> hash, K key, V value, HashMap.Node&lt;K, V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>DEFAULT_INITIAL_CAPACITY  默认的初始容量</li>
<li>DEFAULT_LOAD_FACTOR    默认的加载因子</li>
</ul>
<p><strong>扩容阈值 &#x3D;&#x3D; 数组容量  *  加载因子</strong></p>
<br>



<p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007143119.png"></p>
<ul>
<li>HashMap是懒惰加载，在创建对象时并没有初始化数组</li>
<li>在无参的构造函数中，设置了默认的加载因子是0.75</li>
<li></li>
</ul>
<br>



<p><strong>HashMap源码分析—添加数据</strong></p>
<p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007143158.png"></p>
<br>



<p><strong>HashMap的put方法的具体流程</strong></p>
<ol>
<li>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</li>
<li>根据键值key计算hash值得到数组索引</li>
<li>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</li>
<li>如果table[i]&#x3D;&#x3D;null ,不成立<ol>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</li>
<li>遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</li>
</ol>
</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li>
</ol>
<br>



<hr>
<h3 id="6-HashMap的扩容机制"><a href="#6-HashMap的扩容机制" class="headerlink" title="6. HashMap的扩容机制"></a>6. HashMap的扩容机制</h3><p><strong>扩容流程</strong></p>
<p><img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007143613.png"></p>
<br>

<p><strong>扩容机制</strong></p>
<ul>
<li>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li>
<li>每次扩容的时候，都是扩容之前容量的2倍； </li>
<li>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中<ul>
<li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li>
<li>如果是红黑树，走红黑树的添加</li>
<li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
</li>
</ul>
<br>



<p><strong>HashMap的寻址算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>扰动算法，使hash值更加均匀，减少hash冲突</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好。数组长度必须是2的n次幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span> &#123;<br>……<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>……<br>&#125;<br></code></pre></td></tr></table></figure>

<br>



<p><strong>为什么HashMap的数组长度一定是2的次幂？</strong></p>
<ol>
<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li>
<li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<br>



<p><strong>总结</strong></p>
<ol>
<li>HashMap的寻址算法<ul>
<li>计算对象的 hashCode()</li>
<li>再进行调用 hash() 方法进行二次哈希， hashcode值右移16位再异或运算，让哈希分布更为均匀</li>
<li>最后 (capacity – 1) &amp; hash 得到索引</li>
</ul>
</li>
<li>为什么HashMap的数组长度一定是2的次幂<ul>
<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li>
<li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ul>
</li>
</ol>
<br>



<hr>
<h3 id="7-HashMap在jdk1-7的情况下的多线程死循环问题"><a href="#7-HashMap在jdk1-7的情况下的多线程死循环问题" class="headerlink" title="7. HashMap在jdk1.7的情况下的多线程死循环问题"></a>7. HashMap在jdk1.7的情况下的多线程死循环问题</h3><p>jdk7的的数据结构是：数组+链表</p>
<p>在数组进行扩容的时候，因为链表是<font color="red">头插法</font>，在进行数据迁移的过程中，有可能导致死循环</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007145334.png" style="zoom:80%;">

<p>线程1和线程2的变量e和next都引用了这个两个节点</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007145401.png" style="zoom:80%;">

<p>线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点</p>
<img src="/2023/10/05/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/20231007145418.png" style="zoom:80%;">

<br>

<p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环<br>比如说，现在有两个线程<br>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入<br>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。<br>线程一：继续执行的时候就会出现死循环的问题。<br>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。<br>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p>
</bt>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-框架面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-09-28T01:23:21.000Z" itemprop="datePublished">2023-09-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/">框架</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928092648.png" style="zoom:80%;">

<br>



<hr>
<h3 id="1-单例bean是线程安全的吗？"><a href="#1-单例bean是线程安全的吗？" class="headerlink" title="1. 单例bean是线程安全的吗？"></a>1. 单例bean是线程安全的吗？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>范围</strong></th>
<th align="left"><strong>范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">（默认）将每个Spring IoC容器的单个 bean 定义范围限定为单个对象实例。</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">将单个 bean 定义的作用域限定为任意数量的对象实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个自己的 bean 实例，它是在单个 bean 定义的后面创建的。仅在可感知网络的 Spring 上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">将单个 bean 定义的范围限定为 HTTP 的生命周期 <code>Session</code>。仅在可感知网络的 Spring 上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
<tr>
<td align="left">application</td>
<td align="left">将单个 bean 定义的作用域限定为的生命周期 <code>ServletContext</code>。仅在可感知网络的Spring上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
<tr>
<td align="left">websocket</td>
<td align="left">将单个 bean 定义的作用域限定为的生命周期 <code>WebSocket</code>。仅在可感知网络的Spring上下文中有效 <code>ApplicationContext</code>。</td>
</tr>
</tbody></table>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093702.png" style="zoom: 80%;">

<br>

<p><strong>Spring框架中的单例bean是线程安全的吗？</strong></p>
<p>不是线程安全的</p>
<p>Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。</p>
<p>因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决</p>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230928093917.png" style="zoom:80%;">

<br>



<hr>
<h3 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h3><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>常见的AOP使用场景：</p>
<ul>
<li>记录操作日志</li>
<li>缓存处理</li>
<li>Spring中内置的事务处理</li>
</ul>
<br>

<p>Spring支持编程式事务管理和声明式事务管理两种方式。</p>
<ul>
<li>编程式事务控制：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li>
<li>声明式事务管理：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<br>



<p><strong>什么是AOP？</strong></p>
<p>面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</p>
<br>



<p><strong>项目中有没有使用到AOP？</strong></p>
<p>记录操作日志，缓存，spring实现的事务<br>核心是：使用AOP中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取到这些参数以后，保存到数据库</p>
<br>



<p><strong>Spring中的事务是如何实现的？</strong></p>
<p>其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142446.png" style="zoom:80%;">

<br>



<hr>
<h3 id="3-Spring中事务失效的场景有哪些？"><a href="#3-Spring中事务失效的场景有哪些？" class="headerlink" title="3. Spring中事务失效的场景有哪些？"></a>3. Spring中事务失效的场景有哪些？</h3><ul>
<li>异常捕获处理</li>
<li>抛出检查异常</li>
<li>非public方法</li>
</ul>
<br>



<p><strong>情况一：异常捕获处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer from, Integer to, Double money)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//转账的用户不能为空</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(from);<br>        <span class="hljs-comment">//判断用户的钱是否够转账</span><br>        <span class="hljs-keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="hljs-number">0</span>) &#123;<br>            fromAccount.setMoney(fromAccount.getMoney() - money);<br>            accountDao.updateById(fromAccount);<br>            <span class="hljs-comment">//异常</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//被转账的用户</span><br>            <span class="hljs-type">Account</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(to);<br>            toAccount.setMoney(toAccount.getMoney() + money);<br>            accountDao.updateById(toAccount);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p>
<p>解决：在catch块添加throw new RuntimeException(e)抛出</p>
<br>



<p><strong>情况二：抛出检查异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer from, Integer to, Double money)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-comment">//转账的用户不能为空</span><br>    <span class="hljs-type">Account</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(from);<br>    <span class="hljs-comment">//判断用户的钱是否够转账</span><br>    <span class="hljs-keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="hljs-number">0</span>) &#123;<br>        fromAccount.setMoney(fromAccount.getMoney() - money);<br>        accountDao.updateById(fromAccount);<br>        <span class="hljs-comment">//读取文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;dddd&quot;</span>);<br>        <span class="hljs-comment">//被转账的用户</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(to);<br>        toAccount.setMoney(toAccount.getMoney() + money);<br>        accountDao.updateById(toAccount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因：Spring默认只会回滚会异常检查</p>
<p>解决：配置rollbackFor属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor=Exception.class)</span><br></code></pre></td></tr></table></figure>

<br>



<p><strong>情况三：非public方法导致的事务失效</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer from, Integer to, Double money)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-comment">//转账的用户不能为空</span><br>    <span class="hljs-type">Account</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(from);<br>    <span class="hljs-comment">//判断用户的钱是否够转账</span><br>    <span class="hljs-keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="hljs-number">0</span>) &#123;<br>        fromAccount.setMoney(fromAccount.getMoney() - money);<br>        accountDao.updateById(fromAccount);<br>        <span class="hljs-comment">//读取文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;dddd&quot;</span>);<br>        <span class="hljs-comment">//被转账的用户</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> accountDao.selectById(to);<br>        toAccount.setMoney(toAccount.getMoney() + money);<br>        accountDao.updateById(toAccount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</p>
<p>解决：改为public方法</p>
<br>



<p><strong>Spring中事务失效的场景有哪些？</strong></p>
<ol>
<li>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出</li>
<li>抛出检查异常，配置rollbackFor属性为Exception</li>
<li>非public方法导致的事务失效，改为public</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930142522.png" style="zoom:80%;">

<br>



<h3 id="4-bean的生命周期"><a href="#4-bean的生命周期" class="headerlink" title="4. bean的生命周期"></a>4. bean的生命周期</h3><p>Spring容器在进行实例化时，会将xml配置的bean的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;userDao&quot;</span> class=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> lazy-init=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> class=<span class="hljs-string">&quot;com.itheima.service.UserServiceImpl&quot;</span> scope=<span class="hljs-string">&quot;singleton&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;userDao&quot;</span> ref=<span class="hljs-string">&quot;userDao&quot;</span>&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>beanClassName：bean 的类名</li>
<li>initMethodName：初始化方法名称</li>
<li>properryValues：bean 的属性值</li>
<li>scope：作用域</li>
<li>lazyInit：延迟初始化</li>
</ul>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143021.png" style="zoom:67%;">

<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143044.png" style="zoom:67%;">

<br>

<ol>
<li>通过BeanDefinition获取bean的定义信息：Spring首先通过BeanDefinition获取Bean的定义信息，包括类名、作用域、构造函数参数、属性值等</li>
<li>调用构造函数实例化bean：Spring通过反射机制调用Bean的构造函数或工厂方法来创建Bean的实例</li>
<li>bean的依赖注入：Spring将Bean的依赖注入到Bean的实例中</li>
<li>处理Aware接口：如果Bean实现了Aware接口（如BeanNameAware、BeanFactoryAware、ApplicationContextAware），Spring会调用相应的方法，让Bean获取到相关的资源<ul>
<li>BeanNameAware：实现该接口的Bean可以获取到Bean的名称</li>
<li>BeanFactoryAware：实现该接口的Bean可以获取到BeanFactory组件对象</li>
<li>ApplicationContextAware：实现该接口的Bean可以获取到ApplicationContext组件对象</li>
</ul>
</li>
<li>Bean的后置处理器BeanPostProcessor-前置：在Bean初始化之前，Spring会调用BeanPostProcessor的postProcessBeforeInitialization方法</li>
<li>初始化方法(InitializingBean、init-method)：Spring会调用Bean的初始化方法，这可能是InitializingBean接口的afterPropertiesSet方法，或者是在XML中通过init-method属性指定的方法</li>
<li>Bean的后置处理器BeanPostProcessor-后置：在Bean初始化之后，Spring会调用BeanPostProcessor的postProcessAfterInitialization方法</li>
<li>销毁bean</li>
</ol>
<br>

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930143901.png" style="zoom:80%;">

<br>



<hr>
<h3 id="5-Spring的循环依赖"><a href="#5-Spring的循环依赖" class="headerlink" title="5. Spring的循环依赖"></a>5. Spring的循环依赖</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144904.png" style="zoom:67%;">

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930144925.png" style="zoom:67%;">

<br>



<p><strong>三级缓存解决循环依赖</strong></p>
<p>Spring解决循环依赖是通过三级缓存，对应的三级缓存如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单实例对象注册器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSingletonBeanRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleAliasRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SingletonBeanRegistry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>(<span class="hljs-number">256</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>(<span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>缓存名称</strong></th>
<th><strong>源码名称</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObjects</td>
<td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象（生命周期还没走完）</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td>
</tr>
</tbody></table>
<br>



<p>一级缓存作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145429.png" style="zoom:67%;">

<br>



<p>如果要想打破循环依赖, 就需要一个中间人的参与, 这个中间人就是二级缓存</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145602.png" style="zoom:67%;">

<br>



<p>三级缓存：</p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930145817.png" style="zoom:67%;">

<br>



<p><strong>构造方法中出现了循环依赖怎么解决？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// B成员变量</span><br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(B b)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A的构造方法执行了...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.b = b ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">// A成员变量</span><br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(A a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B的构造方法执行了...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.a = a ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IS there an unresolvable circular reference?<br></code></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> B b)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A的构造方法执行了...&quot;</span>);<br>    <span class="hljs-built_in">this</span>.b = b ;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>



<p><strong>解释一下Spring中的循环引用？</strong></p>
<ul>
<li>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</li>
<li>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖<ol>
<li>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</li>
<li>二级缓存：缓存早期的bean对象（生命周期还没走完）</li>
<li>三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</li>
</ol>
</li>
</ul>
<p><strong>如果构造方法中出现了循环引用怎么解决？</strong></p>
<p>A依赖于B，B依赖于A，注入的方式是构造函数<br>原因：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br>解决方案：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p>
<br>

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930150448.png" style="zoom:80%;">

<br>



<hr>
<h3 id="6-SpringMVC的执行流程"><a href="#6-SpringMVC的执行流程" class="headerlink" title="6. SpringMVC的执行流程"></a>6. SpringMVC的执行流程</h3><ul>
<li>视图阶段（老旧JSP等）</li>
<li>前后端分离阶段（接口开发，异步）</li>
</ul>
<br>

<p><strong>视图阶段（JSP）</strong></p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930151957.png" style="zoom:80%;">

<ol>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>Controller执行完成返回ModelAndView对象</li>
<li>HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）</li>
<li>ViewReslover解析后返回具体View（视图）</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户</li>
</ol>
<br>



<p><strong>前后端分离阶段（接口开发，异步请求）</strong></p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152105.png" style="zoom:80%;">

<ol>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>方法上添加了@ResponseBody</li>
<li>通过HttpMessageConverter来返回结果转换为JSON并响应</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152520.png" style="zoom:67%;">

<br>



<hr>
<h3 id="7-SpringBoot自动装配原理"><a href="#7-SpringBoot自动装配原理" class="headerlink" title="7. SpringBoot自动装配原理"></a>7. SpringBoot自动装配原理</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930152852.png" style="zoom:67%;">

<ul>
<li>@SpringBootConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。</li>
<li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包。</li>
<li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解。</li>
</ul>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155116.png" style="zoom: 67%;">



<p><strong>SpringBoot自动配置原理</strong></p>
<ol>
<li>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
</li>
<li>其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。<br>内部就是读取了该项目和该项目引用的Jar包的的classpath路径下META-INF&#x2F;spring.factories文件中的所配置的类的全类名。 在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。</li>
<li>条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930155653.png" style="zoom:67%;">



<br>



<hr>
<h3 id="8-Spring框架常见注解"><a href="#8-Spring框架常见注解" class="headerlink" title="8. Spring框架常见注解"></a>8. Spring框架常见注解</h3><p><strong><font color="red">Spring 的常见注解</font></strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring  在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程（AOP）</td>
</tr>
</tbody></table>
<br>



<p><strong><font color="red">SpringMVC 的常见注解</font></strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将controller方法返回对象转化为json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<br>



<p><strong><font color="red">SpringBoot的常见注解</font></strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootConfiguration</td>
<td>组合了- @Configuration注解，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>打开自动配置的功能，也可以关闭某个自动配置的选</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring  在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程（AOP）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将controller方法返回对象转化为json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<br>



<hr>
<h3 id="9-MyBatis的执行流程"><a href="#9-MyBatis的执行流程" class="headerlink" title="9. MyBatis的执行流程"></a>9. MyBatis的执行流程</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161252.png" style="zoom:67%;">

<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161332.png" style="zoom:67%;">



<p><strong>Mybatis执行流程：</strong></p>
<ol>
<li>读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161555.png" style="zoom:67%;">

<br>



<hr>
<h3 id="10-Mybatis是否支持延迟加载"><a href="#10-Mybatis是否支持延迟加载" class="headerlink" title="10. Mybatis是否支持延迟加载"></a>10. Mybatis是否支持延迟加载</h3><p>Mybatis支持延迟记载，但默认没有开启</p>
<p><strong>什么叫做延迟加载？</strong></p>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161751.png" style="zoom:67%;">

<p>查询用户的时候，把用户所属的订单数据也查询出来，这个是立即加载<br>查询用户的时候，暂时不查询订单数据，当需要订单的时候，再查询订单，这个就是延迟加载</p>
<br>



<p><strong>延迟加载原理</strong></p>
<ol>
<li>使用CGLIB创建目标对象的代理对象</li>
<li>当调用目标方法user.getOrderList()时，进入拦截器invoke方法，发现user.getOrderList()是null值，执行sql查询order列表</li>
<li>把order查询上来，然后调用user.setOrderList(List<Order> orderList) ，接着完成user.getOrderList()方法的调用</Order></li>
</ol>
<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930161915.png" style="zoom:67%;">

<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162014.png" style="zoom:67%;">

<br>



<hr>
<h3 id="11-Mybatis的一级、二级缓存"><a href="#11-Mybatis的一级、二级缓存" class="headerlink" title="11. Mybatis的一级、二级缓存"></a>11. Mybatis的一级、二级缓存</h3><img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162117.png" style="zoom:67%;">

<ul>
<li>本地缓存，基于PerpetualCache，本质是一个HashMap</li>
<li>一级缓存：作用域是session级别</li>
<li>二级缓存：作用域是namespace和mapper的作用域，不依赖于session</li>
</ul>
<br>



<p><font color="red"><strong>一级缓存</strong></font>: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><span class="hljs-comment">//3. 执行sql</span><br><span class="hljs-comment">//3.1 获取UserMapper接口的代理对象</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper1</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper2</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper1.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user);<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> userMapper2.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user1);<br></code></pre></td></tr></table></figure>

<br>



<p><font color="red"><strong>二级缓存</strong></font>:是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession1</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><span class="hljs-comment">//3. 执行sql</span><br><span class="hljs-comment">//3.1 获取UserMapper接口的代理对象UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> userMapper1.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user1);<br>sqlSession1.close();<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper2</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> userMapper2.selectById(<span class="hljs-number">6</span>);<br>System.out.println(user2);<br><span class="hljs-comment">//4.关闭资源</span><br>sqlSession2.close();<br></code></pre></td></tr></table></figure>

<p>二级缓存默认是关闭的<br>开启方式，两步：</p>
<ol>
<li>全局配置文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;settings&gt;<br>    &lt;setting name=<span class="hljs-string">&quot;cacheEnabled&quot;</span> value=<span class="hljs-string">&quot;true</span><br><span class="hljs-string">&lt;/settings&gt;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>映射文件<br>使用<cache>标签让当前mapper生效二级缓存</cache></li>
</ol>
<p><font color="red">注意事项：</font></p>
<ol>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li>
<li>二级缓存需要缓存的数据实现Serializable接口</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ol>
<br>



<img src="/2023/09/28/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/20230930162915.png" style="zoom:67%;">

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-MySQL面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-09-17T13:17:17.000Z" itemprop="datePublished">2023-09-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">MySQL</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230917212620.png"></p>
<br>

<hr>
<h3 id="1-定位慢查询"><a href="#1-定位慢查询" class="headerlink" title="1. 定位慢查询"></a>1. 定位慢查询</h3><p><strong>在MySQL中如何定位慢查询？</strong></p>
<p>表象：页面加载慢、接口压测响应时间过长（超过1s）</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
<p>定位慢查询可以通过开源工具或者MySQL慢日志</p>
<p><strong>方案一：</strong></p>
<ul>
<li>调试工具： Arthas</li>
<li>运维工具：Prometheus、Skywalking</li>
</ul>
<br>



<p><strong>方案二：</strong></p>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志,如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启MySQL慢日志查询开关</span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span><br><span class="hljs-comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure>

<p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p>
<p> &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230918121511.png"></p>
<p>Query_time ：执行时间<br>select * from tb_sku: 执行的语句</p>
<br>



<p><strong>如何定位慢查询？</strong></p>
<ol>
<li><p>介绍一下当时产生问题的场景（我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟）</p>
</li>
<li><p>我们系统中当时采用了运维工具（ Skywalking ），可以监测出哪个接口，最终因为是sql的问题</p>
</li>
<li><p>在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中（调试阶段）</p>
</li>
</ol>
<br>



<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230918121741.png"></p>
<br>



<p><strong>一个SQL语句执行很慢，如何分析？</strong></p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919180453.png"></p>
<p>可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息</p>
<p>语法：</p>
<p>直接在select语句之前加上关键字 explain&#x2F;desc</p>
<p>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919180848.png"></p>
<p><strong>type</strong>	 这条sql的连接的类型，性能由好到差为NULL、system、const、eq_ref、ref、range、 index、all </p>
<ul>
<li><p>system：查询系统中的表</p>
</li>
<li><p>const：根据主键查询</p>
</li>
<li><p>eq_ref：主键索引查询或唯一索引查询</p>
</li>
<li><p>ref：索引查询</p>
</li>
<li><p>range：范围查询</p>
</li>
<li><p>index：索引树扫描</p>
</li>
<li><p>all：全盘扫描</p>
</li>
</ul>
<br>



<p><strong>那这个SQL语句执行很慢，如何分析？</strong></p>
<p>可以采用MySQL自带的分析工具 EXPLAIN</p>
<ul>
<li>通过key和key_len检查是否命中了索引（索引本身存在是否失效的情况）</li>
<li>通过type字段查看sql是否有进一步优化的空间，是否存在全索引扫描或全盘扫描</li>
<li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919181545.png"></p>
<br>



<hr>
<h3 id="2-索引概念及索引底层数据结构"><a href="#2-索引概念及索引底层数据结构" class="headerlink" title="2. 索引概念及索引底层数据结构"></a>2. 索引概念及索引底层数据结构</h3><p><strong>什么是索引？</strong></p>
<p><strong>索引</strong>（index）是帮助MySQL<font color="red">高效获取数据</font>的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<p><br><strong>B-Tree</strong>，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919201320.png" style="zoom:80%;">

<p>B-Tree有如下特点:</p>
<ol>
<li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找；</li>
</ol>
<br>

<p><strong>B+Tree</strong>是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919210535.png" style="zoom:80%;">

<p>B树与B+树对比:</p>
<p>①：磁盘读写代价B+树更低；②：查询效率B+树更加稳定；③：B+树便于扫库和区间查询</p>
<br>



<p><strong>了解过索引吗？（什么是索引）</strong></p>
<ul>
<li><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)</p>
</li>
<li><p>提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</p>
</li>
<li><p>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</p>
</li>
</ul>
<br>



<p><strong>索引的底层数据结构了解过吗？</strong></p>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
<br>



<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919211608.png" style="zoom:80%;">

<br>



<hr>
<h3 id="3-聚蔟索引和非聚蔟索引"><a href="#3-聚蔟索引和非聚蔟索引" class="headerlink" title="3. 聚蔟索引和非聚蔟索引"></a>3. 聚蔟索引和非聚蔟索引</h3><p>什么是聚集索引（聚蔟）？，什么是二级索引（非聚蔟索引）？，什么是回表？</p>
<ul>
<li><p>聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个</p>
</li>
<li><p>非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个</p>
</li>
</ul>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919214724.png" style="zoom:80%;">

<br>

<p><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919214814.png" style="zoom:80%;">

<br>

<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230919215043.png">

<br>





<hr>
<h3 id="4-覆盖索引和超大分页优化"><a href="#4-覆盖索引和超大分页优化" class="headerlink" title="4. 覆盖索引和超大分页优化"></a>4. 覆盖索引和超大分页优化</h3><p><strong>什么是覆盖索引？</strong></p>
<p><strong>覆盖索引</strong>是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922162045.png"></p>
<br>



<p><strong>MySQL超大分页处理</strong></p>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。我们一起来看看执行limit分页查询耗时对比：</p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922162946.png"></p>
<p>因为，当在进行分页查询时，如果执行 limit 9000000,10 ，此时需要MySQL排序前9000010 记录，仅仅返回 9000000 - 9000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
<p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *<br>from tb_sku t,<br>(select id from tb_sku order by id limit 9000000,10) a<br>where t.id = a.id;<br></code></pre></td></tr></table></figure>



<br>



<p><strong>知道什么叫覆盖索引吗？</strong></p>
<p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *</li>
</ul>
<br>



<p><strong>MySQL超大分页怎么处理？</strong></p>
<p>问题：在数据量比较大时，limit分页查询，需要对数据进行排序，效率低</p>
<p>解决方案：覆盖索引+子查询</p>
<br>



<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922163725.png"></p>
<br>



<hr>
<h3 id="5-索引创建原则"><a href="#5-索引创建原则" class="headerlink" title="5. 索引创建原则"></a>5. 索引创建原则</h3><p><strong>索引创建原则有哪些？</strong></p>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<br>

<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230922193945.png"></p>
<br>



<hr>
<h3 id="6-索引失效"><a href="#6-索引失效" class="headerlink" title="6. 索引失效"></a>6. 索引失效</h3><p>执行计划explain可以判断索引是否失效</p>
<p><strong>什么情况下索引会失效？</strong></p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123714.png"></p>
<br>

<ol>
<li><p>违反最左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引。如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123754.png" style="zoom:80%;"><br></p>
</li>
<li><p>范围查询右边的列，不能使用索引 <img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123830.png" style="zoom:80%;"><br></p>
</li>
<li><p>不要在索引列上进行运算操作， 索引将失效</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123923.png" style="zoom:80%;">

<br>


</li>
<li><p>字符串不加单引号，造成索引失效。由于，在查询时没有对字符串加单引号， MySQL的查询优化器，会自动的进行类型转换，造成索引失效</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924123954.png" style="zoom:80%;">

<br>


</li>
<li><p>以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924124018.png" style="zoom:80%;"></li>
</ol>
<br>

<p><strong>索引什么情况下会失效？</strong></p>
<ol>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行运算操作， 索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效</li>
</ol>
<br>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924124846.png" style="zoom:80%;">

<br>

<hr>
<h3 id="7-SQL的优化"><a href="#7-SQL的优化" class="headerlink" title="7. SQL的优化"></a>7. SQL的优化</h3><ul>
<li>表的设计优化</li>
<li>索引优化</li>
<li>SQL语句优化</li>
<li>主从复制、读写分离</li>
<li>分库分表</li>
</ul>
<p><strong>表的设计优化</strong></p>
<ol>
<li>比如设置合适的数值（tinyint  int  bigint），要根据实际情况选择</li>
<li>比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低</li>
</ol>
<br>

<p><strong>SQL语句优化</strong></p>
<ol>
<li><p>SELECT语句务必指明字段名称（避免直接使用select * ）</p>
</li>
<li><p>SQL语句要避免造成索引失效的写法</p>
</li>
<li><p>尽量用union all代替union  union会多一次过滤，效率低</p>
<p><strong>Union</strong>：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序</p>
<p><strong>Union All</strong>：对两个结果集进行并集操作，包括重复行，不进行排序</p>
</li>
<li><p>避免在where子句中对字段进行表达式操作</p>
</li>
<li><p>Join优化 能用inner join 就不用left join 和 right join，如必须使用 一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。left join 或 right join，不会重新调整顺序</p>
</li>
</ol>
<br>

<p><strong>主从复制，读写分离</strong></p>
<p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。读写分离解决的是，数据库的写入，影响了查询的效率。</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924131834.png" style="zoom:80%;">

<br>

<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924131943.png">

<br>



<hr>
<h3 id="8-事务"><a href="#8-事务" class="headerlink" title="8. 事务"></a>8. 事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p><strong>事务的特性（ACID）是什么？可以详细说一下嘛？</strong></p>
<ul>
<li>原子性（<strong>A</strong>tomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（<strong>C</strong>onsistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（<strong>I</strong>solation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（<strong>D</strong>urability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<br>

<p><strong>并发事务带来哪些问题？怎么解决这些问题呢？MySQL的默认隔离级别是？</strong></p>
<ul>
<li>并发事务问题：脏读、不可重复读、幻读</li>
<li>隔离级别：读未提交、读已提交、可重复读、串行化</li>
</ul>
<br>



<p><strong>并发事务问题</strong></p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140143.png" style="zoom:80%;">

<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140202.png" style="zoom:95%;">

<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140454.png" style="zoom:80%;">

<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140526.png" style="zoom: 80%;">

<br>



<p><strong>解决方案：</strong>对事务进行隔离</p>
<p>√ 表示存在该问题	× 表示不存在该问题</p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924140839.png" style="zoom:80%;">

<p><strong>注意</strong>：<font face="仿宋">事务隔离级别越高，数据越安全，但是性能越低</font></p>
<br>

<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924141542.png"></p>
<br>



<hr>
<h3 id="9-undo-log-和redo-log-的区别"><a href="#9-undo-log-和redo-log-的区别" class="headerlink" title="9. undo log 和redo log 的区别"></a>9. undo log 和redo log 的区别</h3><ul>
<li><strong>缓冲池（buffer pool）</strong>:主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页（page）</strong>:是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<br>

<p><strong>redo log</strong></p>
<p><strong>重做日志</strong>，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong>。</p>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p>
<br>



<p><strong>undo log</strong></p>
<p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : <font color="red">提供回滚 </font>和 <font color="red">MVCC</font>(多版本并发控制) 。undo log和redo log记录物理日志不一样，它是<font color="red">逻辑日志</font>。</p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</li>
</ul>
<p><font face="仿宋">undo log可以实现事务的一致性和原子性</font></p>
<br>

<p><strong>undo log  和 redo log 的区别</strong></p>
<ul>
<li>redo log: 记录的是数据页的物理变化，服务宕机可用来同步数据</li>
<li>undo log ：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据</li>
<li>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</li>
</ul>
<br>

<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230924153143.png" style="zoom:80%;">

<br>

<hr>
<h3 id="10-MVCC"><a href="#10-MVCC" class="headerlink" title="10. MVCC"></a>10. MVCC</h3><p>事务中的隔离性是如何保证的？</p>
<p>排他锁（如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）mvcc : 多版本并发控制</p>
<p><strong>MVCC-实现原理</strong></p>
<ul>
<li><p><strong>记录中的隐藏字段</strong></p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230926140006.png"></p>
</li>
<li><p><strong>undo log</strong></p>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p>
<p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p>
<p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</p>
</li>
</ul>
<br>

<p><strong>事务中的隔离性是如何保证的(MVCC)？</strong></p>
<p>MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p>
<ul>
<li><p><strong>隐藏字段</strong>：</p>
<ol>
<li>trx_id(事务id)，记录每一次操作的事务id，是自增的</li>
<li>roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</li>
</ol>
</li>
<li><p><strong>undo log</strong>：</p>
<ol>
<li>回滚日志，存储老版本数据</li>
<li>版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</li>
</ol>
</li>
<li><p><strong>ReadView</strong>解决的是一个事务查询选择版本的问题</p>
<ol>
<li><p>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据</p>
</li>
<li><p>不同的隔离级别快照读是不一样的，最终的访问的结果不一样</p>
<p>RC ：每一次执行快照读时生成ReadView</p>
<p>RR：仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</li>
</ol>
</li>
</ul>
<br>



<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928082723.png">

<br>



<hr>
<h3 id="11-MySQL主从同步原理"><a href="#11-MySQL主从同步原理" class="headerlink" title="11. MySQL主从同步原理"></a>11. MySQL主从同步原理</h3><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928082927.png" style="zoom: 80%;">

<p><strong>MySQL主从复制的核心就是二进制日志</strong></p>
<p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句</p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083110.png"></p>
<p>复制分成三步：</p>
<ol>
<li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li>
<li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ol>
<br>

<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083241.png"></p>
<br>



<hr>
<h3 id="12-分库分表"><a href="#12-分库分表" class="headerlink" title="12. 分库分表"></a>12. 分库分表</h3><p>分库分表的时机：</p>
<ol>
<li><strong>前提</strong>，项目业务数据逐渐增多，或业务发展比较迅速</li>
<li>优化已解决不了性能问题（主从读写分离、查询索引…）</li>
<li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询、连接数太多）</li>
</ol>
<br>

<p><strong>拆分策略</strong></p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083629.png" style="zoom:80%;">

<ul>
<li><p><strong>垂直分库</strong></p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928083745.png" style="zoom:80%;">

<p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p>
<p>特点：</p>
<ol>
<li>按业务对数据分级管理、维护、监控、扩展</li>
<li>在高并发下，提高磁盘IO和数据量连接数</li>
</ol>
<br>




</li>
<li><p><strong>垂直分表</strong></p>
<p><img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928090520.png"></p>
<p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p>
<p>特点：</p>
<ol>
<li>冷热数据分离</li>
<li>减少IO过渡争抢，两表互不影响</li>
</ol>
<p>拆分规则：</p>
<ul>
<li>把不常用的字段单独放在一张表</li>
<li>把text，blob等大字段拆分出来放在附表中</li>
</ul>
</li>
</ul>
<br>



<ul>
<li><p><strong>水平分库</strong></p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928090036.png" style="zoom:80%;">

<p>水平分库：将一个库的数据拆分到多个库中。</p>
<p>特点：</p>
<ol>
<li><p>解决了单库大数量，高并发的性能瓶颈问题</p>
</li>
<li><p>提高了系统的稳定性和可用性</p>
</li>
</ol>
<p>路由规则:</p>
<ul>
<li>根据id节点取模</li>
<li>按id也就是范围路由，节点1(1-100万 ),节点2(100万-200万)</li>
<li>…</li>
</ul>
<br>




</li>
<li><p><strong>水平分表</strong></p>
<img src="/2023/09/17/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/20230928090306.png" style="zoom:80%;">

<p>水平分表：将一个表的数据拆分到多个表中(可以在同一个库内)。</p>
<p>特点：</p>
<ol>
<li>优化单一表数据量过大而产生的性能问题;</li>
<li>避免IO争抢并减少锁表的几率;</li>
</ol>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-redis面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
      <time datetime="2023-09-11T07:14:28.000Z" itemprop="datePublished">2023-09-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/">redis</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="redis面试题"><a href="#redis面试题" class="headerlink" title="redis面试题"></a>redis面试题</h2><p>该笔记基于b站<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK?vd_source=db8e7458ec195ac74979ce">黑马程序员Java面试题</a>视频制作</p>
<p>redis的作用： </p>
<ul>
<li>缓存</li>
<li>分布式锁</li>
<li>消息队列、延迟队列</li>
<li>… …</li>
</ul>
<br>



<hr>
<h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>查询一个不存在的数据，MySQL查询不到数据，也不会把数据写入到缓存中，这样就会导致每次请求直接查询数据库</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910162308.png"></p>
<p>解决问题：</p>
<ol>
<li><p><strong>缓存空数据</strong>，查询返回数据为空时，也把这个空结果写入到缓存中</p>
<p>​	<strong>优点：</strong> 简单</p>
<p>​	<strong>缺点：</strong> 消耗内存，肯能会发生不一致问题（缓存空数据后，数据库又添加了这个数据，导致数据库存在该数据而缓存中又为空）</p>
</li>
<li><p><strong>布隆过滤器</strong></p>
</li>
</ol>
<p>​			<strong>bitmap（位图）:</strong> 相当于是一个以位（bit）为单位的数组，数组中每个单元只能存储二进制0或1</p>
<p>​			<strong>布隆过滤器的作用：</strong> 布隆过滤器可以用于检索一个元素是否在一个集合中</p>
<p>​			<strong>误判率：</strong> 数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗</p>
<p>​			<strong>优点：</strong> 内存占用较少，没有多余key</p>
<p>​			<strong>缺点：</strong> 存在误判，实现复杂</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910162955.png"></p>
<p>  <img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910163354.png"></p>
 <img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912102927.png">

<br>



<hr>
<h3 id="2-缓存刺穿"><a href="#2-缓存刺穿" class="headerlink" title="2. 缓存刺穿"></a>2. 缓存刺穿</h3><p>给某一个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求发送过来，这些请求可能会瞬间把数据库压垮</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230910164857.png"></p>
<p><strong>解决方案一：</strong> 互斥锁，强一致，性能差</p>
<p><strong>解决方案二：</strong> 逻辑过期，高可用，性能优，不能保证数据绝对一致</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912102445.png"></p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912102834.png" style="zoom:80%;">

<br>



<hr>
<h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h3><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，给数据库带来压力</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912103407.png"></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>给不同的key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性   哨兵模式 、集群模式</li>
<li>给缓存业务添加降级限流策略    Nginx或者spring cloud gateway     降级可做为系统的保底策略，适用于穿透、击穿、雪崩</li>
<li>给业务添加多级缓存  Guava、Caffeine</li>
</ul>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912103925.png"></p>
<br>



<p><strong>“缓存三兄弟”</strong></p>
<p>穿透无中生有key，布隆过滤null隔离</p>
<p>缓存击穿过期key，锁与非期解难题</p>
<p>缓存大量过期key，过期时间要随机</p>
<p>面试必考三兄弟，可用限流来兜底</p>
<br>



<hr>
<h3 id="4-双写一致性"><a href="#4-双写一致性" class="headerlink" title="4. 双写一致性"></a>4. 双写一致性</h3><p>面试官问：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</p>
<p><font color="red"><strong>一定</strong></font>要先设置前提，先介绍自己的业务背景，然后根据自己的业务背景进行回答，根据业务背景可划分两大类</p>
<ul>
<li>一致性要求高</li>
<li>允许延迟一致</li>
</ul>
<br>



<ol>
<li>介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以，我们当时采用的是异步的方案同步的数据（允许延迟一致）</li>
</ol>
<p><strong>解决方案： 采用异步通知</strong></p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912205428.png"></p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912205541.png"></p>
<br>





<ol start="2">
<li>我们当时是把抢券的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致，我们当时采用的是redisson提供的读写锁来保证数据的同步（一致性要求高）</li>
</ol>
<p><strong>解决方案： 采用Redisson提供的读写锁</strong></p>
<ul>
<li>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</li>
<li>排他锁：也叫独占锁writeLock，加锁之后，阻塞其他线程读写操作</li>
</ul>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912210739.png"></p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230914223534.png"></p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230914223616.png"></p>
<br>



<p><strong>双写一致性：</strong> 当修改了数据库中的数据后要更新缓存中的数据，即数据库的数据和缓存保存一致</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230912105518.png"></p>
<p><strong>读操作：</strong> 缓存命中，直接返回；缓存未命中，查询数据库，写入缓存，设定TTL</p>
<p><strong>写操作：</strong> <font color="red">延迟双删</font></p>
<p>​			删除缓存 	 &rarr; 	 修改数据库 	&rarr; （延时）	删除缓存</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230914224134.png" style="zoom:80%;">

<br>



<hr>
<h3 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5. 持久化"></a>5. 持久化</h3><p>在Redis中提供了两种持久化方式 RDB和AOF</p>
<br>



<p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915091601.png"></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到格式如下：</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915092105.png">



<p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li>
</ul>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915092855.png"></p>
<br>



<p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 是否开启AOF功能，默认是no<br>appendonly yes<br># AOF文件的名称<br>appendfilename &quot;appendonly.aof&quot;<br></code></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 表示每执行一次写命令，立即记录到AOF文件<br>appendfsync always <br># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案<br>appendfsync everysec <br># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘<br>appendfsync no<br><br></code></pre></td></tr></table></figure>



<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915094412.png"></p>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915094513.png" style="zoom:80%;">



<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs linux"># AOF文件比上次文件 增长超过多少百分比则触发重写<br>auto-aof-rewrite-percentage 100<br># AOF文件体积最小多大以上才触发重写 <br>auto-aof-rewrite-min-size 64mb <br><br></code></pre></td></tr></table></figure>

<br>



<p><strong>RDB与AOF对比</strong></p>
<p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中可以结合两者一起使用</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915094852.png" style="zoom: 80%;">



<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915095003.png" style="zoom: 67%;">

<br>





<hr>
<h3 id="6-数据过期策略"><a href="#6-数据过期策略" class="headerlink" title="6. 数据过期策略"></a>6. 数据过期策略</h3><p>Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）</p>
<br>



<p><strong>惰性删除：</strong> 设置该key过期时间后，我们不去管它，当需要该时key时，我们再检查是否过期，如果过期，我们就删除掉它，反之返回该key</p>
<p><strong>优点</strong> ：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p>
<p><strong>缺点</strong> ：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p>
<br>



<p><strong>定期删除：</strong>每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</p>
<p>定期清理有两种模式：</p>
<ul>
<li><p>lSLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的hz 选项来调整这个次数</p>
</li>
<li><p>lFAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>
</li>
</ul>
<p><strong>优点</strong>：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p>
<p><strong>缺点</strong>：难以确定删除操作执行的时长和频率。</p>
<p><strong>Redis的过期删除策略：</strong><font color="red">惰性删除 + 定期删除</font> 两种策略进行配合使用</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915102704.png" style="zoom:80%;">

<br>





<hr>
<h3 id="7-数据淘汰策略"><a href="#7-数据淘汰策略" class="headerlink" title="7. 数据淘汰策略"></a>7. 数据淘汰策略</h3><p><strong>数据的淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p>
<p>Redis支持8种不同策略来选择要删除的key：</p>
<ul>
<li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p>
</li>
<li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p>
</li>
<li><p>allkeys-random：对全体key ，随机进行淘汰。</p>
</li>
<li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。</p>
</li>
<li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p>
</li>
<li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p>
</li>
<li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p>volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰</p>
</li>
</ul>
<p><font face="仿宋"><strong>LRU</strong>（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</font></p>
<p><font face="仿宋"><strong>LFU</strong>（<strong>L</strong>east <strong>F</strong>requently <strong>U</strong>sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</font></p>
<br>



<p><strong>使用建议</strong></p>
<ol>
<li><p>优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</p>
</li>
<li><p>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。</p>
</li>
<li><p>如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。</p>
</li>
<li><p>如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。</p>
</li>
</ol>
<br>



<p>关于数据淘汰策略的其他问题</p>
<ol>
<li>数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?</li>
</ol>
<p>​	使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据</p>
<ol start="2">
<li>Redis的内存用完了会发生什么</li>
</ol>
<p>​	主要看数据淘汰策略是什么？如果是默认的配置（ noeviction ），会直接报错</p>
<br>



<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915104239.png" style="zoom:80%;">

<br>



<hr>
<h3 id="8-分布式锁"><a href="#8-分布式锁" class="headerlink" title="8. 分布式锁"></a>8. 分布式锁</h3><p>Redis实现分布式锁主要利用Redis的setnx命令。setnx是SET if not exists（如果不存在，则SET）的简写</p>
<ul>
<li><p>获取锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 添加锁，NX是互斥、EX是设置超时时间<br>SET lock value NX EX 10<br></code></pre></td></tr></table></figure>
</li>
<li><p>释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux"># 释放锁，删除即可<br>DEL key<br></code></pre></td></tr></table></figure>

<p>如果不给锁设置过期时间，获取锁的服务器宕机后，无法释放锁，会导致死锁问题</p>
<br></li>
</ul>
<p>Redis实现分布式锁如何合理地控制锁的有效时长？</p>
<ul>
<li>根据业务作息时间预估</li>
<li>给锁续期</li>
</ul>
<br>

<p>redisson实现分布式锁——执行流程</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915162207.png"></p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915162258.png" style="zoom:150%;">

<p><font face="仿宋" color="red">加锁、设置过期时间等操作都是基于lua脚本完成的</font></p>
<br>

<p>redisson实现分布式锁——可重入</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915165128.png"></p>
<br>
redis分布式锁，是如何实现的？

<ul>
<li>先按照自己简历上的业务进行描述分布式锁使用的场景</li>
<li>我们当使用的redisson实现的分布式锁，底层是<font color="red">setnx</font>f和<font color="red">lua脚本</font>（保证原子性）</li>
</ul>
<br>

<p>Redisson实现分布式锁如何合理的控制锁的有效时长？</p>
<p>在redisson的分布式锁中，提供了一个<font color="red">WatchDog</font>(看门狗），一个线程获取锁成功以后， WatchDog会给持有锁的线程<font color="red">续期（默认是每隔10秒续期一次）</font></p>
<br>

<p>Redisson的这个锁，可以重入吗？</p>
<p>可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的<font color="red">hash结构，来存储线程信息和重入的次数</font></p>
<br>

<p>Redisson锁能解决主从数据一致的问题吗？</p>
<p>不能解决，但是可以使用redisson提供的<font color="red">红锁</font>来解决，但是这样的话，<font color="red">性能就太低了</font>，如果业务中非要<font color="red">保证数据的强一致性</font>，建议采用<font color="red">zookeeper</font>实现的分布式锁</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230915170401.png" style="zoom:80%;">

<br>

<hr>
<h3 id="9-主从同步"><a href="#9-主从同步" class="headerlink" title="9. 主从同步"></a>9. 主从同步</h3><p>单节点Redis的并发能力是有上限的，要进一步提升Redis的能力，就需要搭建主从集群，实现读写分离</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917132857.png" style="zoom: 80%;">

<br>



<p>主从全量同步</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917133346.png" style="zoom: 80%;">

<p><font color="red">Replication id</font>: 简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p>
<p><font color="red">offset</font>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p>
<br>

<p>主从增量同步(slave重启或后期数据变化)</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917134053.png" style="zoom: 80%;">

<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917134215.png" style="zoom:80%;">



<br>



<p><strong>介绍一下redis的主从同步</strong></p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p>
<br>



<p><strong>能说一下，主从同步数据的流程</strong></p>
<p><strong>全量同步</strong></p>
<ol>
<li>从节点请求主节点同步数据（replication id、 offset ）</li>
<li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id和offset）</li>
<li>主节点执行bgsave，生成rdb文件后，发送给从节点去执行</li>
<li>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）</li>
<li>把生成之后的命令日志文件发送给从节点进行同步</li>
</ol>
<br>

<p><strong>增量同步</strong></p>
<ol>
<li>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</li>
<li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</li>
</ol>
<br>

<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917135453.png" style="zoom:80%;">

<br>



<hr>
<h3 id="10-哨兵模式"><a href="#10-哨兵模式" class="headerlink" title="10. 哨兵模式"></a>10. 哨兵模式</h3><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917141134.png" style="zoom: 67%;">

<ul>
<li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p>
</li>
<li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p>
</li>
<li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p>
</li>
</ul>
<br>



<p><strong>服务状态监控</strong></p>
<p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li>
</ul>
<br>



<p><strong>哨兵选主规则</strong></p>
<ul>
<li><p>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</p>
</li>
<li><p>然后判断从节点的slave-priority值，越小优先级越高</p>
</li>
<li><p><font color="red">如果slave-prority一样，则判断slave节点的offset值，越大优先级越高</font></p>
</li>
<li><p>最后是判断slave节点的运行id大小，越小优先级越高。</p>
</li>
</ul>
<br>



<p><strong>怎么保证Redis的高并发高可用</strong></p>
<p>哨兵模式：实现主从集群的自动故障恢复（监控、故障自动恢复、通知）</p>
<br>



<p><strong>你们使用redis是单点还是集群，那种集群？</strong></p>
<p>主从（1主1从）+哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同</p>
<br>



<p>redis集群脑裂是什么？怎么解决</p>
<p><font color="red">集群脑裂</font>是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失</p>
<p><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>
<br>



<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917152920.png" style="zoom:100%;">

<br>



<hr>
<h3 id="11-分片集群结构"><a href="#11-分片集群结构" class="headerlink" title="11. 分片集群结构"></a>11. 分片集群结构</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p>海量数据存储问题</p>
</li>
<li><p>高并发写的问题</p>
</li>
</ul>
<br>



<p>使用分片集群可以解决上述问题，分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点</p>
</li>
<li><p>master之间通过ping监测彼此健康状态</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
</li>
</ul>
<bt>



<p><strong>数据读写</strong></p>
<p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917154045.png" style="zoom:80%;">

<br>



<p><strong>redis的分片集群有什么作用？</strong></p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点</p>
</li>
<li><p>master之间通过ping监测彼此健康状态</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
</li>
</ul>
<br>



<p><strong>reids分片集群中数据是怎样存储和读取的？</strong></p>
<ul>
<li><p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽</p>
</li>
<li><p>将16384个插槽分配到不同的实例</p>
</li>
<li><p>读写数据：根据key的有效部分计算哈希值，对16384取余（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）余数做为插槽，寻找插槽所在的实例</p>
</li>
</ul>
<br>



<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917154457.png"></p>
<br>



<hr>
<h3 id="12-线程模型"><a href="#12-线程模型" class="headerlink" title="12. 线程模型"></a>12. 线程模型</h3><p><strong>redis是单线程的，但是为什么还那么快？</strong></p>
<ul>
<li>reids是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用I&#x2F;O多路复用模型，非阻塞IO</li>
</ul>
<p>Redis6引入了多线程机制，它有 “一个 worker线程+多个IO子线程”，其实就是在 IO 就绪之后使用多线程提升读写解析数据的效率，而在 操作内存数据的时候还是用单线程。<br>利用这种单线程+多线程共同运作的机制，将CPU的性能显著提升了。</p>
<p>目前所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，<strong>Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的</strong></p>
<br>

<p><strong>能解释一下I&#x2F;O多路复用模型吗？</strong></p>
<p>redis是存内存操作，执行速度非常快，它的性能瓶颈是<font color="red">网络延迟</font>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<ul>
<li><p>用户空间和内核空间</p>
</li>
<li><p>常见的IO模型</p>
<p>阻塞IO（Blocking IO）</p>
<p>非阻塞IO（Nonblocking IO）</p>
<p>IO多路复用（IO Multiplexing）</p>
</li>
<li><p>Redis网络模型</p>
</li>
</ul>
<br>



<p>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong></p>
<ul>
<li><p><strong>用户空间</strong>只能执行受限的命令（Ring3），而且不能直接调用系统资源 必须通过内核提供的接口来访问</p>
</li>
<li><p><strong>内核空间</strong>可以执行特权命令（Ring0），调用一切系统资源</p>
</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<ul>
<li><p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>
</li>
<li><p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>
</li>
</ul>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917161533.png" style="zoom:100%;">

<br>

<p><strong>阻塞IO</strong></p>
<p>阻塞IO就是两个阶段都必须阻塞等待：</p>
<p>阶段一：																					</p>
<ol>
<li><p>用户进程尝试读取数据（比如网卡数据）</p>
</li>
<li><p>此时数据尚未到达，内核需要等待数据</p>
</li>
<li><p>此时用户进程也处于阻塞状态</p>
</li>
</ol>
<p>阶段二：</p>
<ol>
<li><p>数据到达并拷贝到内核缓冲区，代表已就绪</p>
</li>
<li><p>将内核数据拷贝到用户缓冲区</p>
</li>
<li><p>拷贝过程中，用户进程依然阻塞等待</p>
</li>
<li><p>拷贝完成，用户进程解除阻塞，处理数据</p>
</li>
</ol>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917162821.png" style="zoom: 80%;">

<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态</p>
<br>



<p><strong>非阻塞IO</strong></p>
<p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p>
<p>阶段一：</p>
<ol>
<li><p>用户进程尝试读取数据（比如网卡数据）</p>
</li>
<li><p>此时数据尚未到达，内核需要等待数据</p>
</li>
<li><p>返回异常给用户进程</p>
</li>
<li><p>用户进程拿到error后，再次尝试读取</p>
</li>
<li><p>循环往复，直到数据就绪</p>
</li>
</ol>
<p>阶段二：</p>
<ol>
<li><p>将内核数据拷贝到用户缓冲区</p>
</li>
<li><p>拷贝过程中，用户进程依然阻塞等待</p>
</li>
<li><p>拷贝完成，用户进程解除阻塞，处理数据</p>
</li>
</ol>
<p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917163520.png" style="zoom:80%;">

<br>



<p><strong>IO多路复用</strong></p>
<p>是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p>阶段一：</p>
<ol>
<li><p>用户进程调用select，指定要监听的Socket集合</p>
</li>
<li><p>内核监听对应的多个socket</p>
</li>
<li><p>任意一个或多个socket数据就绪则返回readable</p>
</li>
<li><p>此过程中用户进程阻塞</p>
</li>
</ol>
<p>阶段二：</p>
<ol>
<li><p>用户进程找到就绪的socket</p>
</li>
<li><p>依次调用recvfrom读取数据</p>
</li>
<li><p>内核将数据拷贝到用户空间</p>
</li>
<li><p>用户进程处理数据</p>
</li>
</ol>
<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917163917.png" style="zoom:80%;">

<br>

<p>常见的监听Socket的方式、通知的方式：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p><strong>差异</strong></p>
<p>uselect和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket ，需要用户进程逐个遍历Socket来确认</p>
<p>uepoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间</p>
<br>

<p><strong>redis网络模型</strong></p>
<p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库</p>
<p><img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917164958.png"></p>
<br>

<p><strong>能解释一下I&#x2F;O多路复用模型吗？</strong></p>
<p>是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I&#x2F;O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p>
<br>

<p><strong>reids网络模型</strong></p>
<p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<ul>
<li><p>连接应答处理器</p>
</li>
<li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p>
</li>
<li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
</li>
</ul>
<br>

<img src="/2023/09/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/20230917164508.png" style="zoom: 80%;">

<p>&#96;&#96;</p>
</bt>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-我的第一篇博客文章" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/09/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="article-date">
      <time datetime="2023-09-10T01:55:32.000Z" itemprop="datePublished">2023-09-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>什么也没有！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2024 Zheng
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>